
\chapter{صوری‌گری جدید برای روش وارسی مدل}

محوریت کار ما قرار است\cite{calcul} باشد که در آن سعی شده روش وارسی مدل با کمک نظریه تعبیر مجرد، بهبود داده شود. در\cite{clarke} روشی که معرفی شده در‌واقع ویژگی برنامه‌ها را به کمک منطق های \lr{LTL} یا \lr{CTL} بیان می‌کند. خود برنامه‌ها هم با کمک معناشناسی این منطق ها که نوع خاصی از مدل های کریپیکی به اسم سیستم گذار هستند توصیف می شوند. اما در\cite{calcul} کاری که انجام شده به این شکل است که منطق های \lr{LTL} و \lr{CTL} با عبارات منظم\cite{kleene56} جایگزین شده‌اند. علت این کار دو نکته بوده، اولی اینکه استفاده از عبارات منظم به جای منطق های نام برده شده می‌تواند برای برنامه نویسان ساده‌تر باشد و دومی اینکه عبارت منظم از از منطق های نام برده شده قدرت بیان بالاتری دارد.\cite{regisbetter} در ادامه ی کار وارسی مدل با استفاده از موجودات جدید تعریف شده به سه شکل مختلف بیان شده. در هر مرتبه بیان وارسی مدل، به‌گفته‌ی نویسنده، "ساختارمند"تر شده. می‌توان دریافت که فایده ساختارمندتر بودن بیان این است که پیاده‌سازی راحت‌تری دارد.\\
حال به بیان و بررسی تعاریف و خواص آن‌ها می‌پردازیم.

\section{نحو زبان مورد بررسی‬}

زبان بیان برنامه ها زیرمجموعه ای از دستورات زبان \lr{C} است، به شکل زیر:
$$\mathsf{x,y},... \in \mathfrak{X}\hspace{4.65cm}$$
$$\mathsf{A} \in \mathfrak{A} ::=\mathsf{1\:|\:x\:|\:A_1 - A_2\hspace{2.4cm}}$$  
$$\mathsf{B \in \mathfrak{B} ::=A_1<A_2 \:|\: B_1 \: nand\: B_2\hspace{1.2cm}}$$
$$\mathsf{E \in \mathfrak{E}::= A \: | \: B\hspace{4cm}}$$
$$\mathsf{S\in \mathfrak{S} ::=\hspace{5cm}  }$$
$$\mathsf{x=A; \hspace{2.25cm}}$$
$$\mathsf{|\:\:\:;\hspace{3.75cm}}$$
$$\mathsf{|\:\:\:if\:(B)\:S\:|\:if\:(B)\:S\:else\:S}$$
$$\mathsf{|\:\:\:while\:(B)\:S\: | \: break;\hspace{0.65cm}}$$
$$\mathsf{|\:\:\:\{Sl\}\hspace{3.15cm}}$$
$$\mathsf{Sl \in \mathfrak{SL}::=Sl\:\:\:S\:|\:\epsilon}\hspace{3.05cm}$$
$$\mathsf{P\in \mathfrak{P}\:::=Sl}\hspace{4.25cm}$$

\vspace{1cm}
در اینجا زیر مجموعه‌ای از دستورات زبان \lr{C} را داریم. همین‌طور که قابل مشاهده است این زبان تا حد ممکن کوچک شده. علت این کار را بعدا عمیق‌تر حس خواهیم‌کرد. علتْ ساده‌تر شدن کار برای ارائه‌ی معناشناسی و تعبیر مجرد آن است. در اینجا راحتی آن برنامه‌نویسی که قرار است با این زبان برنامه بنویسد مطرح نبوده چون اصلا این زبان برای این کار ساخته نشده. نویسنده‌ی \cite{calcul} در اینجا صرفا می‌خواسته فرآیند را نشان دهد. اگر به فرض برای زبانی مانند پایتون بخواهیم درستی‌یابی با استفاده از روش ارائه شده را درست کینم، می‌توانیم همه‌ی راهی که در \cite{calcul} برای زبان توصیف شده، رفته‌شده را برای پایتون هم برویم و به یک تحلیل‌گر ایستا برای پایتون برسیم.
در مورد قدرت بیان این زبان هم می‌توانیم بگوییم که می‌توانیم باقی اعداد را از روی عدد ۱ و عملگر منها بسازیم. مثلا ابتدا 0 را به کمک ۱-۱ می سازیم و سپس با استفاده از 0 می‌توانیم یکی یکی اعداد منفی را بسازیم و سپس بعد از آن به سراغ اعداد مثبت می‌رویم که با کمک 0 و هر عدد منفی‌ای که ساختیم، ساخته می شوند. باقی اعداد و حتی باقی عملگر‌ها( یعنی به غیر از اعداد طبیعی) نیز از روی آنچه داریم قابل‌ساختن است. در مورد عبارت‌های بولی نیز داستان به همین منوال است. یعنی اینجا صرفا ادات شفر تعریف شده و باقی عملگر‌های بولی را می‌توان با استفاده از همین عملگر ساخت. باقی دستورات نیز دستورات شرط و حلقه هستند. باقی دستورات قرار است مطابق چیزی که از زبان \lr{C} انتظار داریم کار بکنند. در مورد دستور \lr{$\mathsf{break;}$} ذکر این نکته ضروری است که اجرای آن قرار است اجرای برنامه را از دستوری بعد از داخلی‌ترین حلقه‌ای که \lr{$\mathsf{break;}$} داخلش قرار دارد ادامه ‌دهد. در پایان می توان ثابت کرد که این زبان هم قدرت با مدل دیویس\cite{davis} است. 
توجه داریم که هر‌چه در این بخش در‌مورد معنای دستورات این زبان گفتیم، به هیچ وجه صوری نبود و صرفا درک شهودی ای که از معنای اجرای هر‌یک از دستورات داشتیم را بیان کردیم. بیان صوری معنای برنامه‌ها را، که برخلاف درک شهودی‌مان قابل انتقال به کامپیوتر‌ است، در ادامه بیان خواهیم‌کرد. طبیعتا این بیان صوری از روی یک درک شهودی ساخته شده‌است.

\section{معناشناسی زبان مورد بررسی‬}
معناشناسی زبانی را که در بخش پیش آوردیم با کمک مفاهیمی به نام برچسب و رد پیشوندی و عملگر چسباندن روی دو رود پیشوندی مختلف تعریف خواهیم‌کرد و نام این معناشناسی نیز معناشناسی رد پیشوندی است.\\

\subsection{برچسب‌ها}

با‌وجود اینکه خود زبان \lr{C} در قسمتی از زبان خود چیز‌هایی به نام برچسب دارد اما همین‌طور که در بخش پیشین دیدیم، در زبانی که اینجا در حال بحث روی آن هستیم خبری از برچسب‌ها نیست. اما برای تعریف صوری معنای برنامه‌ها، به شکلی که مورد بحث است، به آن‌ها نیاز است. در این بخش ابتدا به توضیحی مختصر در مورد برچسب‌ها در معناشناسی‌ زبان مورد بحث می‌پردازیم. تعاریف صوری دقیق این موجودات در پیوست \cite{calcul} آورده‌شده اند. برای اختصار از آوردن مستقیم این تعاریف در اینجا خود‌داری کرده‌ایم. 
در زبانمان \lr{$\mathsf{S}$}ها بخشی از موجودات موجود در زبان هستند. برچسب ها را برای \lr{$\mathsf{S}$}ها تعریف می‌کنیم. برچسب‌ها با کمک توابع \lr{labs, in, brks-of, brk-to, esc, aft, at} تعریف می‌شوند. در‌واقع هر $\mathsf{S}$ به ازای بعضی از این توابع یک برجسب دارد و این‌ها در‌واقع نشان‌دهنده‌ی آن برچسب هستند. بعض دیگر این توابع برای هر $\mathsf{S}$ ممکن است یک مجموعه از برچسب‌ها را تعیین‌ کند و یکی از آن‌ها هم با گرفتن $\mathsf{S}$ یک مقدار بولی را بر‌می‌گرداند. 
\\\\
\lr{at[$\mathsf{S}$]} : برچسب شروع $\mathsf{S}$\\
\lr{aft[$\mathsf{S}$]} : برچسب پایان $\mathsf{S}$، اگر پایانی داشته باشد\\
\lr{esc[$\mathsf{S}$]} : یک مقدار بولی را باز‌‌می‌گرداند که بسته به اینکه در $\mathsf{S}$ دستور $\mathsf{break;}$ وجود دارد یا خیر، مقدار درست یا غلط را بر‌می‌گرداند.\\
\lr{brk-to[$\mathsf{S}$]} : برچسبی است که اگر حین $\mathsf{S}$ دستور $\mathsf{break;}$ اجرا شود، برنامه از آن نقطه ادامه پیدا می کند.\\
\lr{brks-of[$\mathsf{S}$]} : مجموعه‌ای از برچسب $\mathsf{break;}$ های $\mathsf{S}$ را بر‌می‌گرداند.\\
\lr{in[$\mathsf{S}$]} : مجموعه‌ای از تمام برچسب‌های درون $\mathsf{S}$ را برمی‌گرداند.\\
\lr{labs[$\mathsf{S}$]} : مجموعه‌ای از تمام بر‌چسب‌هایی که با اجرای $\mathsf{S}$ قابل دسترسی هستند را بر‌می‌گرداند.\\\\\\


\subsection{رد پیشوندی}


پس از تعریف برچسب‌ها به سراغ تعریف رد پیشوندی می‌رویم. هر رد پیشوندی یک دنباله است که قرار است توصیفی از چگونگی اجرای برنامه باشد. اعضای دنباله وضعیت‌ها هستند. یک وضعیت، یک زوج مرتب $\langle l , \rho \rangle$ است. که در آن $l$ یک برچسب و $\rho$ یک محیط است. یک محیط تابعی است از مجموعه‌ی متغیر‌ها $\mathbb{X}$ به مجموعه‌ی مقادیر $\mathbb{V}$ و مجموعه‌ی خود وضعیت ها را هم با $\mathbb{S}$ نشان می‌دهیم. مجموعه‌ی محیط ها را نیز با $\mathbb{EV}$ نشان می‌دهیم. وضعیت‌ها همان‌طور که از نامشان پیداست قرار‌ است موقعیت لحظه‌ای برنامه را توصیف کنند. $l$ قرار است برچسب برنامه‌ی در حال اجرا باشد و $\rho$ مقدار متغیر‌ها را در آن موقع از اجرای برنامه نشان می‌دهد. دنباله‌های ما می‌توانند متناهی یا نامتناهی باشند. مجموعه‌ی ردهای پیشوندی‌ متناهی را با $\mathbb{S^+}$ و مجموعه‌ی ردهای پیشوندی نامتناهی را با  $\mathbb{S^\infty}$ نمایش می‌دهیم. مجموعه‌ی همه‌ی ردهای پیشوندی را هم با $\mathbb{S^{+\infty}}$ نمایش می‌دهیم. 
با‌توجه به آنچه گفتیم، یک عملگر چسباندن $\Join$ را روی ردهای پیشوندی تعریف می‌کنیم. اگر داشته باشیم 
$\pi_1 , \pi_2 \in \mathbb{S^{+\infty}}  , \sigma_1 ,\sigma_2 \in \mathbb{S}$
داریم:\\
\begin{center}
	اگر $\pi_1 \in \mathbb{S^+} $ داریم  $\hspace{2.60cm}  $                                     
	$\pi_1 \Join \pi_2 = \pi_1$    \\
	اگر $\sigma_1\neq\sigma_2$    $\hspace{1.6cm}  $
	$\pi_1 \Join \pi_2$ تعریف نشده است
	\\اگر $\pi_1 \in \mathbb{S^\infty} $ داریم   $\hspace{1cm}  $ 
	$\pi_1 \sigma_1 \Join \sigma_1 \pi_2 = \pi_1 \sigma_1 \pi_2 $
	
\end{center}

همین طور $\ni$ هم یک رد پیشوندی است که حاوی هیچ وضعیتی نیست. به عبارت دیگر یک دنباله‌ی تهی است.

\subsection{تعریف صوری معناشناسی رد پیشوندی}
در این بخش قرار است دو تابع $\mathcal{A}$ و $\mathcal{B}$ را به ترتیب روی عبارات حسابی و بولی زبانمان یعنی $\mathsf{A}$ها و $\mathsf{B}$ها تعریف کنیم سپس با کمک آنها $\mathcal{S^*}$ را روی  مجموعه‌ای از اجتماع معنای $\mathsf{S}$ها و $\mathsf{Sl}$ها تعریف می کنیم. پس در نهایت هدف ما تعریف  $\mathcal{S^*}$ است.
\\تعریف  $\mathcal{A}$ به این شکل است:\\
$$\mathcal{A[\mathsf{1}]\rho = }1     $$
$$\mathcal{A[\mathsf{x}]\rho = } \rho(\mathsf{x})          $$
$$\mathcal{A[\mathsf{A_1-A_2}]\rho = }\mathcal{A[\mathsf{A_1}]\rho }- \mathcal{A[\mathsf{A_2}]\rho }       $$



تعریف  $\mathcal{B}$ نیز به شکل زیر است:
\begin{center}
	اگر $\mathcal{A[\mathsf{A_1}]\rho }$ کوچکتر از $\mathcal{A[\mathsf{A_2}]\rho }$ باشد
	$\mathcal{B[\mathsf{A_1<A_2}]\rho = } True   \hspace{2cm}  $\\
	اگر $\mathcal{A[\mathsf{A_1}]\rho }$ بزرگتر از $\mathcal{A[\mathsf{A_2}]\rho }$ باشد
	$\mathcal{B[\mathsf{A_1<A_2}]\rho = } False   \hspace{2cm}  $\\
	$ \mathcal{B[\mathsf{B_1 nand B_2}]\rho = } \neg(\mathcal{B[\mathsf{B_1}]\rho}   \wedge \mathcal{B[\mathsf{B_2}]\rho}) $
\end{center}

که طبعا $\wedge$ و $\neg$ در فرازبان هستند.\\\\
در ادامه به تعریف $\mathcal{S^*}$ می‌پردازیم. این کار را با تعریف $\mathcal{S^*}$ روی هر ساخت $\mathsf{S}$ و $\mathsf{Sl}$ انجام می‌دهیم.
پیش از ادامه‌ی بحث باید این نکته را در‌مورد علامت‌گذاری‌هایمان ذکر کنیم که منظور از $        \mathsf{S} ::= l \mathsf{break;}  $ این است که تاکید کرده‌ایم که $\mathsf{S}$ با برچسب $l$ شروع شده‌است وگرنه همین طور که گفتیم   $l$ جزو زبان نیست.\\\\
اگر $        \mathsf{S} ::= \mathsf{break;}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S^*} [\mathsf{S}] = \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} \cup     \{ \langle at[\mathsf{S}] , \rho \rangle \langle brk-to[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \}             $$   


اگر $        \mathsf{S} ::=  \mathsf{x=A;}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S^*} [\mathsf{S}] = \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} \cup     \{ \langle at[\mathsf{S}] , \rho \rangle \langle aft[\mathsf{S}] , \rho[\mathsf{x}\leftarrow \mathcal{A}[\mathsf{A}]\rho] \rangle | \rho \in \mathbb{EV}       \}             $$   

اگر $         \mathsf{S} ::= \mathsf{if}  \mathsf{ (B) S_t}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S^*} [\mathsf{S}] = \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} \cup     \{ \langle at[\mathsf{S}] , \rho \rangle \langle aft[\mathsf{S}] , \rho \rangle | \mathcal{B}[\mathsf{B}] \rho =False      \} 
$$$$\cup    \{ \langle at[\mathsf{S}] , \rho \rangle \langle at[\mathsf{S_t}] , \rho \rangle 
\pi | \mathcal{B}[\mathsf{B}] \rho =True  \wedge   \langle  at[\mathsf{S_t}]  , \rho \rangle \pi \in \mathcal{S} [\mathsf{S_t}]    \}          $$ 


اگر $         \mathsf{S} ::= \mathsf{if}  \mathsf{ (B) S_t else S_f}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S} [\mathsf{S}] = \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} $$$$\cup     \{ \langle at[\mathsf{S}] , \rho \rangle \langle at[\mathsf{S_f}] , \rho \rangle 
\pi | \mathcal{B}[\mathsf{B}] \rho =False  \wedge   \langle  at[\mathsf{S_f}]  , \rho \rangle \pi \in \mathcal{S} [\mathsf{S_f}]    \}  
$$$$\cup    \{ \langle at[\mathsf{S}] , \rho \rangle \langle at[\mathsf{S_t}] , \rho \rangle 
\pi | \mathcal{B}[\mathsf{B}] \rho =True  \wedge   \langle  at[\mathsf{S_t}]  , \rho \rangle \pi \in \mathcal{S} [\mathsf{S_t}]    \}          $$ \\


اگر $         \mathsf{Sl} ::= \ni  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:

$$\mathcal{S} [\mathsf{Sl}] = \{ \langle at[\mathsf{Sl}] , \rho \rangle | \rho \in \mathbb{EV}       \}        $$ \\

اگر $         \mathsf{Sl} ::= \mathsf{Sl' \:\:\: S}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S} [\mathsf{Sl}] = \mathcal{S} [\mathsf{Sl'}] \cup( \mathcal{S} [\mathsf{Sl'}]
\Join \mathcal{S} [\mathsf{S}] )      $$ \\



اگر $         \mathsf{S} ::= \mathsf{while (B)S_b }   $ باشد، ماجرا نسبت به حالات قبل اندکی پیچیده‌تر می‌شود. تابعی به اسم $\mathcal{F} $ را تعریف خواهیم‌کرد که در حقیت دو ورودی دارد. ورودی اول آن یک دستور حلقه است و ورودی دوم آن یک مجموعه. به عبارتی دیگر می‌توانیم بگوییم به ازای هر حلقه یک تابع $\mathcal{F} $  جداگانه تعریف می‌شود که مجموعه‌ای از ردهای پیشوندی را می گیرد و مجموعه‌ای دیگر از همین موجودات را بازمی‌گرداند. کاری که این تابع قرار است انجام دهد این است که انگار یک دور دستورات داخل حلقه را اجرا می کند و دنباله‌هایی جدید را از دنباله‌های قبلی می‌سازد. معنای یک حلقه را کوچکترین نقطه ثابت این تابع در نظر می‌گیریم. در ادامه تعریف $\mathcal{F} $ آمده. با دیدن تعریف می توان به دلیل این کار پی‌برد. آن نقطه‌ای که دیگر $\mathcal{F} $ روی آن اثر نمی‌کند یا حالتی است که در آن دیگر شرط حلقه برقرار نیست و اصولا قرار نیست دستورات داخل حلقه اجرا شوند که طبق تعریف $\mathcal{F} $  می‌توانیم ببینیم که $\mathcal{F} $  در این حالت چیزی به ردهای پیشوندی اضافه نمی‌کند. یا اینکه حلقه به دستور $\mathsf{break;}$ خورده که در آن صورت وضعیتی به ته ردهای پیشوندی اضافه می‌شود که برچسبش خارج از مجموعه برچسب دستورات حلقه است و همین اضافه کردن هر چیزی را به ته ردهای پیشوندی موجود، توسط $\mathcal{F} $  غیرممکن می‌کند. بنابراین نقطه ثابت مفهوم مناسبی است برای اینکه از آن در تعریف صوری معنای حلقه استفاده کنیم. علت اینکه کوچکترین نقطه ثابت را به عنوان معنای حلقه در نظر می‌گیریم هم این است که مطمئن هستیم کوچکترین نقطه ثابت، هر رد پیشوندی ای را در خود داشته باشد به معنای اجرای برنامه مرتبط است. برای درک بهتر این نکته می‌توان به این نکته توجه کرد که با اضافه کردن وضعیت‌هایی کاملا بی‌ربط به اجرای برنامه به ته رد‌های پیشوندی، که صرفا برچسب متفاوتی با آخرین وضعیت هر رد پیشوندی دارند، نقطه ثابت جدیدی ساخته ایم. پس اگر خودمان را محدود به انتخاب کوچکترین نقطه ثابت نکنیم، به توصیفات صوری خوبی از برنامه‌ها دست پیدا نخواهیم‌کرد. در مورد نقطه ثابت تنها این نکته باقی می‌ماند که اصلا از کجا می‌دانیم که چنین نقطه ثابتی وجود دارد که در این صورت باید گفت مجموعه‌هایی که از ردهای پیشوندی تشکیل می‌شوند با عملگر زیرمجموعه بودن یک مشبکه را تشکیل می‌دهند و بنا به قضیه تارسکی\cite{tarski} برای چنین موجودی نقطه ثابت وجود دارد.
تعاریف موجوداتی که درموردشان صحبت کردیم به این شکل است:

$$\mathcal{S} [\mathsf{S}] = lfp^{\subseteq}\: \mathcal{F[\mathsf{S}]}      $$ $$\mathcal{F} [\mathsf{S}] X= \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} \cup $$
$$  \{ \pi_2 \langle l ,\rho \rangle \langle aft[\mathsf{S}],\rho \rangle |  \pi_2 \langle l ,\rho \rangle \in X \wedge \mathcal{B}[\mathsf{B}]\rho=False \wedge l= at[\mathsf{S}]   \} \cup      $$
$$  \{ \pi_2 \langle l ,\rho \rangle \langle at[\mathsf{S_b}],\rho \rangle \pi_3 |  \pi_2 \langle l ,\rho \rangle \in X \wedge \mathcal{B}[\mathsf{B}]\rho=True \wedge$$$$  \langle at[\mathsf{S_b}],\rho \rangle \pi_3 \in  \mathcal{S} [\mathsf{S_b}]   \wedge   l= at[\mathsf{S}]  \}  $$\\

اگر $         \mathsf{S} ::=;  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S} [\mathsf{S}] = \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} \cup     \{ \langle at[\mathsf{S}] , \rho \rangle \langle aft[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \}             $$  


اگر $         \mathsf{S} ::=\{\mathsf{Sl}\}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S} [\mathsf{S}] = \mathcal{S} [\mathsf{Sl}] $$   \\

\section{ویژگی‌های معنایی برنامه‌ها}
تا به اینجای کار یک زبان آورده‌ایم و برای آن معنا تعریف کرده‌ایم. در این فصل می‌خواهیم در مورد ویژگی‌های برنامه‌هایی که در این زبان نوشته می‌شوند با توجه به معنای صوری‌ای که تعریف کرده‌ایم، صحبت کنیم. دقت شود که برای برنامه‌هایی که در یک زبان برنامه‌نویسی نوشته می‌شوند می‌توان به اشکال مختلفی ویژگی تعریف کرد؛ مثلا ویژگی‌های نحوی، مثل اینکه طول برنامه چند خط است یا هر کاراکتر چند بار به کار رفته، یا ویژگی‌های محاسباتی، مثل بررسی‌ سرعت برنامه یا میزان استفاده‌ی آن از حافظه که عموما در نظریه الگوریتم و پیچیدگی محاسبات بررسی می‌شود. منظور ما در اینجا از تعریف ویژگی، متناسب است با معناشناسی‌ای که برای برنامه‌هایمان تعریف کرده‌ایم. معناشناسی‌ای که تعریف کرده‌ایم درواقع سیر محاسباتی برنامه را توصیف می‌کند و ما می‌خواهیم ویژگی‌ها را با توجه به این موصوع تعریف کنیم. در این صورت می‌توانیم صحت عملکرد برنامه‌ها را با توجه به صادق بودن ویژگی‌هایی که در مورد آن‌ها تعریف شده بفهمیم.\\
ابتدا به تعریف ویژگی‌ها می‌پردازیم، سپس به سراغ تعریف یک نوع عبارت منظم می‌رویم که از آن برای بیان ویژگی‌ها استفاده می‌شود.
\subsection{ویژگی‌های معنایی}
همان‌طور که در بخش قبلی دیدیم، معنای هر برنامه با یک مجموعه‌ی 
$\mathcal{S^*} [\mathsf{S}]$
مشخص می‌شود. وقتی می‌خواهیم ویژگی‌هایی را برای موجوداتی که به کمک مجموعه‌ها تعریف شده اند بیان کنیم، اینکه ویژگی‌ها را هم با مجموعه‌ها بیان کنیم کار معقولی به نظر می‌رسد. مثل اینکه بخواهیم ویژگی زوج بودن را در مورد اعداد طبیعی بیان کنیم. می توانیم مجموعه‌ی $\mathbb{E}$ را به عنوان مجموعه‌ی همه‌ی اعداد زوج در نظر بگیریم و اینکه یک عدد زوج هست یا نه را عضویتش در مجموعه‌ی $\mathbb{E}$ تعریف کنیم. پس یعنی در مورد اعداد طبیعی قرار است هر ویژگی به شکل زیرمجموعه‌ای از تمام این اعداد در نظر گرفته شود. یعنی هر عضو 
$\mathit{P}(\mathbb{N})$
بنا به تعریف ما یک ویژگی از اعداد طبیعی است.
در مورد برنامه‌ها نیز قرار است همین رویه را پیش بگیریم. تابع 
$\mathcal{S^*}$
از نوع 
$\mathfrak{P} \rightarrow \mathit{P}(\mathbb{S^+})$
است. یعنی یک برنامه را در ورودی می‌گیرد و یک مجموعه از ردهای پیشوندی را باز می‌گرداند. پس می‌توانیم هر ویژگی را به عنوان زیر مجموعه‌ای از 
$\mathit{P}(\mathbb{S^+})$
تعریف کنیم، به عبارت دیگر عضوی از
$\mathit{P(P}(\mathbb{S^+}))$.

\subsection{عبارات منظم}
در اینجا توصیف ویژگی‌ها برای هر برنامه باید یک چارچوب داشته باشد. در صورت قدیمی روش وارسی مدل ما از منطق های زمانی برای بیان ویژگی‌ها به صورت صوری استفاده می‌کردیم و این احتیاج به یک زبان برای صوری کردن کامل کار را، که رسیدن به بیان مسئله‌ی وارسی مدل است، به ما نشان می‌دهد. در اینجا ما با داستان دیگری هم رو به رو هستیم و آن این است که از آنجایی که با مجموعه‌ها سر و کار داریم و مجموعه‌ها چندان موجودات ساختنی‌ای نیستند( برخلاف مدل کریپکی)، بهتر است یک موجود ساختنی مثل یک زبان صوری برای بیان آن‌ها داشته باشیم. در این فصل قصد داریم یک نوع عبارت منظم را برای این منظور تعریف کنیم. ابتدا زبان این عبارت منظم را تعریف می‌کنیم، سپس به سراغ معناشناسی آن می‌رویم. 
\subsection{زبان عبارات منظم}
فرق عمده‌ای که زبان عبارات منظم ما با عبارات منظم کلاسیک دارد در کاراکترهاست. کاراکترها در زبان کلاسیک موجوداتی اتمی بودند، اما در اینجا ساختار دارند. در اینجا به جای هر کاراکتر یک زوج متشکل از مجموعه‌ی $\mathsf{L}$ و عبارت بولی $\mathsf{B}$ تشکیل شده‌اند که این زوج را به شکل 
$\mathsf{L : B}$
در زبانمان نمایش می‌دهیم.\\ 
زبان ما به شکل BNF زیر است:
$$\mathsf{L} \in \mathit{P}(\mathbb{L})$$        
$$\mathsf{x,y,...} \in \mathbb{X}$$
$$\mathsf{\underline{x},\underline{y},...} \in \mathbb{\underline{X}}$$
$$\mathsf{B} \in \mathbb{B}$$
$$\mathsf{R} \in \mathbb{R}$$
\newpage
$$\mathsf{R} ::=\hspace{0.5cm} \varepsilon\hspace{4.2cm}$$
$$|\:\:\:\mathsf{L : B}\hspace{2.4cm}$$
$$|\:\:\:\mathsf{R_1 R_2}\:\:\:(or\:\mathsf{R_1 \bullet R_2 })$$
$$\:\:\:\:\:\:\:|\:\:\:\mathsf{R_1\:\mid\:R_2}\:\:\:(or\:\mathsf{R_1 + R_2 })$$
$$|\:\:\:\mathsf{R_1^*}\hspace{2.8cm}$$
$$|\:\:\:\mathsf{R_1^+}\hspace{2.7cm}$$
$$|\:\:\:(\mathsf{R_1})\hspace{2.47cm}$$

همان طور که قابل مشاهده است در اینجا عملگرهای دوتایی چسباندن
$(\bullet)$
 و انتخاب
$(|)$
 را داریم، به همراه عملگرهای یگانی 
$^*$
و
$^+$.
در ادامه خواهیم دید که در فرازبان معنی عملگر یگانی 
$^+$
به وسیله‌ی عملگر یگانی دیگر قابل بیان است، هرچند که در زبانمان هم برای سهولت کار از بیان این عملگر اجتناب نشده. 
توجه شود که پرانتزها هم جزئی از زبان قرار داده شده‌اند.


همین‌طور در اینجا می‌خواهیم از تعدادی عبارات مخفف که در ادامه کارمان را راحت‌تر می‌کنند صحبت کنیم. منظور از زوج 
$\mathsf{? : B}$
همان 
$\mathbb{L}\mathsf{ : B}$
است. عبارت 
$l : \mathsf{B}$
به جای عبارت 
$\{l\} : \mathsf{B}$
به کار می‌رود و منظور از عبارت 
$\neg l \mathsf{: B}$
نیز عبارت 
$\mathbb{L}\backslash\{l\}:\mathsf{B}$
است.

با یک نگاه به دستور این زبان یک نکته‌ی چشمگیر برای ما، با توجه به موجوداتی که در بخش قبل تعریف کردیم، با نگاه به قواعد این زبان می‌تواند وجود یک مجموعه‌ی
$\mathbb{\underline{X}}$
در کنار 
$\mathbb{X}$
که از قبل داشتیم باشد. قرار است به ازای هر 
$\mathsf{x}\in\mathbb{X}$
یک 
$\mathsf{\underline{x}}\in\mathbb{\underline{X}}$
داشته‌باشیم. منظور از 
$\mathsf{\underline{x}}$
مقدار متغیر 
$\mathsf{x}$
در ابتدای هر برنامه است. این یعنی تابع
$\underline{\rho}: \mathbb{\underline{X}} \rightarrow \mathbb{V}$
که 
$\mathbb{V}$
مجموعه‌ی مقادیر متغیرهاست( در بخش قبل به این اشاره نشد اما خود
$\rho$
هایی که در بخش قبل داشتیم هم از نوع
$\mathbb{X} \rightarrow \mathbb{V}$
بود. با توجه به زبانمان و توضیحاتی که در گذشته دادیم، می‌توان در نظر گرفت که در اینجا 
$\mathbb{V}$
همان 
$\mathbb{Z}$
یعنی اعداد صحیح است. دلیل استفاده از نماد
$\mathbb{V}$
به عنوان مجموعه مقادیر این است که روح کلی نگرانه‌ی کار حفظ شود). همان‌طور که پیش‌تر گفتیم برای اشاره به یک تابع
$\rho$
از کلمه‌ی "محیط" استفاده می‌شود. به همین منوال در ادامه برای اشاره‌ به 
$\underline{\rho}$
از "محیط اولیه" استفاده می‌کنیم. برای اشاره به مجموعه‌ی همه‌ی محیط‌های اولیه هم از نماد 
$\underline{\mathbb{EV}}$
استفاده می‌کنیم.
بقیه‌ی موجودات از جمله برچسب‌ها و عبارات بولی را هم که قبلا داشتیم.\\
در ادامه به بیان صوری معنای زبان بیان شده می‌پردازیم. پس از آن می‌توانیم با بررسی چند مثال، از اینکه معنای هر عبارت منظم چیست درکی شهودی به دست آوریم.\\

\subsection{معناشناسی عبارات منظم}
معنای عبارات منظم را با استفاده از تابع 
$\mathcal{S}^r$
نشان می‌دهیم. این تابع به این شکل تعریف می‌شود که در ورودی یک عبارت منظم 
$\mathsf{R}$
را می‌گیرد، سپس یک مجموعه از زوج مرتب‌های( یا همان‌طور که پیش‌تر نام‌گذاری کردیم "حالت‌ها"ی)
$\langle\underline{\rho} , \pi\rangle$
را که 
$\pi \in \mathbb{S^*}$
و 
$\underline{\rho} \in \underline{\mathbb{EV}}$
باز می‌گرداند. بنابراین این تابع از نوع
$\mathbb{R} \rightarrow \mathit{P} (\mathbb{\underline{EV} \times S^*})$
است. همین‌طور دقت شود که تا به حال از 
$\mathbb{S}^*$
صحبتی نکرده بودیم و فقط 
$\mathbb{S}^+$
را معرفی کرده بودیم. 
$\mathbb{S}^*$
نیز برابر است با
$\mathbb{S}^+ \cup \{\epsilon\}$ 
(به لحاظ معنایی همان عملگر
$^*$
است که در زبان عبارات منظمهم هست، مشهور به ستاره‌ی کلینی).

تعریف استقرایی تابع 
$\mathcal{S}^r$
به شکل زیر است:

$$\mathcal{S}^r[\varepsilon]= \{ \langle \underline{\rho} , \epsilon \rangle | \underline{\rho} \in \underline{\mathbb{EV}}\}$$
[یعنی معنای عبارت منظم
$\varepsilon$
مجموعه‌ای شامل حالت‌هایی از محیط‌های اولیه‌ی مختلف در کنار رد پیشوندی تهی استفاده می‌کند.]
$$\mathcal{S}^r[\mathsf{L:B}] = \{\langle\underline{\rho},\langle l , \rho \rangle \rangle | l \in \mathsf{L} \land \mathcal{B}[\mathsf{B}] \underline{\rho},\rho \}$$
[این یعنی معنای عبارت 
$\mathcal{S}^r[\mathsf{L:B}]$
حالت‌هایی هستند که عضو اول آن‌ها محیط‌های اولیه مختلف هستند( مانند مورد قبلی و البته در موارد آتی!) و عضو دوم آن‌ها ردهای پیشوندی تک‌عضوی 
$\langle l , \rho \rangle$
هستند که در آن‌ها برچسب 
$l$
باید در
$\mathsf{L}$
که مجموعه‌ای از برچسب‌هاست حضور داشته باشد و عبارت بولی 
$\mathsf{B}$
باید درباره‌ی محیط اولیه
$\underline{\rho}$
و محیط 
$\rho$
برقرار باشد. حتما متوجه این نکته شدید که 
$\mathcal{B}$
در اینجا به جای اینکه از نوع 
$\mathbb{EV} \rightarrow \mathbb{BOOL}$
باشد،همان‌طور که قبلا تعریف کردیم، از نوع
$\underline{\mathbb{EV}} \rightarrow \mathbb{EV} \rightarrow \mathbb{BOOL}$
است.( منظور از 
$\mathbb{BOOL}$
همان مجموعه‌ی 
$\{True,False\}$
است.) در اینجا 
$\mathcal{A}$
و 
$\mathcal{B}$
را در ادامه با نوع‌های متفاوت دوباره تعریف خواهیم کرد، که البته فرق اساسی‌ای با تعریف قبلی ندارد و صرفا گسترشی ساده از آن است.]
$$\mathcal{S}^r[\mathsf{R_1 R_2}]= \mathcal{S}^r[\mathsf{R_1}] \Join \mathcal{S}^r[\mathsf{R_2}]$$
\begin{center}
	به‌طوری که در آن برای هر دو مجموعه‌ی 
	$\mathcal{S}$
	و
	$\mathcal{S'}$
	از رد‌های پیشوندی:
$$\mathcal{S \Join S'}=
\{
\langle \underline{\rho}, \pi \pi' \rangle |
\langle \underline{\rho},\pi \rangle \in \mathcal{S} \land
\langle \underline{\rho},\pi' \rangle \in \mathcal{S'}
\}
$$
\end{center}
[این یعنی اگر یک عبارت منظم داشته باشیم که از چسباندن 
$\mathsf{R_1}$
و 
$\mathsf{R_2}$
به هم ساخته شده باشد، آنگاه معنای این عبارت منظم با چسباندن ردهای پیشوندی موجود در مولفه‌ی دوم زوج مرتب‌هایی که اعضای مجموعه‌ی معنای این دو عبارت منظم هستند و گذاشتن این رد پیشوندی‌های حاصل از چسباندنْ در معنای عبارت منظم جدید تعریف می‌شود.\\
تا این تکه از تعریف معنای عبارت منظم که رسیده‌ایم می‌توانیم تا حدی به دستیابی به درکی شهودی از اینکه به چه نحوی قرار است عبارات منظم راهی برای توصیف ویژگی‌ در مورد برنامه‌ها باشد نزدیک‌تر شویم. همان‌طور که در مورد قبل دیدیم هر زوج 
$\mathsf{L:B}$
دقیقا به یک حالتْ داخل یک رد پیشوندی اشاره می‌کند. انگار که قرار است این زوج‌ها موازی با حالت‌ها در ردهای پیشوندی موجود در معنای یک برنامه جلو روند و منطبق باشند تا وارسی مدل انجام شود. درک این موضوع اولین قدم ماست در دیدن عصاره‌ی روش وارسی مدل در ادبیاتی که از اول این فصل علم کرده‌ایم.]







