
\chapter{صوری‌گری جدید برای روش وارسی مدل}

محوریت کار ما قرار است\cite{calcul} باشد که در آن سعی شده روش وارسی مدل با کمک نظریه تعبیر مجرد، بهبود داده شود. در\cite{clarke} روشی که معرفی شده در‌واقع ویژگی برنامه‌ها را به کمک منطق های \lr{LTL} یا \lr{CTL} بیان می‌کند. خود برنامه‌ها هم با کمک معناشناسی این منطق ها که نوع خاصی از مدل های کریپیکی به اسم سیستم گذار هستند توصیف می شوند. اما در\cite{calcul} کاری که انجام شده به این شکل است که منطق های \lr{LTL} و \lr{CTL} با عبارات منظم\cite{kleene56} جایگزین شده‌اند. علت این کار دو نکته بوده، اولی اینکه استفاده از عبارات منظم به جای منطق های نام برده شده می‌تواند برای برنامه نویسان ساده‌تر باشد و دومی اینکه عبارت منظم از از منطق های نام برده شده قدرت بیان بالاتری دارد.\cite{regisbetter} در ادامه ی کار وارسی مدل با استفاده از موجودات جدید تعریف شده به سه شکل مختلف بیان شده. در هر مرتبه بیان وارسی مدل، به‌گفته‌ی نویسنده، "ساختارمند"تر شده. می‌توان دریافت که فایده ساختارمندتر بودن بیان این است که پیاده‌سازی راحت‌تری دارد.\\
حال به بیان و بررسی تعاریف و خواص آن‌ها می‌پردازیم.

\section{نحو زبان مورد بررسی‬}

زبان بیان برنامه ها زیرمجموعه ای از دستورات زبان \lr{C} است، به شکل زیر:
$$\mathsf{x,y},... \in \mathbb{X}\hspace{4.65cm}$$
$$\mathsf{A} \in \mathbb{A} ::=\mathsf{1\:|\:x\:|\:A_1 - A_2\hspace{2.4cm}}$$  
$$\mathsf{B \in \mathbb{B} ::=A_1<A_2 \:|\: B_1 \: nand\: B_2\hspace{1.2cm}}$$
$$\mathsf{E \in \mathbb{E}::= A \: | \: B\hspace{4cm}}$$
$$\mathsf{S\in \mathbb{S} ::=\hspace{5cm}  }$$
$$\mathsf{x\doteq A; \hspace{2.25cm}}$$
$$\mathsf{|\:\:\:;\hspace{3.75cm}}$$
$$\mathsf{|\:\:\:if\:(B)\:S\:|\:if\:(B)\:S\:else\:S}$$
$$\mathsf{|\:\:\:while\:(B)\:S\: | \: break;\hspace{0.65cm}}$$
$$\mathsf{|\:\:\:\{Sl\}\hspace{3.15cm}}$$
$$\mathsf{Sl \in \mathbb{SL}::=Sl\:\:\:S\:|\:\backepsilon}\hspace{3.05cm}$$
$$\mathsf{P\in \mathbb{P}\:::=Sl}\hspace{4.25cm}$$

\vspace{1cm}
در اینجا زیر مجموعه‌ای از دستورات زبان \lr{C} را داریم. همین‌طور که قابل مشاهده است این زبان تا حد ممکن کوچک شده. علت این کار را بعدا عمیق‌تر حس خواهیم‌کرد. علتْ ساده‌تر شدن کار برای ارائه‌ی معناشناسی و تعبیر مجرد آن است. در اینجا راحتی آن برنامه‌نویسی که قرار است با این زبان برنامه بنویسد مطرح نبوده چون اصلا این زبان برای این کار ساخته نشده. نویسنده‌ی \cite{calcul} در اینجا صرفا می‌خواسته فرآیند را نشان دهد. اگر به فرض برای زبانی مانند پایتون بخواهیم درستی‌یابی با استفاده از روش ارائه شده را درست کینم، می‌توانیم همه‌ی راهی که در \cite{calcul} برای زبان توصیف شده، رفته‌شده را برای پایتون هم برویم و به یک تحلیل‌گر ایستا برای پایتون برسیم.
در مورد قدرت بیان این زبان هم می‌توانیم بگوییم که می‌توانیم باقی اعداد را از روی عدد ۱ و عملگر منها بسازیم. مثلا ابتدا 0 را به کمک ۱-۱ می سازیم و سپس با استفاده از 0 می‌توانیم یکی یکی اعداد منفی را بسازیم و سپس بعد از آن به سراغ اعداد مثبت می‌رویم که با کمک 0 و هر عدد منفی‌ای که ساختیم، ساخته می شوند. باقی اعداد و حتی باقی عملگر‌ها( یعنی به غیر از اعداد طبیعی) نیز از روی آنچه داریم قابل‌ساختن است. در مورد عبارت‌های بولی نیز داستان به همین منوال است. یعنی اینجا صرفا ادات شفر تعریف شده و باقی عملگر‌های بولی را می‌توان با استفاده از همین عملگر ساخت. باقی دستورات نیز دستورات شرط و حلقه هستند. باقی دستورات قرار است مطابق چیزی که از زبان \lr{C} انتظار داریم کار بکنند. در مورد دستور \lr{$\mathsf{break;}$} ذکر این نکته ضروری است که اجرای آن قرار است اجرای برنامه را از دستوری بعد از داخلی‌ترین حلقه‌ای که \lr{$\mathsf{break;}$} داخلش قرار دارد ادامه ‌دهد. در پایان می توان ثابت کرد که این زبان هم قدرت با مدل دیویس\cite{davis} است. 
توجه داریم که هر‌چه در این بخش در‌مورد معنای دستورات این زبان گفتیم، به هیچ وجه صوری نبود و صرفا درک شهودی ای که از معنای اجرای هر‌یک از دستورات داشتیم را بیان کردیم. بیان صوری معنای برنامه‌ها را، که برخلاف درک شهودی‌مان قابل انتقال به کامپیوتر‌ است، در ادامه بیان خواهیم‌کرد. طبیعتا این بیان صوری از روی یک درک شهودی ساخته شده‌است.

\section{معناشناسی زبان مورد بررسی‬}
معناشناسی زبانی را که در بخش پیش آوردیم با کمک مفاهیمی به نام برچسب و رد پیشوندی و عملگر چسباندن روی دو رود پیشوندی مختلف تعریف خواهیم‌کرد و نام این معناشناسی نیز معناشناسی رد پیشوندی است.\\

\subsection{برچسب‌ها}

با‌وجود اینکه خود زبان \lr{C} در قسمتی از زبان خود چیز‌هایی به نام برچسب دارد اما همین‌طور که در بخش پیشین دیدیم، در زبانی که اینجا در حال بحث روی آن هستیم خبری از برچسب‌ها نیست. اما برای تعریف صوری معنای برنامه‌ها، به شکلی که مورد بحث است، به آن‌ها نیاز است. در این بخش ابتدا به توضیحی مختصر در مورد برچسب‌ها در معناشناسی‌ زبان مورد بحث می‌پردازیم. تعاریف صوری دقیق این موجودات در پیوست \cite{calcul} آورده‌شده‌اند. از آوردن مستقیم این تعاریف در اینجا خود‌داری کرده‌ایم. البته در مورد معنای صوری برجسب‌ها هم ذکر این نکته ضروری است که نویسنده‌ی \cite{calcul} حتی به صورت صوری هم برای هر بخش از برنامه این کار را به طور دقیق انجام نداده و انجام این کار به طور دقیق‌تر را احتمالا به کسی که قرار است یک پیاده سازی کامل از این روش داشته باشد سپرده.


در زبانمان \lr{$\mathsf{S}$}ها بخشی از موجودات موجود در زبان هستند. برچسب ها را برای \lr{$\mathsf{S}$}ها تعریف می‌کنیم. برچسب‌ها با کمک توابع \lr{labs, in, brks-of, brk-to, esc, aft, at} تعریف می‌شوند. در‌واقع هر $\mathsf{S}$ به ازای بعضی از این توابع یک برجسب دارد و این‌ها در‌واقع نشان‌دهنده‌ی آن برچسب هستند. بعض دیگر این توابع برای هر $\mathsf{S}$ ممکن است یک مجموعه از برچسب‌ها را تعیین‌ کند و یکی از آن‌ها هم با گرفتن $\mathsf{S}$ یک مقدار بولی را بر‌می‌گرداند. 
\\\\
\lr{at[$\mathsf{S}$]} : برچسب شروع $\mathsf{S}$.\\
\lr{aft[$\mathsf{S}$]} : برچسب پایان $\mathsf{S}$، اگر پایانی داشته باشد.\\
\lr{esc[$\mathsf{S}$]} : یک مقدار بولی را باز‌‌می‌گرداند که بسته به اینکه در $\mathsf{S}$ دستور $\mathsf{break;}$ وجود دارد یا خیر، مقدار درست یا غلط را بر‌می‌گرداند.\\
\lr{brk-to[$\mathsf{S}$]} : برچسبی است که اگر حین $\mathsf{S}$ دستور $\mathsf{break;}$ اجرا شود، برنامه از آن نقطه ادامه پیدا می کند.\\
\lr{brks-of[$\mathsf{S}$]} : مجموعه‌ای از برچسب $\mathsf{break;}$ های $\mathsf{S}$ را بر‌می‌گرداند.\\
\lr{in[$\mathsf{S}$]} : مجموعه‌ای از تمام برچسب‌های درون $\mathsf{S}$ را برمی‌گرداند.\\
\lr{labs[$\mathsf{S}$]} : مجموعه‌ای از تمام بر‌چسب‌هایی که با اجرای $\mathsf{S}$ قابل دسترسی هستند را بر‌می‌گرداند.\\\\\\


\subsection{رد پیشوندی}


پس از تعریف برچسب‌ها به سراغ تعریف رد پیشوندی می‌رویم. پیش از آن باید وضعیت‌ها و محیط‌ها را تعریف کنیم.
\begin{defn}
	(محیط): به ازای مجموعه مقادیر $\mathbb{V}$ و مجموعه متغیرهای $\mathbb{X}$ تابع 
	$\rho : \mathbb{X} \rightarrow \mathbb{V}$ 
	را یک محیط می‌گوییم. مجموعه‌ی همه‌ی محیط‌ها را با $\mathbb{EV}$ نمایش می‌دهیم.
\end{defn}

\begin{defn}
	(وضعیت): به هر زوج مرتبْ به ترتیب متشکل از یک برچسب $l$ و یک محیط $\rho$ یک وضعیت (یا حالت)  
	$\langle l , \rho \rangle$
	می‌گوییم. مجموعه‌ی همه‌ی وضعیت‌ها را با $\mathfrak{S}$ نشان می‌دهیم.
\end{defn}
\begin{defn}
	(رد پیشوندی): به یک دنباله از وضعیت‌ها(با امکان تهی بودن) یک رد پیشوندی می‌گوییم.
\end{defn}

 هر رد پیشوندی یک دنباله است که قرار است توصیفی از چگونگی اجرای برنامه باشد. وضعیت‌ها همان‌طور که از نامشان پیداست قرار‌ است موقعیت لحظه‌ای برنامه را توصیف کنند. $l$ قرار است برچسب برنامه‌ی در حال اجرا باشد و $\rho$ مقدار متغیر‌ها را در آن موقع از اجرای برنامه نشان می‌دهد. دنباله‌های ما می‌توانند متناهی یا نامتناهی باشند. مجموعه‌ی ردهای پیشوندی‌ متناهی را با $\mathfrak{S^+}$ و مجموعه‌ی ردهای پیشوندی نامتناهی را با  $\mathfrak{S^\infty}$ نمایش می‌دهیم. مجموعه‌ی همه‌ی ردهای پیشوندی را هم با $\mathfrak{S^{+\infty}}$ نمایش می‌دهیم. 
با‌توجه به آنچه گفتیم، یک عملگر چسباندن $\Join$ را روی ردهای پیشوندی تعریف می‌کنیم. 
\begin{defn}
(عملگر چسباندن): اگر داشته باشیم 
$\pi_1 , \pi_2 \in \mathfrak{S^{+\infty}}  , \sigma_1 ,\sigma_2 \in \mathfrak{S}$
داریم:\\
\begin{center}
	اگر $\pi_1 \in \mathfrak{S^+} $ داریم  $\hspace{2.60cm}  $                                     
	$\pi_1 \Join \pi_2 = \pi_1$    \\
	اگر $\sigma_1\neq\sigma_2$    $\hspace{1.6cm}  $
	$\pi_1 \Join \pi_2$ تعریف نشده است
	\\اگر $\pi_1 \in \mathfrak{S^\infty} $ داریم   $\hspace{1cm}  $ 
	$\pi_1 \sigma_1 \Join \sigma_1 \pi_2 = \pi_1 \sigma_1 \pi_2 $
	
\end{center}
\end{defn}
همینطور $\epsilon$ هم یک رد پیشوندی است که حاوی هیچ وضعیتی نیست. به عبارت دیگر یک دنباله‌ی تهی است.

\subsection{تعریف صوری معناشناسی رد پیشوندی}
در این بخش قرار است دو تابع $\mathcal{A}$ و $\mathcal{B}$ را به ترتیب روی عبارات حسابی و بولی زبانمان یعنی $\mathsf{A}$ها و $\mathsf{B}$ها تعریف کنیم سپس با کمک آنها $\mathcal{S^*}$ را روی  مجموعه‌ای از اجتماع معنای $\mathsf{S}$ها و $\mathsf{Sl}$ها تعریف می کنیم. پس در نهایت هدف ما تعریف  $\mathcal{S^*}$ است.


\begin{defn}
(معنای عبارات حسابی - تابع $\mathcal{A}$): تابع 
$\mathcal{A}:\mathbb{A}\rightarrow \mathbb{EV} \rightarrow \mathbb{V}$
را به صورت بازگشتی روی ساختار 
$\mathsf{A} \in \mathbb{A}$
به شکل زیر تعریف می‌کنیم:
$$\mathcal{A[\mathsf{1}]\rho = }1     $$
$$\mathcal{A[\mathsf{x}]\rho = } \rho(\mathsf{x})          $$
$$\mathcal{A[\mathsf{A_1-A_2}]\rho = }\mathcal{A[\mathsf{A_1}]\rho }- \mathcal{A[\mathsf{A_2}]\rho }       $$

\end{defn}

\begin{defn}
	(معنای عبارات بولی - تابع $\mathcal{B}$): تابع 
	$\mathcal{B}: \mathbb{B} \rightarrow \mathbb{EV} \rightarrow \mathbb{BOOL}$
	را به صورت بازگشتی روی ساختار 
	$\mathsf{B} \in \mathbb{B}$
	به شکل زیر تعریف می‌کنیم:

\begin{center}
	اگر $\mathcal{A[\mathsf{A_1}]\rho }$ کوچکتر از $\mathcal{A[\mathsf{A_2}]\rho }$ باشد
	$\mathcal{B[\mathsf{A_1<A_2}]\rho = } True   \hspace{2cm}  $\\
	اگر $\mathcal{A[\mathsf{A_1}]\rho }$ بزرگتر از $\mathcal{A[\mathsf{A_2}]\rho }$ باشد
	$\mathcal{B[\mathsf{A_1<A_2}]\rho = } False   \hspace{2cm}  $\\
	$ \mathcal{B[\mathsf{B_1 nand B_2}]\rho = } \neg(\mathcal{B[\mathsf{B_1}]\rho}   \wedge \mathcal{B[\mathsf{B_2}]\rho}) $
\end{center}
\end{defn}

طبعا $\wedge$ و $\neg$ در فرازبان هستند.\\\\
در ادامه به تعریف $\mathcal{S^*}$ می‌پردازیم. این کار را با تعریف $\mathcal{S^*}$ روی هر ساخت $\mathsf{S}$ و $\mathsf{Sl}$ انجام می‌دهیم.
پیش از ادامه‌ی بحث باید این نکته را در‌مورد علامت‌گذاری‌هایمان ذکر کنیم که منظور از $        \mathsf{S} ::= l \mathsf{break;}  $ این است که تاکید کرده‌ایم که $\mathsf{S}$ با برچسب $l$ شروع شده‌است وگرنه همین طور که گفتیم   $l$ جزو زبان نیست.\\\\

\begin{defn}
	(معنای برنامه‌ها - تابع $\mathcal{S}^*$): 
اگر $        \mathsf{S} ::= \mathsf{break;}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S^*} [\mathsf{S}] = \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} \cup     \{ \langle at[\mathsf{S}] , \rho \rangle \langle brk-to[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \}             $$   


اگر $        \mathsf{S} ::=  \mathsf{x\doteq A;}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S^*} [\mathsf{S}] = \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} \cup     \{ \langle at[\mathsf{S}] , \rho \rangle \langle aft[\mathsf{S}] , \rho[\mathsf{x}\leftarrow \mathcal{A}[\mathsf{A}]\rho] \rangle | \rho \in \mathbb{EV}       \}             $$   

اگر $         \mathsf{S} ::= \mathsf{if}  \mathsf{ (B) S_t}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S^*} [\mathsf{S}] = \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} \cup     \{ \langle at[\mathsf{S}] , \rho \rangle \langle aft[\mathsf{S}] , \rho \rangle | \mathcal{B}[\mathsf{B}] \rho =False      \} 
$$$$\cup    \{ \langle at[\mathsf{S}] , \rho \rangle \langle at[\mathsf{S_t}] , \rho \rangle 
\pi | \mathcal{B}[\mathsf{B}] \rho =True  \wedge   \langle  at[\mathsf{S_t}]  , \rho \rangle \pi \in \mathcal{S} [\mathsf{S_t}]    \}          $$ 


اگر $         \mathsf{S} ::= \mathsf{if}  \mathsf{ (B) S_t else S_f}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S} [\mathsf{S}] = \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} $$$$\cup     \{ \langle at[\mathsf{S}] , \rho \rangle \langle at[\mathsf{S_f}] , \rho \rangle 
\pi | \mathcal{B}[\mathsf{B}] \rho =False  \wedge   \langle  at[\mathsf{S_f}]  , \rho \rangle \pi \in \mathcal{S} [\mathsf{S_f}]    \}  
$$$$\cup    \{ \langle at[\mathsf{S}] , \rho \rangle \langle at[\mathsf{S_t}] , \rho \rangle 
\pi | \mathcal{B}[\mathsf{B}] \rho =True  \wedge   \langle  at[\mathsf{S_t}]  , \rho \rangle \pi \in \mathcal{S} [\mathsf{S_t}]    \}          $$ \\


اگر 
$         \mathsf{Sl} ::= \backepsilon  $
 باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:

$$\mathcal{S} [\mathsf{Sl}] = \{ \langle at[\mathsf{Sl}] , \rho \rangle | \rho \in \mathbb{EV}       \}        $$ \\

اگر $         \mathsf{Sl} ::= \mathsf{Sl' \:\:\: S}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S} [\mathsf{Sl}] = \mathcal{S} [\mathsf{Sl'}] \cup( \mathcal{S} [\mathsf{Sl'}]
\Join \mathcal{S} [\mathsf{S}] )      $$ \\



اگر $         \mathsf{S} ::= \mathsf{while (B)S_b }   $ باشد، ماجرا نسبت به حالات قبل اندکی پیچیده‌تر می‌شود. تابعی به اسم $\mathcal{F} $ را تعریف خواهیم‌کرد که در حقیت دو ورودی دارد. ورودی اول آن یک دستور حلقه است و ورودی دوم آن یک مجموعه. به عبارتی دیگر می‌توانیم بگوییم به ازای هر حلقه یک تابع $\mathcal{F} $  جداگانه تعریف می‌شود که مجموعه‌ای از ردهای پیشوندی را می گیرد و مجموعه‌ای دیگر از همین موجودات را بازمی‌گرداند. کاری که این تابع قرار است انجام دهد این است که انگار یک دور دستورات داخل حلقه را اجرا می کند و دنباله‌هایی جدید را از دنباله‌های قبلی می‌سازد. معنای یک حلقه را کوچکترین نقطه ثابت این تابع در نظر می‌گیریم. در ادامه تعریف $\mathcal{F} $ آمده. با دیدن تعریف می توان به دلیل این کار پی‌برد. آن نقطه‌ای که دیگر $\mathcal{F} $ روی آن اثر نمی‌کند یا حالتی است که در آن دیگر شرط حلقه برقرار نیست و اصولا قرار نیست دستورات داخل حلقه اجرا شوند که طبق تعریف $\mathcal{F} $  می‌توانیم ببینیم که $\mathcal{F} $  در این حالت چیزی به ردهای پیشوندی اضافه نمی‌کند. یا اینکه حلقه به دستور $\mathsf{break;}$ خورده که در آن صورت وضعیتی به ته ردهای پیشوندی اضافه می‌شود که برچسبش خارج از مجموعه برچسب دستورات حلقه است و همین اضافه کردن هر چیزی را به ته ردهای پیشوندی موجود، توسط $\mathcal{F} $  غیرممکن می‌کند. بنابراین نقطه ثابت مفهوم مناسبی است برای اینکه از آن در تعریف صوری معنای حلقه استفاده کنیم. علت اینکه کوچکترین نقطه ثابت را به عنوان معنای حلقه در نظر می‌گیریم هم این است که مطمئن هستیم کوچکترین نقطه ثابت، هر رد پیشوندی ای را در خود داشته باشد به معنای اجرای برنامه مرتبط است. برای درک بهتر این نکته می‌توان به این نکته توجه کرد که با اضافه کردن وضعیت‌هایی کاملا بی‌ربط به اجرای برنامه به ته رد‌های پیشوندی، که صرفا برچسب متفاوتی با آخرین وضعیت هر رد پیشوندی دارند، نقطه ثابت جدیدی ساخته ایم. پس اگر خودمان را محدود به انتخاب کوچکترین نقطه ثابت نکنیم، به توصیفات صوری خوبی از برنامه‌ها دست پیدا نخواهیم‌کرد. در مورد نقطه ثابت تنها این نکته باقی می‌ماند که اصلا از کجا می‌دانیم که چنین نقطه ثابتی وجود دارد که در این صورت باید گفت مجموعه‌هایی که از ردهای پیشوندی تشکیل می‌شوند با عملگر زیرمجموعه بودن یک مشبکه را تشکیل می‌دهند و بنا به قضیه تارسکی\cite{tarski} برای چنین موجودی نقطه ثابت وجود دارد.
تعاریف موجوداتی که درموردشان صحبت کردیم به این شکل است:

$$\mathcal{S} [\mathsf{S}] = lfp^{\subseteq}\: \mathcal{F[\mathsf{S}]}      $$ $$\mathcal{F} [\mathsf{S}] X= \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} \cup $$
$$  \{ \pi_2 \langle l ,\rho \rangle \langle aft[\mathsf{S}],\rho \rangle |  \pi_2 \langle l ,\rho \rangle \in X \wedge \mathcal{B}[\mathsf{B}]\rho=False \wedge l= at[\mathsf{S}]   \} \cup      $$
$$  \{ \pi_2 \langle l ,\rho \rangle \langle at[\mathsf{S_b}],\rho \rangle \pi_3 |  \pi_2 \langle l ,\rho \rangle \in X \wedge \mathcal{B}[\mathsf{B}]\rho=True \wedge$$$$  \langle at[\mathsf{S_b}],\rho \rangle \pi_3 \in  \mathcal{S} [\mathsf{S_b}]   \wedge   l= at[\mathsf{S}]  \}  $$\\

اگر $         \mathsf{S} ::=;  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S} [\mathsf{S}] = \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} \cup     \{ \langle at[\mathsf{S}] , \rho \rangle \langle aft[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \}             $$  


اگر $         \mathsf{S} ::=\{\mathsf{Sl}\}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S} [\mathsf{S}] = \mathcal{S} [\mathsf{Sl}] $$   \\
\end{defn}
در ادامه چند مثال می‌زنیم تا مفهوم موجودات تعریف شده مشخص‌تر شود.
\begin{exm}
	
\end{exm}
\begin{exm}
	
\end{exm}
\begin{exm}
	
\end{exm}

\section{ویژگی‌های معنایی برنامه‌ها}
تا به اینجای کار یک زبان آورده‌ایم و برای آن معنا تعریف کرده‌ایم. در این فصل می‌خواهیم در مورد ویژگی‌های برنامه‌هایی که در این زبان نوشته می‌شوند با توجه به معنای صوری‌ای که تعریف کرده‌ایم، صحبت کنیم. دقت شود که برای برنامه‌هایی که در یک زبان برنامه‌نویسی نوشته می‌شوند می‌توان به اشکال مختلفی ویژگی تعریف کرد؛ مثلا ویژگی‌های نحوی، مثل اینکه طول برنامه چند خط است یا هر کاراکتر چند بار به کار رفته، یا ویژگی‌های محاسباتی، مثل بررسی‌ سرعت برنامه یا میزان استفاده‌ی آن از حافظه که عموما در نظریه الگوریتم و پیچیدگی محاسبات بررسی می‌شود. منظور ما در اینجا از تعریف ویژگی، متناسب است با معناشناسی‌ای که برای برنامه‌هایمان تعریف کرده‌ایم. معناشناسی‌ای که تعریف کرده‌ایم درواقع سیر محاسباتی برنامه را توصیف می‌کند و ما می‌خواهیم ویژگی‌ها را با توجه به این موصوع تعریف کنیم. در این صورت می‌توانیم صحت عملکرد برنامه‌ها را با توجه به صادق بودن ویژگی‌هایی که در مورد آن‌ها تعریف شده بفهمیم.\\
ابتدا به تعریف ویژگی‌ها می‌پردازیم، سپس به سراغ تعریف یک نوع عبارت منظم می‌رویم که از آن برای بیان ویژگی‌ها استفاده می‌شود.
\subsection{ویژگی‌های معنایی}
همان‌طور که در بخش قبلی دیدیم، معنای هر برنامه با یک مجموعه‌ی 
$\mathcal{S^*} [\mathsf{S}]$
مشخص می‌شود. وقتی می‌خواهیم ویژگی‌هایی را برای موجوداتی که به کمک مجموعه‌ها تعریف شده اند بیان کنیم، اینکه ویژگی‌ها را هم با مجموعه‌ها بیان کنیم کار معقولی به نظر می‌رسد. مثل اینکه بخواهیم ویژگی زوج بودن را در مورد اعداد طبیعی بیان کنیم. می توانیم مجموعه‌ی $\mathbb{E}$ را به عنوان مجموعه‌ی همه‌ی اعداد زوج در نظر بگیریم و اینکه یک عدد زوج هست یا نه را عضویتش در مجموعه‌ی $\mathbb{E}$ تعریف کنیم. پس یعنی در مورد اعداد طبیعی قرار است هر ویژگی به شکل زیرمجموعه‌ای از تمام این اعداد در نظر گرفته شود. یعنی هر عضو 
$\mathit{P}(\mathbb{N})$
بنا به تعریف ما یک ویژگی از اعداد طبیعی است.
در مورد برنامه‌ها نیز قرار است همین رویه را پیش بگیریم. تابع 
$\mathcal{S^*}$
از نوع 
$\mathbb{P} \rightarrow \mathit{P}(\mathfrak{S^+})$
است. یعنی یک برنامه را در ورودی می‌گیرد و یک مجموعه از ردهای پیشوندی را باز می‌گرداند. پس می‌توانیم هر ویژگی را به عنوان زیر مجموعه‌ای از 
$\mathit{P}(\mathfrak{S^+})$
تعریف کنیم، به عبارت دیگر عضوی از
$\mathit{P(P}(\mathfrak{S^+}))$.

\subsection{عبارات منظم}
در اینجا توصیف ویژگی‌ها برای هر برنامه باید یک چارچوب داشته باشد. در صورت قدیمی روش وارسی مدل ما از منطق های زمانی برای بیان ویژگی‌ها به صورت صوری استفاده می‌کردیم و این احتیاج به یک زبان برای صوری کردن کامل کار را، که رسیدن به بیان مسئله‌ی وارسی مدل است، به ما نشان می‌دهد. در اینجا ما با داستان دیگری هم رو به رو هستیم و آن این است که از آنجایی که با مجموعه‌ها سر و کار داریم و مجموعه‌ها چندان موجودات ساختنی‌ای نیستند( برخلاف مدل کریپکی)، بهتر است یک موجود ساختنی مثل یک زبان صوری برای بیان آن‌ها داشته باشیم. در این فصل قصد داریم یک نوع عبارت منظم را برای این منظور تعریف کنیم. پیشتر به نکته‌ی دیگری در مورد استفاده از عبارات منظم، که متداول‌تر بودن بین جامعه‌ی برنامه نویسان است، صحبت کردیم. ابتدا زبان این عبارت منظم را تعریف می‌کنیم، سپس به سراغ معناشناسی آن می‌رویم. 
\subsection{زبان عبارات منظم}
فرق عمده‌ای که زبان عبارات منظم ما با عبارات منظم کلاسیک دارد در کاراکترهاست. کاراکترها در زبان کلاسیک موجوداتی اتمی بودند، اما در اینجا ساختار دارند. در اینجا به جای هر کاراکتر یک زوج متشکل از مجموعه‌ی $\mathsf{L}$ و عبارت بولی $\mathsf{B}$ تشکیل شده‌اند که این زوج را به شکل 
$\mathsf{L : B}$
در زبانمان نمایش می‌دهیم.\\ 
زبان ما به شکل BNF زیر است:
\begin{defn}
$$\mathsf{L} \in \mathit{P}(\mathbb{L})$$        
$$\mathsf{x,y,...} \in \mathbb{X}$$
$$\mathsf{\underline{x},\underline{y},...} \in \mathbb{\underline{X}}$$
$$\mathsf{B} \in \mathbb{B}$$
$$\mathsf{R} \in \mathbb{R}$$
\newpage
$$\mathsf{R} ::=\hspace{0.5cm} \varepsilon\hspace{4.2cm}$$
$$|\:\:\:\mathsf{L : B}\hspace{2.4cm}$$
$$|\:\:\:\mathsf{R_1 R_2}\:\:\:(or\:\mathsf{R_1 \bullet R_2 })$$
$$\:\:\:\:\:\:\:|\:\:\:\mathsf{R_1\:\mid\:R_2}\:\:\:(or\:\mathsf{R_1 + R_2 })$$
$$|\:\:\:\mathsf{R_1^*}\hspace{2.8cm}$$
$$|\:\:\:\mathsf{R_1^+}\hspace{2.7cm}$$
$$|\:\:\:(\mathsf{R_1})\hspace{2.47cm}$$
\end{defn}
همان طور که قابل مشاهده است در اینجا عملگرهای دوتایی چسباندن
$(\bullet)$
 و انتخاب
$(|)$
 را داریم، به همراه عملگرهای یگانی 
$^*$
و
$^+$.
در ادامه خواهیم دید که در فرازبان معنی عملگر یگانی 
$^+$
به وسیله‌ی عملگر یگانی دیگر قابل بیان است، هرچند که در زبانمان هم برای سهولت کار از بیان این عملگر اجتناب نشده. 
توجه شود که پرانتزها هم جزئی از زبان قرار داده شده‌اند.


همین‌طور در اینجا می‌خواهیم از تعدادی عبارات مخفف که در ادامه کارمان را راحت‌تر می‌کنند صحبت کنیم. منظور از زوج 
$\mathsf{? : B}$
همان 
$\mathbb{L}\mathsf{ : B}$
است. عبارت 
$l : \mathsf{B}$
به جای عبارت 
$\{l\} : \mathsf{B}$
به کار می‌رود و منظور از عبارت 
$\neg l \mathsf{: B}$
نیز عبارت 
$\mathbb{L}\setminus\{l\}:\mathsf{B}$
است.

با یک نگاه به دستور این زبان یک نکته‌ی چشمگیر برای ما، با توجه به موجوداتی که در بخش قبل تعریف کردیم، با نگاه به قواعد این زبان می‌تواند وجود یک مجموعه‌ی
$\mathbb{\underline{X}}$
در کنار 
$\mathbb{X}$
که از قبل داشتیم باشد. قرار است به ازای هر 
$\mathsf{x}\in\mathbb{X}$
یک 
$\mathsf{\underline{x}}\in\mathbb{\underline{X}}$
داشته‌باشیم. منظور از 
$\mathsf{\underline{x}}$
مقدار متغیر 
$\mathsf{x}$
در ابتدای هر برنامه است. این یعنی تابع
$\underline{\rho}: \mathbb{\underline{X}} \rightarrow \mathbb{V}$
که 
$\mathbb{V}$
مجموعه‌ی مقادیر متغیرهاست( در بخش قبل به این اشاره نشد اما خود
$\rho$
هایی که در بخش قبل داشتیم هم از نوع
$\mathbb{X} \rightarrow \mathbb{V}$
بود. با توجه به زبانمان و توضیحاتی که در گذشته دادیم، می‌توان در نظر گرفت که در اینجا 
$\mathbb{V}$
همان اعداد صحیح است). همان‌طور که پیش‌تر گفتیم برای اشاره به یک تابع
$\rho$
از کلمه‌ی "محیط" استفاده می‌شود. به همین منوال در ادامه برای اشاره‌ به 
$\underline{\rho}$
از "محیط اولیه" استفاده می‌کنیم. برای اشاره به مجموعه‌ی همه‌ی محیط‌های اولیه هم از نماد 
$\underline{\mathbb{EV}}$
استفاده می‌کنیم.
بقیه‌ی موجودات از جمله برچسب‌ها و عبارات بولی را هم که قبلا داشتیم.\\
در ادامه به بیان صوری معنای زبان بیان شده می‌پردازیم. پس از آن می‌توانیم با بررسی چند مثال، از اینکه معنای هر عبارت منظم چیست درکی شهودی به دست آوریم.\\

\subsection{معناشناسی عبارات منظم}
معنای عبارات منظم را با استفاده از تابع 
$\mathcal{S}^r$
نشان می‌دهیم. این تابع به این شکل تعریف می‌شود که در ورودی یک عبارت منظم 
$\mathsf{R}$
را می‌گیرد، سپس یک مجموعه از زوج مرتب‌های( یا همان‌طور که پیش‌تر نام‌گذاری کردیم "وضعیت‌ها"ی)
$\langle\underline{\rho} , \pi\rangle$
را که 
$\pi \in \mathbb{S^*}$
و 
$\underline{\rho} \in \underline{\mathbb{EV}}$
باز می‌گرداند. بنابراین این تابع از نوع
$\mathbb{R} \rightarrow \mathit{P} (\mathbb{\underline{EV} \times S^*})$
است. همین‌طور دقت شود که تا به حال از 
$\mathbb{S}^*$
صحبتی نکرده بودیم و فقط 
$\mathbb{S}^+$
را معرفی کرده بودیم. 
$\mathbb{S}^*$
نیز برابر است با
$\mathbb{S}^+ \cup \{\epsilon\}$ 
(به لحاظ معنایی همان عملگر
$^*$
است که در زبان عبارات منظمهم هست، مشهور به ستاره‌ی کلینی).

تعریف استقرایی تابع 
$\mathcal{S}^r$
به شکل زیر است:
\begin{defn}
	تابع 
	$\mathcal{S}^r:\mathbb{R}\rightarrow \mathit{P}(\mathbb{\underline{EV}\times S}^*)$
	به صورت استقرایی روی ساختار عبارت منظم $\mathsf{R}$ به صورت زیر تعریف می‌شود:
$$\mathcal{S}^r[\varepsilon]= \{ \langle \underline{\rho} , \epsilon \rangle | \underline{\rho} \in \underline{\mathbb{EV}}\}$$
[یعنی معنای عبارت منظم
$\varepsilon$
مجموعه‌ای شامل زوج مرتب‌هایی از محیط‌های اولیه‌ی مختلف در کنار رد پیشوندی تهی استفاده می‌کند.]
$$\mathcal{S}^r[\mathsf{L:B}] = \{\langle\underline{\rho},\langle l , \rho \rangle \rangle | l \in \mathsf{L} \land \mathcal{B}[\mathsf{B}] \underline{\rho},\rho \}$$
[این یعنی معنای عبارت 
$\mathcal{S}^r[\mathsf{L:B}]$
زوج مرتب‌هایی هستند که عضو اول آن‌ها محیط‌های اولیه مختلف هستند( مانند مورد قبلی و البته در موارد آتی!) و عضو دوم آن‌ها ردهای پیشوندی تک‌عضوی 
$\langle l , \rho \rangle$
هستند که در آن‌ها برچسب 
$l$
باید در
$\mathsf{L}$
که مجموعه‌ای از برچسب‌هاست حضور داشته باشد و عبارت بولی 
$\mathsf{B}$
باید درباره‌ی محیط اولیه
$\underline{\rho}$
و محیط 
$\rho$
برقرار باشد. حتما متوجه این نکته شدید که 
$\mathcal{B}$
در اینجا به جای اینکه از نوع 
$\mathbb{EV} \rightarrow \mathbb{BOOL}$
باشد،همان‌طور که قبلا تعریف کردیم، از نوع
$\underline{\mathbb{EV}} \rightarrow \mathbb{EV} \rightarrow \mathbb{BOOL}$
است.( منظور از 
$\mathbb{BOOL}$
همان مجموعه‌ی 
$\{True,False\}$
است.) در اینجا 
$\mathcal{A}$
و 
$\mathcal{B}$
را در ادامه با نوع‌های متفاوت دوباره تعریف خواهیم کرد، که البته فرق اساسی‌ای با تعریف قبلی ندارد و صرفا گسترشی ساده از آن است.]
$$\mathcal{S}^r[\mathsf{R_1 R_2}]= \mathcal{S}^r[\mathsf{R_1}] \Join \mathcal{S}^r[\mathsf{R_2}]$$
\begin{center}
	به‌طوری که در آن برای هر دو مجموعه‌ی 
	$\mathcal{S}$
	و
	$\mathcal{S'}$
	از رد‌های پیشوندی:
$$\mathcal{S \Join S'}=
\{
\langle \underline{\rho}, \pi \pi' \rangle |
\langle \underline{\rho},\pi \rangle \in \mathcal{S} \land
\langle \underline{\rho},\pi' \rangle \in \mathcal{S'}
\}
$$
\end{center}
[این یعنی اگر یک عبارت منظم داشته باشیم که از چسباندن 
$\mathsf{R_1}$
و 
$\mathsf{R_2}$
به هم ساخته شده باشد، آنگاه معنای این عبارت منظم با چسباندن ردهای پیشوندی موجود در مولفه‌ی دوم زوج مرتب‌هایی که اعضای مجموعه‌ی معنای این دو عبارت منظم هستند و گذاشتن این رد پیشوندی‌های حاصل از چسباندنْ در معنای عبارت منظم جدید تعریف می‌شود. همین‌طور که می‌بینید یک عملگر چسباندن برای دو مجموعه از این زوج‌های 
$\langle \underline{\rho} , \pi \rangle$
تعریف شده و در تعریف 
$\mathcal{S}^r [\mathsf{R_1 R_2}]$
از آن کمک گرفته شده.\\
تا این تکه از تعریف معنای عبارت منظم که رسیده‌ایم، تا حدی به دستیابی به درکی شهودی از اینکه به چه نحوی قرار است عبارات منظم راهی برای توصیف ویژگی‌ در مورد برنامه‌ها باشد نزدیک‌تر شده‌ایم. همان‌طور که در مورد قبل دیدیم هر زوج 
$\mathsf{L:B}$
دقیقا به یک وضعیتْ داخل یک رد پیشوندی اشاره می‌کند. انگار که قرار است این زوج‌ها موازی با وضعیت‌ها در ردهای پیشوندی موجود در معنای یک برنامه جلو روند و منطبق باشند تا وارسی مدل انجام شود. درک این موضوع اولین قدم ماست در دیدن عصاره‌ی روش وارسی مدل در ادبیاتی که از اول این فصلْ عَلَم کرده‌ایم.]
$$\mathcal{S}^r [\mathsf{R_1\:|\:R_2}]= 
\mathcal{S}^r [R_1] \cup
\mathcal{S}^r [R_2]$$
[این موردْ معنای اعمال عملگر انتخاب روی دو عبارت منظم را توصیف می‌کند. معنای اعمال این عملگر به‌سادگی به صورت اجتماع معنای هر دو عبارت منظم تعریف شده.]

$$\mathcal{S}^r [\mathsf{R}]^0 = \mathcal{S}^r[\varepsilon]$$
$$\mathcal{S}^r [\mathsf{R}]^{n+1} = \mathcal{S}^r [\mathsf{R}]^{n} \Join
\mathcal{S}^r [\mathsf{R}]$$
[دو عبارت اخیر برای توصیف معنای عملگرهای $^*$ و $^+$ تعریف شده‌اند. عملگر $\Join$ و معنای 
$\mathcal{S}^r[\varepsilon]$
را هم که قبلا تعریف کرده بودیم و $0$ و $n$ و $n+1$ هم اعداد طبیعی‌اند و $+$ لاجرم همان جمع اعداد طبیعی است.]
$$\mathcal{S}^r[\mathsf{R^*}] =  \bigcup_{n \in \mathbb{N}}
\mathcal{S}^r [\mathsf{R}^n]$$
$$\mathcal{S}^r[\mathsf{R^+}] =  \bigcup_{n \in \mathbb{N}\setminus\{0\}}
\mathcal{S}^r [\mathsf{R}^n]$$
[این دو عبارت هم تعریف معنای خود دو عملگر $^*$ و $^+$ هستند. منظور از $\mathbb{N}$ مجموعه‌ی اعداد طبیعی است. همان‌طور که قبل‌تر هم اشاره شد $^+$ را می‌توان در فرازبان با $^*$ تعریف کرد. اضافه می‌کنیم که خود $^*$ را هم در فرازبان می‌توان با عملگر انتخاب تعریف کرد و در اینجا می‌توان این نکته را هم دید.]

$$\mathcal{S}^r [(\mathsf{B})]=\mathcal{S}^r [\mathsf{B}]$$
[این تکه از تعریف هم صرفا بیان می‌کند که پرانتزها تاثیری در معنای عبارات منظم ندارند که کاملا قابل انتظار است چرا که وجود پرانتز قرار است در صرفا در خواص نحوی زبان اثر بگذارد.]
\end{defn}
تعریف معنای عبارات منظم در اینجا تمام می‌شود اما همان‌گونه که در لا‌به‌لای تعاریف گفتیم، احتیاج داریم که $\mathcal{A}$ و $\mathcal{B}$ را از نو تعریف کنیم:
\begin{defn}
	توابع 
	$\mathcal{A}:\mathbb{A}\rightarrow \mathbb{\underline{EV}} \rightarrow
	\mathbb{EV} \rightarrow \mathbb{V}$
	و 
	$\mathcal{B}:\mathbb{B}\rightarrow \mathbb{\underline{EV}} \rightarrow
	\mathbb{EV} \rightarrow \mathbb{BOOL}$
	به شکل استقرایی به ترتیب روی ساختارهای 
	$\mathsf{A}\in\mathbb{A}$
	و
	$\mathsf{B} \in \mathbb{B}$
	به شکل زیر تعریف می‌شوند:
	
	
$$\mathcal{A}[\mathsf{1}]\underline{\rho},\rho=1$$
$$\mathcal{A}[\mathsf{\underline{\mathsf{x}}}]\underline{\rho},\rho= \underline{\rho}(\mathsf{x})$$
$$\mathcal{A}[\mathsf{\mathsf{x}}]\underline{\rho},\rho= \rho(\mathsf{x})$$
$$\mathcal{A}[\mathsf{A_1 - A_2}]\underline{\rho},\rho= 
\mathcal{A}[\mathsf{A_1}]\underline{\rho},\rho - \mathcal{A}[\mathsf{A_2}]\underline{\rho},\rho$$
$$\mathcal{B}[\mathsf{A_1 < A_2}]\underline{\rho},\rho=
	\mathcal{A}[\mathsf{A_1}]\underline{\rho},\rho\: <\: \mathcal{A}[\mathsf{A_2}]\underline{\rho},\rho$$
$$\mathcal{B}[\mathsf{B_1\:nand\:B_2}]\underline{\rho},\rho=
\mathcal{B}[\mathsf{B_1}]\underline{\rho},\rho \uparrow 
\mathcal{B}[\mathsf{B_2}]\underline{\rho},\rho $$
\end{defn}
به‌راحتی قابل مشاهده است که تعاریف جدید تا حد خوبی به تعاریف قبلی شبیه هستند و فرق عمده صرفا وارد شدن $\underline{\rho}$ است.\\
حال به سراغ چند مثال از عبارات منظم و معنای آن‌ها می‌رویم.
\begin{exm}
	فرض کنید عبارت منظم ما

\end{exm}

\begin{exm}
	
	{این سه تا مثال باید با سه تا مثال بخش معناشناسی برنامه‌ها سینک باشن! همین طور در ادامه بعد از تعریف مدل چکینگ در این فصل هم ۳ تا مثال خواهیم داشت که قراره هر کدومشون از این ۳ تا مثال و ۳ تا مثالی که قبلا تعریف کردیم تشکیل شده باشن.}
\end{exm}

\begin{exm}
	
\end{exm}

تا اینجای کار بیشتر مفاهیمی که برای بیان صورت جدید مسئله‌ی وارسی مدل احتیاج داریم را بیان کرده‌ایم. 
\subsection{واریته‌های مختلف زبان عبارات منظم}
به عنوان قسمت آخر این بخشْ واریته‌های مختلفی از زبان عبارات منظم را بیان می‌کنیم. ، که هر کدام در واقع زیرمجموعه‌هایی از کل عبارات زبانی که توصیف کرده‌ایم را توصیف می‌کنند. بعضی از آن‌ها را در همین فصل برای هدف نهایی این فصل و بعضی دیگر را در فصل بعدی استفاده می‌کنیم.

اولین واریته‌ای که می‌خواهیم بیان کنیم، واریته‌ای است که در اعضای آن اصلا عبارت 
$\mathsf{L : B}$
حضور ندارد و کل عبارت‌های زبان از $\varepsilon$ ها تشکیل شده‌اند.
\begin{defn}
	(عبارت منظم تهی - $\mathbb{R_\varepsilon}$): 
	$$\mathsf{R} \:\:\:\in\:\:\: \mathbb{R}_\varepsilon$$
	$$\mathsf{R}\:\:\: ::= \:\:\: \varepsilon \: | \: \mathsf{R_1 R_2} \: | 
	\: \mathsf{R_1 + R_2} \: | \: \mathsf{R_1^*} \: | \: \mathsf{R_1^+} | (\mathsf{R_1})$$
\end{defn}


 با توجه به بخش قبل متوجه هستیم که معنای همه‌ی این عبارت‌ها برابر 
$\{\langle \underline{\rho} , \epsilon \rangle\}$
خواهد بود.

واریته‌ی بعدی عبارت منظم ناتهی است.
\begin{defn}
	(عبارت منظم ناتهی - $\mathbb{R}^+$):
	$$\mathsf{R} \:\:\:\in\:\:\: \mathbb{R}^+$$
	$$\mathsf{R}\:\:\: ::= \:\:\: \mathsf{L:B} \: |
	\: \mathsf{\varepsilon R_2} \: | \: \mathsf{R_1 \varepsilon} \: |
	\: \mathsf{R_1 R_2} \: | 
	\: \mathsf{R_1 + R_2} \: | \: \mathsf{R_1^+} | (\mathsf{R_1})$$
\end{defn}
دلیل وجود 
$\mathsf{\varepsilon R_2}$
و 
$\mathsf{R_1 \varepsilon}$
در تعریف این است که ممکن است معنای عبارتی با معنای عبارات عضو $\mathbb{R}_\varepsilon$ برابر نباشد( بعنی برابر ${\langle \underline{\rho} , \epsilon \rangle}$ نباشد)، اما در خود عبارتْ $\varepsilon$ حضور داشته باشد. با این تفاصیل می‌توان دید که دو مجموعه‌ی 
$\mathbb{R}_\varepsilon$
و
$\mathbb{R}^+$
یک افراز برای مجموعه‌ی $\mathbb{R}$ هستند، براساس اینکه معنای هر عبارت در $\mathbb{R}$ برابر ${\langle \underline{\rho} , \epsilon \rangle}$ هست یا خیر. بنابراین شاید به نظر برسد که تعریف یکی از آن‌ها به طور ساختاری کافی بود، اما ممکن است درجایی احتیاج داشته باشیم که ساختاری استقرایی روی هر یک از آن‌ها عَلَم کنیم یا اینکه در اثبات حکمی بخواهیم از استقرا روی یکی از این دو ساختار استفاده کنیم.

واریته‌ی آخر عبارات منظم ما نیز عبارات منظم بدون انتخاب است.
\begin{defn}
(عبارت منظم بدون انتخاب - $\mathbb{R}^\nmid$):
$$
\mathsf{R}\:\:\: \in \:\:\: \mathbb{R}^\nmid$$
$$
\mathsf{R}\:\:\: ::= \:\:\: \varepsilon \: | \: \mathsf{L:B} \: | \:
\mathsf{R_1 R_2} \: | \: \mathsf{R_1}^* \: | \: \mathsf{R_1}^+ \: | \:
(\mathsf{R_1})$$
\end{defn}

\section{صورت جدید مسئله‌ی وارسی مدل}
بالاخره به هدف نهایی این فصل رسیدیم. می‌خواهیم صورت جدیدی از مسئله‌ی وارسی مدل را بیان ‌کنیم.\\
پیش از ارائه‌ی تعریف وارسی مدل نیاز داریم تا عملگر بستار پیشوندی را برای یک مجموعه از ردهای پیشوندی معرفی کنیم.
\begin{defn}
	(بستار پیشوندی):
	اگر 
	$\Pi \in \mathit{P}(\mathbb{\underline{EV}\times S^+})$
	آنگاه بستار پیشوندی $\Pi$را به صورت زیر تعریف می‌کنیم:
	$$\mathsf{prefix}(\Pi)=
	\{\langle \underline{\rho},\pi\rangle | \pi \in \mathbb{S^+} \land \exists\
	\pi' \in \mathbb{S^*}: \langle \underline{\rho}, \pi \pi' \rangle \in \Pi \}$$
\end{defn}

برای درک بهتر مفهوم بستار پیشوندی به مثال زیر توجه شود.
\begin{exm}
	اگر 
	$\Pi = \{\langle\underline{\rho},\langle l_1 , \rho_1 \rangle 
	\langle l_2  \rho_2 \rangle\rangle  \langle l_3 , \rho_3 \rangle\rangle 
	,
	\langle\underline{\rho},\langle {l_1}' , {\rho_1}' \rangle  \langle {l_2}'  {\rho_2}' \rangle\rangle
	\}$ 
	باشد( $\Pi$ شامل دو عضو است) آنگاه:
	$$
	\mathsf{prefix}(\Pi)=
	\{
	\langle\underline{\rho},\langle l_1 , \rho_1 \rangle\rangle ,
	\langle\underline{\rho},\langle l_1 , \rho_1 \rangle  \langle l_2  \rho_2 \rangle\rangle,
	\langle\underline{\rho},\langle l_1 , \rho_1 \rangle  \langle l_2  \rho_2 \rangle  \langle l_3 , \rho_3 \rangle\rangle ,$$
	$$
	\langle\underline{\rho},\langle {l_1}' , {\rho_1}' \rangle\rangle,
	\langle\underline{\rho},\langle {l_1}' , {\rho_1}' \rangle  \langle {l_2}'  {\rho_2}' \rangle\rangle
	\}
	$$
	که شامل 5 عضو است.
\end{exm}
حال به ارائه‌ی صورت جدیدمان از روش وارسی مدل می‌رسیم که هدف اصلی این اصل بود و با این تعریف فصل تمام می‌شود.
\begin{defn}
(وارسی مدل):
	اگر 
	$\mathsf{P}\in\mathbb{P} , \mathsf{R} \in \mathbb{R}^+ , \underline{\rho} \in \underline{\mathbb{EV}}$
	آنگاه:
	$$\mathsf{P},\underline{\rho} \models \mathsf{R}
	 \Leftrightarrow
	(\{\underline{\rho}\}\times \mathcal{S}^* [\mathsf{P}]) \subseteq 
	\mathsf{prefix} (\mathcal{S}^r [\mathsf{R} \bullet (?:\mathit{T})^*])
	$$
\end{defn}

این تعریف بیان می‌کند که برنامه‌ی 
$\mathsf{P}$
در صورتی که با محیط اولیه‌ی 
$\underline{\rho}$
اجرا شود، در صورتی خاصیتی که با عبارت منظم 
$\mathsf{R}$
بیان شده را دارد که معنای آن زیرمجموعه‌ی بستار پیشوندی معنای عبارت منظم
$\mathsf{R} \bullet (?:\mathit{T})^*$
باشد.
توجه شود که محیط اولیه‌ای که برای برنامه‌ی مورد بررسی متصور هستیم صرفا به این منظور قرار داده شده که معناشناسی برنامه را بتوانیم با معنای عبارات منظم قابل قیاس کنیم. دلیل حضور محیط اولیه در معنای عبارات منظم نیز در صورت سوم روش وارسی مدل یعنی فصل ۴ مشخص می‌شود و در این صورت از روش وارسی مدل و صورت بعدی آن چندان نقشی ندارد. 

در مورد نقش 
$ (?:\mathit{T})^*$
و
$ \mathsf{prefix} $
این به تصمیم مبدع این روش بوده که این دو در تعریف روش وارسی مدل حضور داشته باشند. حضور این دو طبعا باعث می‌شود به ازای یک عبارت منظم 
$\mathsf{R}$
نسبت به این حالت که صرفا معنی برنامه زیرمجموعه‌ی معنی 
$\mathsf{R}$
باشد، برنامه‌های بیشتری باشند که خاصیت بیان شده با 
$\mathsf{R}$
را ارضا کنند، چون در این صورت مجموعه‌ی سمت راستی در رابطه‌ی زیرمجموعه بودن بزرگتر می‌شود.

\section{در مورد توقف پذیری}

در این بخش مشکلی از کار که به نظر نگارنده رسیده مطرح شده. متاسفانه این مشکل بسیار بزرگ است و به نظر عجیب می‌‌آید اگر نویسنده‌ی \cite{calcul} متوجه آن نبوده باشد! اگر صحبت ما در اینجا درست باشد، این به این معنی خواهد بود که کل کاری که در حال توصیفش هستیم قابل پیاده سازی نیست!

بحث ما در اینجا در مورد توقف پذیری است. در \cite{calcul} در مورد توقف یک برنامه صحبتی به میان نیامده. یعنی حتی گفته نشده که در چه صورتی می‌توانیم بگوییم که یک برنامه متوقف شده است. یک تعریف  صوری معقول که خودمان می‌توانیم برای این معنا بیاوریم این است:

\begin{defn}
(توقف پذیری:) برنامه‌ی $\mathsf{P}$ را به همراه اجرای اولیه $\underline{\rho}$ توقف پذیر می‌گوییم اگر و تنها اگر وجود داشته باشد 
	$\pi \in \mathcal{S}^* \llbracket \mathsf{P} \rrbracket$ 
	که ($\rho$ محیط متناظر با محیط اولیه‌ی $\underline{\rho}$ است.):
	$$\pi = \langle at \llbracket \mathsf{P} \rrbracket , \rho \rangle \pi'$$
	و اینکه $\langle aft\llbracket \mathsf{P} \rrbracket , \rho' \rangle$ در $\pi$ حضور داشته باشد. این اتفاق را با 
	$\mathsf{P,\underline{\rho}\downarrow}$
	نشان می‌دهیم. همین تعریف را برای لیست دستورات $\mathsf{Sl}$ یا دستور $\mathsf{S}$ هم صرفا با جایگذاری این‌ها با برنامه‌ی $\mathsf{P}$ داریم.
\end{defn} 
در این تعریف توقف پذیری صرفا برای یک محیط اولیه تعریف شده.
در اینجا توقف پذیری به متناهی بودن ردهای پیشوندی موجود در برنامه ربط داده نشده. با توجه به معناشناسی‌ای که داریم، تعریف توقف پذیری به معنای وجود رد پیشوندی متناهی با محیط اولیه‌ی مورد بررسی در معنای برنامه که اصلا جور در نمی‌آید، چون معناشناسی ما خاصیت پیشوندی بودن را دارد و مطمئن هستیم در معنای هر برنامه‌ای حتما یک رد پیشوندی متناهی با محیط اولیه‌ی مورد بررسی وجود دارد.

اگر هم بخواهیم تعریف توقف پذیری را وجودنداشتن ردهای پیشوندی نامتناهی با محیط اولیه‌ی مورد بررسی در معنای برنامه در نظر بگیریم در ابتدا به نظر می‌آید که به تعریف قوی‌تری نسبت به آنچه ارائه دادیم رسیده‌ایم. ما در اینجا سعی داریم تعریفی را ارائه کنیم که برای حرف‌هایی که در \cite{calcul} زده شده تا حد امکان مشکل درست نکند، که اگر دیدیم با این وجود مشکل وجود دارد مطمئن باشیم که اشتباه در \cite{calcul} است و نه حرف ما. پس سعی از ارائه‌ی این تعریف که به نظر از تعریف ارائه شده با کار ناسازگارتر می‌آید اجتناب می‌کنیم( در ادامه به بیان ناسازگاری پراخته شده) اما در قضیه‌ی بعدی می‌بینیم که تعریفی که ارائه کردیم با همان که بگوییم در برنامه رد پیشوندی نامتناهی وجود ندارد معادل است.
\begin{thm}
	برای برنامه‌ی $\mathsf{P}$ و محیط اولیه‌ی $\underline{\rho}$ داریم $\mathsf{P} , \underline{\rho} \downarrow $ اگر و تنها اگر با فرض اینکه $\rho$ محیط متناظر با محیط اولیه‌ی $\underline{\rho}$ است و
	$$\forall \pi \in \mathbb{S^{+\infty}} : 
	\langle at \llbracket \mathsf{P} \rrbracket , \rho \rangle \pi \in \mathcal{S^*} \llbracket \mathsf{P} \rrbracket \rightarrow
	\langle at \llbracket \mathsf{P} \rrbracket , \rho \rangle \pi \in \mathbb{R^+}$$
	 
\end{thm}
\begin{proof}
	$(\Rightarrow)$
	برای این قسمت باید ثابت کنیم که در معنای هر برنامه‌ای رد پیشوندی‌ای وجود دارد که با
	$\langle at\llbracket \mathsf{P} \rrbracket , \rho \rangle$
	شروع شده و به ازای یک محیط $\rho'$ به 
	$\langle aft\llbracket \mathsf{P} \rrbracket , \rho' \rangle$
	ختم شده. 
	در این اثبات از تعریف برچسب‌ها که در ضمیمه‌ی \cite{calcul} آمده استفاده شده.
	داریم 
	$\mathsf{P=Sl}$
	و 
	$aft \llbracket \mathsf{P} \rrbracket = aft \llbracket \mathsf{Sl} \rrbracket $
	
	حکم را با استقرا روی ساختار $\mathsf{Sl}$ ثابت می‌کنیم. 
	$$\blacktriangleright \mathsf{Sl = \backepsilon}:$$
	داریم:
	$$\mathcal{S^*} \llbracket \backepsilon \rrbracket = \{\langle at \llbracket \backepsilon \rrbracket , \dot{\rho} \rangle | \dot{\rho} \in \mathbb{EV}\}$$
	و طبق تعریف برچسب‌ها داریم:
	$$at \llbracket \backepsilon \rrbracket = aft \llbracket \backepsilon \rrbracket$$
	پس حکم برقرار است.
	$$\blacktriangleright \mathsf{Sl =Sl'\;S}:$$
	اینکه در معنای $\mathsf{Sl}$ دنباله‌ای شامل
	 $\langle aft \llbracket \mathsf{Sl} \rrbracket , \rho '\rangle$ وجود داشته باشد، به با توجه به تعاریفی که داریم به این وابسته است که در معنای $\mathsf{S}$ دنباله‌ای شامل $\langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle$ وجود داشته باشد. برای اینکه این را ثابت کنیم هم باید همین حکم را روی ساختار $\mathsf{S}$ ثابت کنیم که در واقع بخش اصلی اثبات این سمت قضیه است. 
	$$\blacktriangleright\blacktriangleright \mathsf{S\;=\; x\doteq A;}:$$
	در این حالت با توجه به تعریف معنای $\mathsf{S}$ که قبل‌تر ارائه شد، دنباله‌ی 
	$$\langle at \llbracket \mathsf{S} \rrbracket ,\rho \rangle \langle aft\llbracket\mathsf{S}\rrbracket , \rho[\mathsf{x}\leftarrow \mathcal{A}\llbracket\mathsf{A}\rrbracket\rho] \rangle $$
	در معنای دستور به ازای هر $\rho$ وجود دارد که خب در هر صورت این شامل محیط متناظر با $\underline{\rho}$ هم می‌شود .
	$$\blacktriangleright\blacktriangleright \mathsf{S=\; ; \;\;}:$$	 
با توجه به معنای این دستوردنباله‌ی زیر در معنای این دستور وجود دارد.
$$\langle at \llbracket \mathsf{S} \rrbracket ,\rho \rangle \langle aft\llbracket\mathsf{S}\rrbracket , \rho \rangle $$

$$\blacktriangleright\blacktriangleright \mathsf{S=\; if\;(B)\;S_t}:$$
	در صورتی که 
	$\mathcal{B}\llbracket\mathsf{B}\rrbracket\rho=\mathit{T}$
	دنباله‌ی 
	$$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle
	\langle at \llbracket \mathsf{S_t} \rrbracket , \rho \rangle \pi$$
	در مجموعه‌ی معنای این دستور حضور دارد در حالیکه 
	$\langle at \llbracket \mathsf{S_t} \rrbracket , \rho \rangle \pi$
	داخل معنای $\mathsf{S_t}$ است و طبق فرض استقرا می‌دانیم که برچسب آخرین موقعیت $\pi$ برابر است با $aft \llbracket \mathsf{S_t} \rrbracket$ که طبق تعاریف مربوط به برچسب‌ها 
	$aft \llbracket \mathsf{S_t} \rrbracket=aft \llbracket \mathsf{S} \rrbracket$.
	در صورتی که معنای عبارت بولی غلط باشد هم دنباله‌ی زیر در معنای دستور طبق تعریف موجود است.
	$$\langle at \llbracket \mathsf{S} \rrbracket ,\rho \rangle \langle aft\llbracket\mathsf{S}\rrbracket , \rho \rangle $$
	
$$\blacktriangleright\blacktriangleright \mathsf{S=\; if\;(B)\;S_t\;else\;S_f}:$$
مانند حالت قبل است منتها با این تفاوت که در صورتی که معنای عبارت بولی غلط باشد دنباله‌ی زیر در معنای دستور حضور دارد:
	$$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle
\langle at \llbracket \mathsf{S_f} \rrbracket , \rho \rangle \pi$$
و تساوی 
$aft \llbracket \mathsf{S_t} \rrbracket=aft \llbracket \mathsf{S} \rrbracket=aft \llbracket \mathsf{S_f} \rrbracket$
هم طبق تعریف برچسب‌ها برقرار است.

$$\blacktriangleright\blacktriangleright \mathsf{S=\; while\;(B)\;S_t}:$$
در اثبات این سمت قضیه این حالت پیچیده ترین حالت است و در واقع تنها حالتی است که در اثبات آن به فرض قضیه احتیاج داریم! همان طور که پیشتر گفتیم معنای حلقه با استفاده از یک تابع تعریف می‌شود. معنای حلقه کوچکترین نقطه ثابت این تابع است، در حالیکه انگار این تابع وقتی روی یک مجموعه از ردهای پیشوندی اعمال شود، تاثیرات یک بار اجرای دستورات درون حلقه را روی ردهای پیشوندی درون مجموعه اعمال می‌کند.

طبق تعریف $\mathcal{F}$ مطمئن هستیم که رد پیشوندی‌ای که با محیط $\underline{\rho}$ شروع شود در مجموعه‌ی معنای $\mathsf{S}$ وجود دارد، چونکه به ازای هر محیط $\dot{\rho}$(نقطه به این خاطر است که با $\rho$ خاص موجود در فرض اشتباه گرفته نشود) حالت 
$\langle at \llbracket \mathsf{S} \rrbracket, \dot{\rho} \rangle$
 در هر اعمال تابع $\mathcal{F}$ روی هر مجموعه‌ی دلخواه وجود دارد. وقتی معنای $\mathsf{S}$ را به عنوان کوچک‌ترین نقطه ثابت $\mathcal{F}$ در نظر گرفته‌ایم پس مطمئن هستیم که آن مجموعه‌ای که کوچکترین نقطه ثابت است شامل رد پیشوندی 
 $\langle at \llbracket \mathsf{S} \rrbracket, \rho \rangle$
 است. این رد پیشوندی با اجرای $\mathcal{F}$ تحت تاثیر قرار می‌گیرد. اگر معنای $\mathsf{B}$ در یکی از اعمال های $\mathcal{F}$ غلط باشد، رد پیشوندی
$ \langle at \llbracket \mathsf{S} \rrbracket, \rho \rangle \pi \langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle$ 
در معنای برنامه قرار خواهد گرفت و می‌توانیم بگوییم اجرای دستور با این محیط اولیه توقف پذیر است. می‌دانیم که طبق تعریف تابع به انتهای این رد پیشوندی چیزی اضافه نمی‌شود. از طرف دیگر هم با این محیط اولیه، با توجه به تعریف رد پیشوندی دیگری وجود ندارد که طولانی‌تر از رد پیشوندی مورد اشاره باشد. 

در حالت دیگر اگر فرض کنیم هیچ گاه به حالتی نمی‌رسیم که در آن معنای $\mathsf{B}$ غلط باشد هم با فرض مسئله به تناقض می‌خوریم، چون در آن صورت تابع $\mathcal{F}$ مدام به طول دنباله‌‌هایی که با محیط $\rho$ شروع می‌شوند می‌افزاید و این یک دنباله‌ی نامتناهی را خواهد ساخت. در صورتی که معنای $\mathsf{B}$ هیچ گاه صحیح نباشد، حداقل حالت 
$\langle at \llbracket \mathsf{S_t} \rrbracket , \rho'' \rangle$
به ته دنباله‌های پیشین اضافه خواهد شد و از این جهت مطمئن هستیم که دنباله‌ی نامتناهی گفته شده در معنای دستور حضور خواهد داشت. 

پس با این تفاصیل، این مورد هم ثابت می‌شود.

\break$$\blacktriangleright\blacktriangleright \mathsf{S=\; break;}:$$
در تعریف تابع $aft$ روی برچسب‌ها در \cite{calcul} این تعریف برای این دستور مشخص نیست! در \cite{cousotbook} که در مورد برچسب‌ها بحث شده، نویسنده‌ی \cite{calcul} گفته که در مورد آن بخش از تعاریف توابع مربوط به برچسب‌ها که تعریف نشده‌اند برداشت آزاد است و ما در اینجا سعی داریم معقول ترین برداشتی که نسبت به درکمان از این کار می‌توانیم داشته باشیم را بیان کنیم. مهم‌ترین چیزی که در مورد برچسب‌ها در مورد این دستور قرار است برقرار باشد این است که اگر این دستور بخشی از $\mathsf{S_t}$ در حلقه‌ی زیر باشد
$$\mathsf{S'=\; while\; (B)\; S_t}$$
در این صورت 
$aft \llbracket \mathsf{S'} \rrbracket = brk-to \llbracket \mathsf{S_t} \rrbracket $
را طبق تعریف داریم. انتظار می‌رود که\break 
$aft \llbracket \mathsf{break;} \rrbracket = aft \llbracket \mathsf{S'} \rrbracket$ 
باشد. اینکه دستورات برنامه پس از اجرای $\mathsf{break;}$ از خارج(یا به عبارت بهتر بعد از) حقله‌ی $\mathsf{S'}$ پی گرفته شود انتظار معقولی است از سیستمی که در حال توصیف رد اجرای برنامه‌های کامپیوتری است. البته در نظر گرفته شود که فرض کرده‌ایم که $\mathsf{S'}$ داخلی ترین حلقه‌ای است که $\mathsf{break;}$ درون آن جای دارد.

 از پس این فرض‌های ما 
$aft \llbracket \mathsf{break;} \rrbracket = break-to \llbracket \mathsf{S_t} \rrbracket$ 
نتیجه می‌شود و طبق تعریف معنای دستورات 
$\mathsf{break;}$
رد پیشوندی زیر در معنای این دستور وجود دارد
$$\langle at \llbracket \mathsf{break;} \rrbracket , \rho \rangle
\langle aft \llbracket \mathsf{break;} \rrbracket , \rho \rangle$$
 که نشانه‌ی توقف است.
 

$$\blacktriangleright\blacktriangleright \mathsf{S=\; \{ Sl'' \}}:$$
	در این صورت توقف پذیری $\mathsf{Sl''}$ را از فرض استقرای استقرایی که روی لیست دستورات زده بودیم داریم پس $\mathsf{\{Sl''\}}$ هم توقف پذیر است.
	
	
در اینجا اثبات این طرف قضیه به پایان می‌رسد.

($\Leftarrow$)
دوباره باید روی ساختار برنامه‌ها استقرا بزنیم و دوباره چون هر برنامه مساوی با یک لیست از دستورات است استقرا را ابتدا روی ساختار لیست دستورات و در دل آن روی ساختار دستورات استقرا می‌زنیم.

در این اثبات به غیر از یک حالت ساختار دستور، که دستور حلقه است، هر آنچه در مورد اثبات طرف راست قضیه گفتیم، به ما حکم را بدون نیاز به فرض نشان می‌دهد. بنابراین فقط در مورد اثبات همین یک مورد بحث می‌کنیم. 
$$\blacktriangleright\blacktriangleright \mathsf{S=\; while\; (B)\; S_t}:$$

اگر فرض کنیم این دستور به ازای محیط $\rho$ در حالت اول متوقف شده، در واقع فرض کرده‌ایم در معنای این دستور رد پیشوندی 
$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle \pi \langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle \pi'$ 
وجود دارد.
باید ثابت کنیم به ازای $\pi'$ دلخواه اگر رد پیشوندی
$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle \pi \langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle \pi'$ 
داخل 
$\mathcal{S^*}\llbracket \mathsf{S} \rrbracket$
وجود داشته باشد آنگاه
$\pi'=\epsilon$
برقرار است.

اگر برچسب
$aft \llbracket \mathsf{S} \rrbracket$
در یک حالت در رد پیشوندی‌ای که گفتیم حضور داشته باشد، یعنی در یک دور اجرای حلقه عبارت بولی معنی غلط می‌داده که حالتی شامل این برچسب به یک رد پیشوندی چسبانده شده و این رد پیشوندی ساخته شده. از طرفی دیگر هم می‌دانیم که وقتی عبارت بولی حاضر در ساختار حلقه غلط شده، دیگر به ردهای پیشوندی داخل معنای حلقه چیزی اضافه نمی‌شود. بنابراین سناریو‌ای جز $\pi'=\epsilon$ باقی نمی‌ماند. 
\end{proof}

پس با توجه به آنچه گفتیم می‌توانیم با خیال راحت توقف پذیری یک برنامه با یک محیط اولیه را معادل متناهی بودن همه‌ی ردهای پیشوندی‌ای بدانیم که با محیط متناظر با آن محیط اولیه شروع شده‌اند.
اگر در صورت ارائه شده از وارسی مدل عبارت منظم $\mathsf{R}$ را با عبارت منظم $\varepsilon$ جایگزین کنیم داریم:
$$\mathsf{P},\underline{\rho} \models \mathsf{R}
\Leftrightarrow
(\{\underline{\rho}\}\times \mathcal{S}^* \llbracket \mathsf{P}\rrbracket) \subseteq 
\mathsf{prefix} (\mathcal{S}^r \llbracket \varepsilon \bullet (?:\mathit{T})^*\rrbracket)
=\mathsf{prefix} (\mathcal{S}^r \llbracket (?:\mathit{T})^*\rrbracket)$$
طبق تعریف معنای عبارات منظم، هر رد پیشوندی متناهی‌ای داخل مجموعه‌ی سمت راستی رابطه‌ی زیرمجموعه بودن قرار می‌گیرد. این یعنی اگر الگوریتمی برای بررسی 
$\mathsf{P} , \underline{\rho} \models \mathsf{R} $
داشته باشیم، این الگوریتم می‌تواند تشخیص دهد آیا برنامه‌ی $\mathsf{P}$ با محیط اولیه‌ی $\underline{\rho}$ متوقف می‌شود یا خیر! این یعنی الگوریتمی برای مسئله‌ی توقف پذیری، مسئله‌ای که تصمیم ناپذیر است! بنابراین چنین الگوریتمی نباید وجود داشته باشد که یعنی پیاده سازی‌ای برای شیوه‌ای که در حال بیانش هستیم وجود ندارد! ادامه‌ی کار روی همین تعریف پیش می‌رود و دو صورت دیگر هم که قرار است ساختارمندتر باشند در نهایت با این صورت معادل‌اند، هرچند که پس از رسیدن به بیان دو صورت دیگر خواهیم دید که همین صحبت‌هایی که در مورد این صورت می‌کنیم در مورد صورت‌های دیگر هم بدون در نظر گرفتن معادل بودن این ۳ صورت برقرار است.





\section{درستی و تمامیت}
در این بخش سعی شده درستی و تمامیت این روش بر اساس تعریفی از درستی و تمامیت که در \cite{statica} آمده بررسی شود. محتویات این بخش نیز در \cite{calcul} نیامده.




