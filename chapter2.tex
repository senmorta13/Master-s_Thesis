
\chapter{صوری‌گری جدید برای روش وارسی مدل}

محوریت کار ما قرار است\cite{calcul} باشد که در آن سعی شده روش وارسی مدل با کمک نظریه تعبیر مجرد، بهبود داده شود. در\cite{clarke} روشی که معرفی شده در‌واقع ویژگی برنامه‌ها را به کمک منطق های \lr{LTL} یا \lr{CTL} بیان می‌کند. خود برنامه‌ها هم با کمک معناشناسی این منطق ها که نوع خاصی از مدل های کریپیکی به اسم سیستم گذار هستند توصیف می شوند. اما در\cite{calcul} کاری که انجام شده به این شکل است که منطق های \lr{LTL} و \lr{CTL} با عبارات منظم\cite{kleene56} جایگزین شده‌اند. علت این کار دو نکته بوده، اولی اینکه استفاده از عبارات منظم به جای منطق های نام برده شده می‌تواند برای برنامه نویسان ساده‌تر باشد و دومی اینکه عبارت منظم از از منطق های نام برده شده قدرت بیان بالاتری دارد.\cite{regisbetter} در ادامه ی کار وارسی مدل با استفاده از موجودات جدید تعریف شده به سه شکل مختلف بیان شده. در هر مرتبه بیان وارسی مدل، به‌گفته‌ی نویسنده، "ساختارمند"تر شده. می‌توان دریافت که فایده ساختارمندتر بودن بیان این است که پیاده‌سازی راحت‌تری دارد.\\
حال به بیان و بررسی تعاریف و خواص آن‌ها می‌پردازیم.

\section{نحو زبان مورد بررسی‬}

زبان بیان برنامه ها زیرمجموعه ای از دستورات زبان \lr{C} است، به شکل زیر:
$$\mathsf{x,y},... \in \mathbb{X}\hspace{4.65cm}$$
$$\mathsf{A} \in \mathbb{A} ::=\mathsf{1\:|\:x\:|\:A_1 - A_2\hspace{2.4cm}}$$  
$$\mathsf{B \in \mathbb{B} ::=A_1<A_2 \:|\: B_1 \: nand\: B_2\hspace{1.2cm}}$$
$$\mathsf{E \in \mathbb{E}::= A \: | \: B\hspace{4cm}}$$
$$\mathsf{S\in \mathbb{S} ::=\hspace{5cm}  }$$
$$\mathsf{x=A; \hspace{2.25cm}}$$
$$\mathsf{|\:\:\:;\hspace{3.75cm}}$$
$$\mathsf{|\:\:\:if\:(B)\:S\:|\:if\:(B)\:S\:else\:S}$$
$$\mathsf{|\:\:\:while\:(B)\:S\: | \: break;\hspace{0.65cm}}$$
$$\mathsf{|\:\:\:\{Sl\}\hspace{3.15cm}}$$
$$\mathsf{Sl \in \mathbb{SL}::=Sl\:\:\:S\:|\:\epsilon}\hspace{3.05cm}$$
$$\mathsf{P\in \mathbb{P}\:::=Sl}\hspace{4.25cm}$$

\vspace{1cm}
در اینجا زیر مجموعه‌ای از دستورات زبان \lr{C} را داریم. همین‌طور که قابل مشاهده است این زبان تا حد ممکن کوچک شده. علت این کار را بعدا عمیق‌تر حس خواهیم‌کرد. علتْ ساده‌تر شدن کار برای ارائه‌ی معناشناسی و تعبیر مجرد آن است. در اینجا راحتی آن برنامه‌نویسی که قرار است با این زبان برنامه بنویسد مطرح نبوده چون اصلا این زبان برای این کار ساخته نشده. نویسنده‌ی \cite{calcul} در اینجا صرفا می‌خواسته فرآیند را نشان دهد. اگر به فرض برای زبانی مانند پایتون بخواهیم درستی‌یابی با استفاده از روش ارائه شده را درست کینم، می‌توانیم همه‌ی راهی که در \cite{calcul} برای زبان توصیف شده، رفته‌شده را برای پایتون هم برویم و به یک تحلیل‌گر ایستا برای پایتون برسیم.
در مورد قدرت بیان این زبان هم می‌توانیم بگوییم که می‌توانیم باقی اعداد را از روی عدد ۱ و عملگر منها بسازیم. مثلا ابتدا 0 را به کمک ۱-۱ می سازیم و سپس با استفاده از 0 می‌توانیم یکی یکی اعداد منفی را بسازیم و سپس بعد از آن به سراغ اعداد مثبت می‌رویم که با کمک 0 و هر عدد منفی‌ای که ساختیم، ساخته می شوند. باقی اعداد و حتی باقی عملگر‌ها( یعنی به غیر از اعداد طبیعی) نیز از روی آنچه داریم قابل‌ساختن است. در مورد عبارت‌های بولی نیز داستان به همین منوال است. یعنی اینجا صرفا ادات شفر تعریف شده و باقی عملگر‌های بولی را می‌توان با استفاده از همین عملگر ساخت. باقی دستورات نیز دستورات شرط و حلقه هستند. باقی دستورات قرار است مطابق چیزی که از زبان \lr{C} انتظار داریم کار بکنند. در مورد دستور \lr{$\mathsf{break;}$} ذکر این نکته ضروری است که اجرای آن قرار است اجرای برنامه را از دستوری بعد از داخلی‌ترین حلقه‌ای که \lr{$\mathsf{break;}$} داخلش قرار دارد ادامه ‌دهد. در پایان می توان ثابت کرد که این زبان هم قدرت با مدل دیویس\cite{davis} است. 
توجه داریم که هر‌چه در این بخش در‌مورد معنای دستورات این زبان گفتیم، به هیچ وجه صوری نبود و صرفا درک شهودی ای که از معنای اجرای هر‌یک از دستورات داشتیم را بیان کردیم. بیان صوری معنای برنامه‌ها را، که برخلاف درک شهودی‌مان قابل انتقال به کامپیوتر‌ است، در ادامه بیان خواهیم‌کرد. طبیعتا این بیان صوری از روی یک درک شهودی ساخته شده‌است.

\section{معناشناسی زبان مورد بررسی‬}
معناشناسی زبانی را که در بخش پیش آوردیم با کمک مفاهیمی به نام برچسب و رد پیشوندی و عملگر چسباندن روی دو رود پیشوندی مختلف تعریف خواهیم‌کرد و نام این معناشناسی نیز معناشناسی رد پیشوندی است.\\

\subsection{برچسب‌ها}

با‌وجود اینکه خود زبان \lr{C} در قسمتی از زبان خود چیز‌هایی به نام برچسب دارد اما همین‌طور که در بخش پیشین دیدیم، در زبانی که اینجا در حال بحث روی آن هستیم خبری از برچسب‌ها نیست. اما برای تعریف صوری معنای برنامه‌ها، به شکلی که مورد بحث است، به آن‌ها نیاز است. در این بخش ابتدا به توضیحی مختصر در مورد برچسب‌ها در معناشناسی‌ زبان مورد بحث می‌پردازیم. تعاریف صوری دقیق این موجودات در پیوست \cite{calcul} آورده‌شده اند. برای اختصار از آوردن مستقیم این تعاریف در اینجا خود‌داری کرده‌ایم. 
در زبانمان \lr{$\mathsf{S}$}ها بخشی از موجودات موجود در زبان هستند. برچسب ها را برای \lr{$\mathsf{S}$}ها تعریف می‌کنیم. برچسب‌ها با کمک توابع \lr{labs, in, brks-of, brk-to, esc, aft, at} تعریف می‌شوند. در‌واقع هر $\mathsf{S}$ به ازای بعضی از این توابع یک برجسب دارد و این‌ها در‌واقع نشان‌دهنده‌ی آن برچسب هستند. بعض دیگر این توابع برای هر $\mathsf{S}$ ممکن است یک مجموعه از برچسب‌ها را تعیین‌ کند و یکی از آن‌ها هم با گرفتن $\mathsf{S}$ یک مقدار بولی را بر‌می‌گرداند. 
\\\\
\lr{at[$\mathsf{S}$]} : برچسب شروع $\mathsf{S}$\\
\lr{aft[$\mathsf{S}$]} : برچسب پایان $\mathsf{S}$، اگر پایانی داشته باشد\\
\lr{esc[$\mathsf{S}$]} : یک مقدار بولی را باز‌‌می‌گرداند که بسته به اینکه در $\mathsf{S}$ دستور $\mathsf{break;}$ وجود دارد یا خیر، مقدار درست یا غلط را بر‌می‌گرداند.\\
\lr{brk-to[$\mathsf{S}$]} : برچسبی است که اگر حین $\mathsf{S}$ دستور $\mathsf{break;}$ اجرا شود، برنامه از آن نقطه ادامه پیدا می کند.\\
\lr{brks-of[$\mathsf{S}$]} : مجموعه‌ای از برچسب $\mathsf{break;}$ های $\mathsf{S}$ را بر‌می‌گرداند.\\
\lr{in[$\mathsf{S}$]} : مجموعه‌ای از تمام برچسب‌های درون $\mathsf{S}$ را برمی‌گرداند.\\
\lr{labs[$\mathsf{S}$]} : مجموعه‌ای از تمام بر‌چسب‌هایی که با اجرای $\mathsf{S}$ قابل دسترسی هستند را بر‌می‌گرداند.\\\\\\


\subsection{رد پیشوندی}


پس از تعریف برچسب‌ها به سراغ تعریف رد پیشوندی می‌رویم. پیش از آن باید وضعیت‌ها و محیط‌ها را تعریف کنیم.
\begin{defn}
	(محیط): به ازای مجموعه مقادیر $\mathbb{V}$ و مجموعه متغیرهای $\mathbb{X}$ تابع 
	$\rho : \mathbb{X} \rightarrow \mathbb{V}$ 
	را یک محیط می‌گوییم. مجموعه‌ی همه‌ی محیط‌ها را با $\mathbb{EV}$ نمایش می‌دهیم.
\end{defn}

\begin{defn}
	(وضعیت): به هر زوج مرتبْ به ترتیب متشکل از یک برچسب $l$ و یک محیط $\rho$ یک وضعیت  
	$\langle l , \rho \rangle$
	می‌گوییم. مجموعه‌ی همه‌ی وضعیت‌ها را با $\mathbb{S}$ نشان می‌دهیم.
\end{defn}
\begin{defn}
	(رد پیشوندی): به یک دنباله از وضعیت‌ها(با امکان تهی بودن) یک رد پیشوندی می‌گوییم.
\end{defn}

 هر رد پیشوندی یک دنباله است که قرار است توصیفی از چگونگی اجرای برنامه باشد. وضعیت‌ها همان‌طور که از نامشان پیداست قرار‌ است موقعیت لحظه‌ای برنامه را توصیف کنند. $l$ قرار است برچسب برنامه‌ی در حال اجرا باشد و $\rho$ مقدار متغیر‌ها را در آن موقع از اجرای برنامه نشان می‌دهد. دنباله‌های ما می‌توانند متناهی یا نامتناهی باشند. مجموعه‌ی ردهای پیشوندی‌ متناهی را با $\mathbb{S^+}$ و مجموعه‌ی ردهای پیشوندی نامتناهی را با  $\mathbb{S^\infty}$ نمایش می‌دهیم. مجموعه‌ی همه‌ی ردهای پیشوندی را هم با $\mathbb{S^{+\infty}}$ نمایش می‌دهیم. 
با‌توجه به آنچه گفتیم، یک عملگر چسباندن $\Join$ را روی ردهای پیشوندی تعریف می‌کنیم. 
\begin{defn}
(عملگر چسباندن): اگر داشته باشیم 
$\pi_1 , \pi_2 \in \mathbb{S^{+\infty}}  , \sigma_1 ,\sigma_2 \in \mathbb{S}$
داریم:\\
\begin{center}
	اگر $\pi_1 \in \mathbb{S^+} $ داریم  $\hspace{2.60cm}  $                                     
	$\pi_1 \Join \pi_2 = \pi_1$    \\
	اگر $\sigma_1\neq\sigma_2$    $\hspace{1.6cm}  $
	$\pi_1 \Join \pi_2$ تعریف نشده است
	\\اگر $\pi_1 \in \mathbb{S^\infty} $ داریم   $\hspace{1cm}  $ 
	$\pi_1 \sigma_1 \Join \sigma_1 \pi_2 = \pi_1 \sigma_1 \pi_2 $
	
\end{center}
\end{defn}
همینطور $\epsilon$ هم یک رد پیشوندی است که حاوی هیچ وضعیتی نیست. به عبارت دیگر یک دنباله‌ی تهی است.

\subsection{تعریف صوری معناشناسی رد پیشوندی}
در این بخش قرار است دو تابع $\mathcal{A}$ و $\mathcal{B}$ را به ترتیب روی عبارات حسابی و بولی زبانمان یعنی $\mathsf{A}$ها و $\mathsf{B}$ها تعریف کنیم سپس با کمک آنها $\mathcal{S^*}$ را روی  مجموعه‌ای از اجتماع معنای $\mathsf{S}$ها و $\mathsf{Sl}$ها تعریف می کنیم. پس در نهایت هدف ما تعریف  $\mathcal{S^*}$ است.


\begin{defn}
(معنای عبارات حسابی - تابع $\mathcal{A}$): تابع 
$\mathcal{A}:\mathbb{A}\rightarrow \mathbb{EV} \rightarrow \mathbb{V}$
را به صورت بازگشتی روی ساختار 
$\mathsf{A} \in \mathbb{A}$
به شکل زیر تعریف می‌کنیم:
$$\mathcal{A[\mathsf{1}]\rho = }1     $$
$$\mathcal{A[\mathsf{x}]\rho = } \rho(\mathsf{x})          $$
$$\mathcal{A[\mathsf{A_1-A_2}]\rho = }\mathcal{A[\mathsf{A_1}]\rho }- \mathcal{A[\mathsf{A_2}]\rho }       $$

\end{defn}

\begin{defn}
	(معنای عبارات بولی - تابع $\mathcal{B}$): تابع 
	$\mathcal{B}: \mathbb{B} \rightarrow \mathbb{EV} \rightarrow \mathbb{BOOL}$
	را به صورت بازگشتی روی ساختار 
	$\mathsf{B} \in \mathbb{B}$
	به شکل زیر تعریف می‌کنیم:

\begin{center}
	اگر $\mathcal{A[\mathsf{A_1}]\rho }$ کوچکتر از $\mathcal{A[\mathsf{A_2}]\rho }$ باشد
	$\mathcal{B[\mathsf{A_1<A_2}]\rho = } True   \hspace{2cm}  $\\
	اگر $\mathcal{A[\mathsf{A_1}]\rho }$ بزرگتر از $\mathcal{A[\mathsf{A_2}]\rho }$ باشد
	$\mathcal{B[\mathsf{A_1<A_2}]\rho = } False   \hspace{2cm}  $\\
	$ \mathcal{B[\mathsf{B_1 nand B_2}]\rho = } \neg(\mathcal{B[\mathsf{B_1}]\rho}   \wedge \mathcal{B[\mathsf{B_2}]\rho}) $
\end{center}
\end{defn}

طبعا $\wedge$ و $\neg$ در فرازبان هستند.\\\\
در ادامه به تعریف $\mathcal{S^*}$ می‌پردازیم. این کار را با تعریف $\mathcal{S^*}$ روی هر ساخت $\mathsf{S}$ و $\mathsf{Sl}$ انجام می‌دهیم.
پیش از ادامه‌ی بحث باید این نکته را در‌مورد علامت‌گذاری‌هایمان ذکر کنیم که منظور از $        \mathsf{S} ::= l \mathsf{break;}  $ این است که تاکید کرده‌ایم که $\mathsf{S}$ با برچسب $l$ شروع شده‌است وگرنه همین طور که گفتیم   $l$ جزو زبان نیست.\\\\

\begin{defn}
	(معنای برنامه‌ها - تابع $\mathcal{S}^*$): 
اگر $        \mathsf{S} ::= \mathsf{break;}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S^*} [\mathsf{S}] = \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} \cup     \{ \langle at[\mathsf{S}] , \rho \rangle \langle brk-to[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \}             $$   


اگر $        \mathsf{S} ::=  \mathsf{x=A;}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S^*} [\mathsf{S}] = \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} \cup     \{ \langle at[\mathsf{S}] , \rho \rangle \langle aft[\mathsf{S}] , \rho[\mathsf{x}\leftarrow \mathcal{A}[\mathsf{A}]\rho] \rangle | \rho \in \mathbb{EV}       \}             $$   

اگر $         \mathsf{S} ::= \mathsf{if}  \mathsf{ (B) S_t}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S^*} [\mathsf{S}] = \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} \cup     \{ \langle at[\mathsf{S}] , \rho \rangle \langle aft[\mathsf{S}] , \rho \rangle | \mathcal{B}[\mathsf{B}] \rho =False      \} 
$$$$\cup    \{ \langle at[\mathsf{S}] , \rho \rangle \langle at[\mathsf{S_t}] , \rho \rangle 
\pi | \mathcal{B}[\mathsf{B}] \rho =True  \wedge   \langle  at[\mathsf{S_t}]  , \rho \rangle \pi \in \mathcal{S} [\mathsf{S_t}]    \}          $$ 


اگر $         \mathsf{S} ::= \mathsf{if}  \mathsf{ (B) S_t else S_f}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S} [\mathsf{S}] = \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} $$$$\cup     \{ \langle at[\mathsf{S}] , \rho \rangle \langle at[\mathsf{S_f}] , \rho \rangle 
\pi | \mathcal{B}[\mathsf{B}] \rho =False  \wedge   \langle  at[\mathsf{S_f}]  , \rho \rangle \pi \in \mathcal{S} [\mathsf{S_f}]    \}  
$$$$\cup    \{ \langle at[\mathsf{S}] , \rho \rangle \langle at[\mathsf{S_t}] , \rho \rangle 
\pi | \mathcal{B}[\mathsf{B}] \rho =True  \wedge   \langle  at[\mathsf{S_t}]  , \rho \rangle \pi \in \mathcal{S} [\mathsf{S_t}]    \}          $$ \\


اگر $         \mathsf{Sl} ::= \ni  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:

$$\mathcal{S} [\mathsf{Sl}] = \{ \langle at[\mathsf{Sl}] , \rho \rangle | \rho \in \mathbb{EV}       \}        $$ \\

اگر $         \mathsf{Sl} ::= \mathsf{Sl' \:\:\: S}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S} [\mathsf{Sl}] = \mathcal{S} [\mathsf{Sl'}] \cup( \mathcal{S} [\mathsf{Sl'}]
\Join \mathcal{S} [\mathsf{S}] )      $$ \\



اگر $         \mathsf{S} ::= \mathsf{while (B)S_b }   $ باشد، ماجرا نسبت به حالات قبل اندکی پیچیده‌تر می‌شود. تابعی به اسم $\mathcal{F} $ را تعریف خواهیم‌کرد که در حقیت دو ورودی دارد. ورودی اول آن یک دستور حلقه است و ورودی دوم آن یک مجموعه. به عبارتی دیگر می‌توانیم بگوییم به ازای هر حلقه یک تابع $\mathcal{F} $  جداگانه تعریف می‌شود که مجموعه‌ای از ردهای پیشوندی را می گیرد و مجموعه‌ای دیگر از همین موجودات را بازمی‌گرداند. کاری که این تابع قرار است انجام دهد این است که انگار یک دور دستورات داخل حلقه را اجرا می کند و دنباله‌هایی جدید را از دنباله‌های قبلی می‌سازد. معنای یک حلقه را کوچکترین نقطه ثابت این تابع در نظر می‌گیریم. در ادامه تعریف $\mathcal{F} $ آمده. با دیدن تعریف می توان به دلیل این کار پی‌برد. آن نقطه‌ای که دیگر $\mathcal{F} $ روی آن اثر نمی‌کند یا حالتی است که در آن دیگر شرط حلقه برقرار نیست و اصولا قرار نیست دستورات داخل حلقه اجرا شوند که طبق تعریف $\mathcal{F} $  می‌توانیم ببینیم که $\mathcal{F} $  در این حالت چیزی به ردهای پیشوندی اضافه نمی‌کند. یا اینکه حلقه به دستور $\mathsf{break;}$ خورده که در آن صورت وضعیتی به ته ردهای پیشوندی اضافه می‌شود که برچسبش خارج از مجموعه برچسب دستورات حلقه است و همین اضافه کردن هر چیزی را به ته ردهای پیشوندی موجود، توسط $\mathcal{F} $  غیرممکن می‌کند. بنابراین نقطه ثابت مفهوم مناسبی است برای اینکه از آن در تعریف صوری معنای حلقه استفاده کنیم. علت اینکه کوچکترین نقطه ثابت را به عنوان معنای حلقه در نظر می‌گیریم هم این است که مطمئن هستیم کوچکترین نقطه ثابت، هر رد پیشوندی ای را در خود داشته باشد به معنای اجرای برنامه مرتبط است. برای درک بهتر این نکته می‌توان به این نکته توجه کرد که با اضافه کردن وضعیت‌هایی کاملا بی‌ربط به اجرای برنامه به ته رد‌های پیشوندی، که صرفا برچسب متفاوتی با آخرین وضعیت هر رد پیشوندی دارند، نقطه ثابت جدیدی ساخته ایم. پس اگر خودمان را محدود به انتخاب کوچکترین نقطه ثابت نکنیم، به توصیفات صوری خوبی از برنامه‌ها دست پیدا نخواهیم‌کرد. در مورد نقطه ثابت تنها این نکته باقی می‌ماند که اصلا از کجا می‌دانیم که چنین نقطه ثابتی وجود دارد که در این صورت باید گفت مجموعه‌هایی که از ردهای پیشوندی تشکیل می‌شوند با عملگر زیرمجموعه بودن یک مشبکه را تشکیل می‌دهند و بنا به قضیه تارسکی\cite{tarski} برای چنین موجودی نقطه ثابت وجود دارد.
تعاریف موجوداتی که درموردشان صحبت کردیم به این شکل است:

$$\mathcal{S} [\mathsf{S}] = lfp^{\subseteq}\: \mathcal{F[\mathsf{S}]}      $$ $$\mathcal{F} [\mathsf{S}] X= \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} \cup $$
$$  \{ \pi_2 \langle l ,\rho \rangle \langle aft[\mathsf{S}],\rho \rangle |  \pi_2 \langle l ,\rho \rangle \in X \wedge \mathcal{B}[\mathsf{B}]\rho=False \wedge l= at[\mathsf{S}]   \} \cup      $$
$$  \{ \pi_2 \langle l ,\rho \rangle \langle at[\mathsf{S_b}],\rho \rangle \pi_3 |  \pi_2 \langle l ,\rho \rangle \in X \wedge \mathcal{B}[\mathsf{B}]\rho=True \wedge$$$$  \langle at[\mathsf{S_b}],\rho \rangle \pi_3 \in  \mathcal{S} [\mathsf{S_b}]   \wedge   l= at[\mathsf{S}]  \}  $$\\

اگر $         \mathsf{S} ::=;  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S} [\mathsf{S}] = \{ \langle at[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \} \cup     \{ \langle at[\mathsf{S}] , \rho \rangle \langle aft[\mathsf{S}] , \rho \rangle | \rho \in \mathbb{EV}       \}             $$  


اگر $         \mathsf{S} ::=\{\mathsf{Sl}\}  $ باشد، ردهای پیشوندی متناظر با اجرای این دستور را به شکل مجموعه‌ی زیر تعریف می کنیم:
$$\mathcal{S} [\mathsf{S}] = \mathcal{S} [\mathsf{Sl}] $$   \\
\end{defn}
در ادامه چند مثال می‌زنیم تا مفهوم موجودات تعریف شده مشخص‌تر شود.
\begin{exm}
	
\end{exm}
\begin{exm}
	
\end{exm}
\begin{exm}
	
\end{exm}

\section{ویژگی‌های معنایی برنامه‌ها}
تا به اینجای کار یک زبان آورده‌ایم و برای آن معنا تعریف کرده‌ایم. در این فصل می‌خواهیم در مورد ویژگی‌های برنامه‌هایی که در این زبان نوشته می‌شوند با توجه به معنای صوری‌ای که تعریف کرده‌ایم، صحبت کنیم. دقت شود که برای برنامه‌هایی که در یک زبان برنامه‌نویسی نوشته می‌شوند می‌توان به اشکال مختلفی ویژگی تعریف کرد؛ مثلا ویژگی‌های نحوی، مثل اینکه طول برنامه چند خط است یا هر کاراکتر چند بار به کار رفته، یا ویژگی‌های محاسباتی، مثل بررسی‌ سرعت برنامه یا میزان استفاده‌ی آن از حافظه که عموما در نظریه الگوریتم و پیچیدگی محاسبات بررسی می‌شود. منظور ما در اینجا از تعریف ویژگی، متناسب است با معناشناسی‌ای که برای برنامه‌هایمان تعریف کرده‌ایم. معناشناسی‌ای که تعریف کرده‌ایم درواقع سیر محاسباتی برنامه را توصیف می‌کند و ما می‌خواهیم ویژگی‌ها را با توجه به این موصوع تعریف کنیم. در این صورت می‌توانیم صحت عملکرد برنامه‌ها را با توجه به صادق بودن ویژگی‌هایی که در مورد آن‌ها تعریف شده بفهمیم.\\
ابتدا به تعریف ویژگی‌ها می‌پردازیم، سپس به سراغ تعریف یک نوع عبارت منظم می‌رویم که از آن برای بیان ویژگی‌ها استفاده می‌شود.
\subsection{ویژگی‌های معنایی}
همان‌طور که در بخش قبلی دیدیم، معنای هر برنامه با یک مجموعه‌ی 
$\mathcal{S^*} [\mathsf{S}]$
مشخص می‌شود. وقتی می‌خواهیم ویژگی‌هایی را برای موجوداتی که به کمک مجموعه‌ها تعریف شده اند بیان کنیم، اینکه ویژگی‌ها را هم با مجموعه‌ها بیان کنیم کار معقولی به نظر می‌رسد. مثل اینکه بخواهیم ویژگی زوج بودن را در مورد اعداد طبیعی بیان کنیم. می توانیم مجموعه‌ی $\mathbb{E}$ را به عنوان مجموعه‌ی همه‌ی اعداد زوج در نظر بگیریم و اینکه یک عدد زوج هست یا نه را عضویتش در مجموعه‌ی $\mathbb{E}$ تعریف کنیم. پس یعنی در مورد اعداد طبیعی قرار است هر ویژگی به شکل زیرمجموعه‌ای از تمام این اعداد در نظر گرفته شود. یعنی هر عضو 
$\mathit{P}(\mathbb{N})$
بنا به تعریف ما یک ویژگی از اعداد طبیعی است.
در مورد برنامه‌ها نیز قرار است همین رویه را پیش بگیریم. تابع 
$\mathcal{S^*}$
از نوع 
$\mathbb{P} \rightarrow \mathit{P}(\mathbb{S^+})$
است. یعنی یک برنامه را در ورودی می‌گیرد و یک مجموعه از ردهای پیشوندی را باز می‌گرداند. پس می‌توانیم هر ویژگی را به عنوان زیر مجموعه‌ای از 
$\mathit{P}(\mathbb{S^+})$
تعریف کنیم، به عبارت دیگر عضوی از
$\mathit{P(P}(\mathbb{S^+}))$.

\subsection{عبارات منظم}
در اینجا توصیف ویژگی‌ها برای هر برنامه باید یک چارچوب داشته باشد. در صورت قدیمی روش وارسی مدل ما از منطق های زمانی برای بیان ویژگی‌ها به صورت صوری استفاده می‌کردیم و این احتیاج به یک زبان برای صوری کردن کامل کار را، که رسیدن به بیان مسئله‌ی وارسی مدل است، به ما نشان می‌دهد. در اینجا ما با داستان دیگری هم رو به رو هستیم و آن این است که از آنجایی که با مجموعه‌ها سر و کار داریم و مجموعه‌ها چندان موجودات ساختنی‌ای نیستند( برخلاف مدل کریپکی)، بهتر است یک موجود ساختنی مثل یک زبان صوری برای بیان آن‌ها داشته باشیم. در این فصل قصد داریم یک نوع عبارت منظم را برای این منظور تعریف کنیم. ابتدا زبان این عبارت منظم را تعریف می‌کنیم، سپس به سراغ معناشناسی آن می‌رویم. 
\subsection{زبان عبارات منظم}
فرق عمده‌ای که زبان عبارات منظم ما با عبارات منظم کلاسیک دارد در کاراکترهاست. کاراکترها در زبان کلاسیک موجوداتی اتمی بودند، اما در اینجا ساختار دارند. در اینجا به جای هر کاراکتر یک زوج متشکل از مجموعه‌ی $\mathsf{L}$ و عبارت بولی $\mathsf{B}$ تشکیل شده‌اند که این زوج را به شکل 
$\mathsf{L : B}$
در زبانمان نمایش می‌دهیم.\\ 
زبان ما به شکل BNF زیر است:
\begin{defn}
$$\mathsf{L} \in \mathit{P}(\mathbb{L})$$        
$$\mathsf{x,y,...} \in \mathbb{X}$$
$$\mathsf{\underline{x},\underline{y},...} \in \mathbb{\underline{X}}$$
$$\mathsf{B} \in \mathbb{B}$$
$$\mathsf{R} \in \mathbb{R}$$
\newpage
$$\mathsf{R} ::=\hspace{0.5cm} \varepsilon\hspace{4.2cm}$$
$$|\:\:\:\mathsf{L : B}\hspace{2.4cm}$$
$$|\:\:\:\mathsf{R_1 R_2}\:\:\:(or\:\mathsf{R_1 \bullet R_2 })$$
$$\:\:\:\:\:\:\:|\:\:\:\mathsf{R_1\:\mid\:R_2}\:\:\:(or\:\mathsf{R_1 + R_2 })$$
$$|\:\:\:\mathsf{R_1^*}\hspace{2.8cm}$$
$$|\:\:\:\mathsf{R_1^+}\hspace{2.7cm}$$
$$|\:\:\:(\mathsf{R_1})\hspace{2.47cm}$$
\end{defn}
همان طور که قابل مشاهده است در اینجا عملگرهای دوتایی چسباندن
$(\bullet)$
 و انتخاب
$(|)$
 را داریم، به همراه عملگرهای یگانی 
$^*$
و
$^+$.
در ادامه خواهیم دید که در فرازبان معنی عملگر یگانی 
$^+$
به وسیله‌ی عملگر یگانی دیگر قابل بیان است، هرچند که در زبانمان هم برای سهولت کار از بیان این عملگر اجتناب نشده. 
توجه شود که پرانتزها هم جزئی از زبان قرار داده شده‌اند.


همین‌طور در اینجا می‌خواهیم از تعدادی عبارات مخفف که در ادامه کارمان را راحت‌تر می‌کنند صحبت کنیم. منظور از زوج 
$\mathsf{? : B}$
همان 
$\mathbb{L}\mathsf{ : B}$
است. عبارت 
$l : \mathsf{B}$
به جای عبارت 
$\{l\} : \mathsf{B}$
به کار می‌رود و منظور از عبارت 
$\neg l \mathsf{: B}$
نیز عبارت 
$\mathbb{L}\setminus\{l\}:\mathsf{B}$
است.

با یک نگاه به دستور این زبان یک نکته‌ی چشمگیر برای ما، با توجه به موجوداتی که در بخش قبل تعریف کردیم، با نگاه به قواعد این زبان می‌تواند وجود یک مجموعه‌ی
$\mathbb{\underline{X}}$
در کنار 
$\mathbb{X}$
که از قبل داشتیم باشد. قرار است به ازای هر 
$\mathsf{x}\in\mathbb{X}$
یک 
$\mathsf{\underline{x}}\in\mathbb{\underline{X}}$
داشته‌باشیم. منظور از 
$\mathsf{\underline{x}}$
مقدار متغیر 
$\mathsf{x}$
در ابتدای هر برنامه است. این یعنی تابع
$\underline{\rho}: \mathbb{\underline{X}} \rightarrow \mathbb{V}$
که 
$\mathbb{V}$
مجموعه‌ی مقادیر متغیرهاست( در بخش قبل به این اشاره نشد اما خود
$\rho$
هایی که در بخش قبل داشتیم هم از نوع
$\mathbb{X} \rightarrow \mathbb{V}$
بود. با توجه به زبانمان و توضیحاتی که در گذشته دادیم، می‌توان در نظر گرفت که در اینجا 
$\mathbb{V}$
همان 
$\mathbb{Z}$
یعنی اعداد صحیح است. دلیل استفاده از نماد
$\mathbb{V}$
به عنوان مجموعه مقادیر این است که روح کلی نگرانه‌ی کار حفظ شود). همان‌طور که پیش‌تر گفتیم برای اشاره به یک تابع
$\rho$
از کلمه‌ی "محیط" استفاده می‌شود. به همین منوال در ادامه برای اشاره‌ به 
$\underline{\rho}$
از "محیط اولیه" استفاده می‌کنیم. برای اشاره به مجموعه‌ی همه‌ی محیط‌های اولیه هم از نماد 
$\underline{\mathbb{EV}}$
استفاده می‌کنیم.
بقیه‌ی موجودات از جمله برچسب‌ها و عبارات بولی را هم که قبلا داشتیم.\\
در ادامه به بیان صوری معنای زبان بیان شده می‌پردازیم. پس از آن می‌توانیم با بررسی چند مثال، از اینکه معنای هر عبارت منظم چیست درکی شهودی به دست آوریم.\\

\subsection{معناشناسی عبارات منظم}
معنای عبارات منظم را با استفاده از تابع 
$\mathcal{S}^r$
نشان می‌دهیم. این تابع به این شکل تعریف می‌شود که در ورودی یک عبارت منظم 
$\mathsf{R}$
را می‌گیرد، سپس یک مجموعه از زوج مرتب‌های( یا همان‌طور که پیش‌تر نام‌گذاری کردیم "وضعیت‌ها"ی)
$\langle\underline{\rho} , \pi\rangle$
را که 
$\pi \in \mathbb{S^*}$
و 
$\underline{\rho} \in \underline{\mathbb{EV}}$
باز می‌گرداند. بنابراین این تابع از نوع
$\mathbb{R} \rightarrow \mathit{P} (\mathbb{\underline{EV} \times S^*})$
است. همین‌طور دقت شود که تا به حال از 
$\mathbb{S}^*$
صحبتی نکرده بودیم و فقط 
$\mathbb{S}^+$
را معرفی کرده بودیم. 
$\mathbb{S}^*$
نیز برابر است با
$\mathbb{S}^+ \cup \{\epsilon\}$ 
(به لحاظ معنایی همان عملگر
$^*$
است که در زبان عبارات منظمهم هست، مشهور به ستاره‌ی کلینی).

تعریف استقرایی تابع 
$\mathcal{S}^r$
به شکل زیر است:
\begin{defn}
	تابع 
	$\mathcal{S}^r:\mathbb{R}\rightarrow \mathit{P}(\mathbb{\underline{EV}\times S}^*)$
	به صورت استقرایی روی ساختار عبارت منظم $\mathsf{R}$ به صورت زیر تعریف می‌شود:
$$\mathcal{S}^r[\varepsilon]= \{ \langle \underline{\rho} , \epsilon \rangle | \underline{\rho} \in \underline{\mathbb{EV}}\}$$
[یعنی معنای عبارت منظم
$\varepsilon$
مجموعه‌ای شامل زوج مرتب‌هایی از محیط‌های اولیه‌ی مختلف در کنار رد پیشوندی تهی استفاده می‌کند.]
$$\mathcal{S}^r[\mathsf{L:B}] = \{\langle\underline{\rho},\langle l , \rho \rangle \rangle | l \in \mathsf{L} \land \mathcal{B}[\mathsf{B}] \underline{\rho},\rho \}$$
[این یعنی معنای عبارت 
$\mathcal{S}^r[\mathsf{L:B}]$
زوج مرتب‌هایی هستند که عضو اول آن‌ها محیط‌های اولیه مختلف هستند( مانند مورد قبلی و البته در موارد آتی!) و عضو دوم آن‌ها ردهای پیشوندی تک‌عضوی 
$\langle l , \rho \rangle$
هستند که در آن‌ها برچسب 
$l$
باید در
$\mathsf{L}$
که مجموعه‌ای از برچسب‌هاست حضور داشته باشد و عبارت بولی 
$\mathsf{B}$
باید درباره‌ی محیط اولیه
$\underline{\rho}$
و محیط 
$\rho$
برقرار باشد. حتما متوجه این نکته شدید که 
$\mathcal{B}$
در اینجا به جای اینکه از نوع 
$\mathbb{EV} \rightarrow \mathbb{BOOL}$
باشد،همان‌طور که قبلا تعریف کردیم، از نوع
$\underline{\mathbb{EV}} \rightarrow \mathbb{EV} \rightarrow \mathbb{BOOL}$
است.( منظور از 
$\mathbb{BOOL}$
همان مجموعه‌ی 
$\{True,False\}$
است.) در اینجا 
$\mathcal{A}$
و 
$\mathcal{B}$
را در ادامه با نوع‌های متفاوت دوباره تعریف خواهیم کرد، که البته فرق اساسی‌ای با تعریف قبلی ندارد و صرفا گسترشی ساده از آن است.]
$$\mathcal{S}^r[\mathsf{R_1 R_2}]= \mathcal{S}^r[\mathsf{R_1}] \Join \mathcal{S}^r[\mathsf{R_2}]$$
\begin{center}
	به‌طوری که در آن برای هر دو مجموعه‌ی 
	$\mathcal{S}$
	و
	$\mathcal{S'}$
	از رد‌های پیشوندی:
$$\mathcal{S \Join S'}=
\{
\langle \underline{\rho}, \pi \pi' \rangle |
\langle \underline{\rho},\pi \rangle \in \mathcal{S} \land
\langle \underline{\rho},\pi' \rangle \in \mathcal{S'}
\}
$$
\end{center}
[این یعنی اگر یک عبارت منظم داشته باشیم که از چسباندن 
$\mathsf{R_1}$
و 
$\mathsf{R_2}$
به هم ساخته شده باشد، آنگاه معنای این عبارت منظم با چسباندن ردهای پیشوندی موجود در مولفه‌ی دوم زوج مرتب‌هایی که اعضای مجموعه‌ی معنای این دو عبارت منظم هستند و گذاشتن این رد پیشوندی‌های حاصل از چسباندنْ در معنای عبارت منظم جدید تعریف می‌شود. همین‌طور که می‌بینید یک عملگر چسباندن برای دو مجموعه از این زوج‌های 
$\langle \underline{\rho} , \pi \rangle$
تعریف شده و در تعریف 
$\mathcal{S}^r [\mathsf{R_1 R_2}]$
از آن کمک گرفته شده.\\
تا این تکه از تعریف معنای عبارت منظم که رسیده‌ایم، تا حدی به دستیابی به درکی شهودی از اینکه به چه نحوی قرار است عبارات منظم راهی برای توصیف ویژگی‌ در مورد برنامه‌ها باشد نزدیک‌تر شده‌ایم. همان‌طور که در مورد قبل دیدیم هر زوج 
$\mathsf{L:B}$
دقیقا به یک وضعیتْ داخل یک رد پیشوندی اشاره می‌کند. انگار که قرار است این زوج‌ها موازی با وضعیت‌ها در ردهای پیشوندی موجود در معنای یک برنامه جلو روند و منطبق باشند تا وارسی مدل انجام شود. درک این موضوع اولین قدم ماست در دیدن عصاره‌ی روش وارسی مدل در ادبیاتی که از اول این فصلْ عَلَم کرده‌ایم.]
$$\mathcal{S}^r [\mathsf{R_1\:|\:R_2}]= 
\mathcal{S}^r [R_1] \cup
\mathcal{S}^r [R_2]$$
[این موردْ معنای اعمال عملگر انتخاب روی دو عبارت منظم را توصیف می‌کند. معنای اعمال این عملگر به‌سادگی به صورت اجتماع معنای هر دو عبارت منظم تعریف شده.]

$$\mathcal{S}^r [\mathsf{R}]^0 = \mathcal{S}^r[\varepsilon]$$
$$\mathcal{S}^r [\mathsf{R}]^{n+1} = \mathcal{S}^r [\mathsf{R}]^{n} \Join
\mathcal{S}^r [\mathsf{R}]$$
[دو عبارت اخیر برای توصیف معنای عملگرهای $^*$ و $^+$ تعریف شده‌اند. عملگر $\Join$ و معنای 
$\mathcal{S}^r[\varepsilon]$
را هم که قبلا تعریف کرده بودیم و $0$ و $n$ و $n+1$ هم اعداد طبیعی‌اند و $+$ لاجرم همان جمع اعداد طبیعی است.]
$$\mathcal{S}^r[\mathsf{R^*}] =  \bigcup_{n \in \mathbb{N}}
\mathcal{S}^r [\mathsf{R}^n]$$
$$\mathcal{S}^r[\mathsf{R^+}] =  \bigcup_{n \in \mathbb{N}\setminus\{0\}}
\mathcal{S}^r [\mathsf{R}^n]$$
[این دو عبارت هم تعریف معنای خود دو عملگر $^*$ و $^+$ هستند. منظور از $\mathbb{N}$ مجموعه‌ی اعداد طبیعی است. همان‌طور که قبل‌تر هم اشاره شد $^+$ را می‌توان در فرازبان با $^*$ تعریف کرد. اضافه می‌کنیم که خود $^*$ را هم در فرازبان می‌توان با عملگر انتخاب تعریف کرد و در اینجا می‌توان این نکته را هم دید.]

$$\mathcal{S}^r [(\mathsf{B})]=\mathcal{S}^r [\mathsf{B}]$$
[این تکه از تعریف هم صرفا بیان می‌کند که پرانتزها تاثیری در معنای عبارات منظم ندارند که کاملا قابل انتظار است چرا که وجود پرانتز قرار است در صرفا در خواص نحوی زبان اثر بگذارد.]
\end{defn}
تعریف معنای عبارات منظم در اینجا تمام می‌شود اما همان‌گونه که در لا‌به‌لای تعاریف گفتیم، احتیاج داریم که $\mathcal{A}$ و $\mathcal{B}$ را از نو تعریف کنیم:
\begin{defn}
	توابع 
	$\mathcal{A}:\mathbb{A}\rightarrow \mathbb{\underline{EV}} \rightarrow
	\mathbb{EV} \rightarrow \mathbb{V}$
	و 
	$\mathcal{B}:\mathbb{B}\rightarrow \mathbb{\underline{EV}} \rightarrow
	\mathbb{EV} \rightarrow \mathbb{BOOL}$
	به شکل استقرایی به ترتیب روی ساختارهای 
	$\mathsf{A}\in\mathbb{A}$
	و
	$\mathsf{B} \in \mathbb{B}$
	به شکل زیر تعریف می‌شوند:
	
	
$$\mathcal{A}[\mathsf{1}]\underline{\rho},\rho=1$$
$$\mathcal{A}[\mathsf{\underline{\mathsf{x}}}]\underline{\rho},\rho= \underline{\rho}(\mathsf{x})$$
$$\mathcal{A}[\mathsf{\mathsf{x}}]\underline{\rho},\rho= \rho(\mathsf{x})$$
$$\mathcal{A}[\mathsf{A_1 - A_2}]\underline{\rho},\rho= 
\mathcal{A}[\mathsf{A_1}]\underline{\rho},\rho - \mathcal{A}[\mathsf{A_2}]\underline{\rho},\rho$$
$$\mathcal{B}[\mathsf{A_1 < A_2}]\underline{\rho},\rho=
	\mathcal{A}[\mathsf{A_1}]\underline{\rho},\rho\: <\: \mathcal{A}[\mathsf{A_2}]\underline{\rho},\rho$$
$$\mathcal{B}[\mathsf{B_1\:nand\:B_2}]\underline{\rho},\rho=
\mathcal{B}[\mathsf{B_1}]\underline{\rho},\rho \uparrow 
\mathcal{B}[\mathsf{B_2}]\underline{\rho},\rho $$
\end{defn}
به‌راحتی قابل مشاهده است که تعاریف جدید تا حد خوبی به تعاریف قبلی شبیه هستند و فرق عمده صرفا وارد شدن $\underline{\rho}$ است.\\
حال به سراغ چند مثال از عبارات منظم و معنای آن‌ها می‌رویم.
\begin{exm}
	فرض کنید عبارت منظم ما

\end{exm}

\begin{exm}
	
	{این سه تا مثال باید با سه تا مثال بخش معناشناسی برنامه‌ها سینک باشن! همین طور در ادامه بعد از تعریف مدل چکینگ در این فصل هم ۳ تا مثال خواهیم داشت که قراره هر کدومشون از این ۳ تا مثال و ۳ تا مثالی که قبلا تعریف کردیم تشکیل شده باشن.}
\end{exm}

\begin{exm}
	
\end{exm}

تا اینجای کار بیشتر مفاهیمی که برای بیان صورت جدید مسئله‌ی وارسی مدل احتیاج داریم را بیان کرده‌ایم. 
\subsection{واریته‌های مختلف زبان عبارات منظم}
به عنوان قسمت آخر این بخشْ واریته‌های مختلفی از زبان عبارات منظم را بیان می‌کنیم. ، که هر کدام در واقع زیرمجموعه‌هایی از کل عبارات زبانی که توصیف کرده‌ایم را توصیف می‌کنند. بعضی از آن‌ها را در همین فصل برای هدف نهایی این فصل و بعضی دیگر را در فصل بعدی استفاده می‌کنیم.

اولین واریته‌ای که می‌خواهیم بیان کنیم، واریته‌ای است که در اعضای آن اصلا عبارت 
$\mathsf{L : B}$
حضور ندارد و کل عبارت‌های زبان از $\varepsilon$ ها تشکیل شده‌اند.
\begin{defn}
	(عبارت منظم تهی - $\mathbb{R_\varepsilon}$): 
	$$\mathsf{R} \:\:\:\in\:\:\: \mathbb{R}_\varepsilon$$
	$$\mathsf{R}\:\:\: ::= \:\:\: \varepsilon \: | \: \mathsf{R_1 R_2} \: | 
	\: \mathsf{R_1 + R_2} \: | \: \mathsf{R_1^*} \: | \: \mathsf{R_1^+} | (\mathsf{R_1})$$
\end{defn}


 با توجه به بخش قبل متوجه هستیم که معنای همه‌ی این عبارت‌ها برابر 
$\{\langle \underline{\rho} , \epsilon \rangle\}$
خواهد بود.

واریته‌ی بعدی عبارت منظم ناتهی است.
\begin{defn}
	(عبارت منظم ناتهی - $\mathbb{R}^+$):
	$$\mathsf{R} \:\:\:\in\:\:\: \mathbb{R}^+$$
	$$\mathsf{R}\:\:\: ::= \:\:\: \mathsf{L:B} \: |
	\: \mathsf{\varepsilon R_2} \: | \: \mathsf{R_1 \varepsilon} \: |
	\: \mathsf{R_1 R_2} \: | 
	\: \mathsf{R_1 + R_2} \: | \: \mathsf{R_1^+} | (\mathsf{R_1})$$
\end{defn}
دلیل وجود 
$\mathsf{\varepsilon R_2}$
و 
$\mathsf{R_1 \varepsilon}$
در تعریف این است که ممکن است معنای عبارتی با معنای عبارات عضو $\mathbb{R}_\varepsilon$ برابر نباشد( بعنی برابر ${\langle \underline{\rho} , \epsilon \rangle}$ نباشد)، اما در خود عبارتْ $\varepsilon$ حضور داشته باشد. با این تفاصیل می‌توان دید که دو مجموعه‌ی 
$\mathbb{R}_\varepsilon$
و
$\mathbb{R}^+$
یک افراز برای مجموعه‌ی $\mathbb{R}$ هستند، براساس اینکه معنای هر عبارت در $\mathbb{R}$ برابر ${\langle \underline{\rho} , \epsilon \rangle}$ هست یا خیر. بنابراین شاید به نظر برسد که تعریف یکی از آن‌ها به طور ساختاری کافی بود، اما ممکن است درجایی احتیاج داشته باشیم که ساختاری استقرایی روی هر یک از آن‌ها عَلَم کنیم یا اینکه در اثبات حکمی بخواهیم از استقرا روی یکی از این دو ساختار استفاده کنیم.

واریته‌ی آخر عبارات منظم ما نیز عبارات منظم بدون انتخاب است.
\begin{defn}
(عبارت منظم بدون انتخاب - $\mathbb{R}^\nmid$):
$$
\mathsf{R}\:\:\: \in \:\:\: \mathbb{R}^\nmid$$
$$
\mathsf{R}\:\:\: ::= \:\:\: \varepsilon \: | \: \mathsf{L:B} \: | \:
\mathsf{R_1 R_2} \: | \: \mathsf{R_1}^* \: | \: \mathsf{R_1}^+ \: | \:
(\mathsf{R_1})$$
\end{defn}

\section{صورت جدید مسئله‌ی وارسی مدل}
بالاخره به هدف نهایی این فصل رسیدیم. می‌خواهیم صورت جدیدی از مسئله‌ی وارسی مدل را بیان ‌کنیم.\\
پیش از ارائه‌ی تعریف وارسی مدل نیاز داریم تا عملگر بستار پیشوندی را برای یک مجموعه از ردهای پیشوندی معرفی کنیم.
\begin{defn}
	اگر 
	$\Pi \in \mathit{P}(\mathbb{\underline{EV}\times S^+})$
	آنگاه بستار پیشوندی $\Pi$را به صورت زیر تعریف می‌کنیم:
	$$\mathsf{prefix}(\Pi)=
	\{\langle \underline{\rho},\pi\rangle | \pi \in \mathbb{S^+} \land \exists\
	\pi' \in \mathbb{S^*}: \langle \underline{\rho}, \pi \pi' \rangle \in \Pi \}$$
\end{defn}

به زبان ساده‌تر همان‌طور که پیش‌تر گفتیم ردهای پیشوندی دنباله هستند و منظور از بستار یک رد پیشوندی، مجموعه‌ی همه‌ی ردهای پیشوندی ناتهی است که زیردنباله های آن رد پیشوندی هستند، در ادامه بستار یک مجموعه از ردهای پیشوندی هم می‌شود هر رد پیشوندی‌ای که زیردنباله‌ی یک رد پیشوندی موجود در آن مجموعه باشد.
\begin{exm}
	اگر 
	$\Pi = \{\langle l_1 , \rho_1 \rangle  \langle l_2  \rho_2 \rangle  \langle l_3 , \rho_3 \rangle 
	,
	\langle {l_1}' , {\rho_1}' \rangle  \langle {l_2}'  {\rho_2}' \rangle
	\}$ 
	باشد( $\Pi$ شامل دو عضو است) آنگاه:
	$$
	\mathsf{prefix}(\Pi)=
	\{
	\langle l_1 , \rho_1 \rangle ,
	\langle l_1 , \rho_1 \rangle  \langle l_2  \rho_2 \rangle,
	\langle l_1 , \rho_1 \rangle  \langle l_2  \rho_2 \rangle  \langle l_3 , \rho_3 \rangle ,
	\langle {l_1}' , {\rho_1}' \rangle,
	\langle {l_1}' , {\rho_1}' \rangle  \langle {l_2}'  {\rho_2}' \rangle
	\}
	$$
	که شامل 5 عضو است.
\end{exm}

\begin{defn}
	اگر 
	$\mathsf{P}\in\mathbb{P} , \mathsf{R} \in \mathbb{R}^+ , \underline{\rho} \in \underline{\mathbb{EV}}$
	آنگاه:
	$$\mathsf{P},\underline{\rho} \models \mathsf{R}
	 \Leftrightarrow
	(\{\underline{\rho}\}\times \mathcal{S}^* [\mathsf{P}]) \subseteq 
	\mathsf{prefix} (\mathcal{S}^r [\mathsf{R} \bullet (?:\mathit{T})^*])
	$$
\end{defn}




