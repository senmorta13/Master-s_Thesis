
\chapter{صوری‌گری جدید برای روش وارسی مدل}

\section{ویژگی‌های معنایی برنامه‌ها}
تا به اینجای کار یک زبان آورده‌ایم و برای آن معنا تعریف کرده‌ایم. در این فصل می‌خواهیم در مورد ویژگی‌های برنامه‌هایی که در این زبان نوشته می‌شوند با توجه به معنای صوری‌ای که تعریف کرده‌ایم، صحبت کنیم. دقت شود که برای برنامه‌هایی که در یک زبان برنامه‌نویسی نوشته می‌شوند می‌توان به اشکال مختلفی ویژگی تعریف کرد؛ مثلا ویژگی‌های نحوی، مثل اینکه طول برنامه چند خط است یا هر کاراکتر چند بار به کار رفته، یا ویژگی‌های محاسباتی، مثل بررسی‌ سرعت برنامه یا میزان استفاده‌ی آن از حافظه که عموما در نظریه الگوریتم و پیچیدگی محاسبات بررسی می‌شود. منظور ما در اینجا از تعریف ویژگی، متناسب است با معناشناسی‌ای که برای برنامه‌هایمان تعریف کرده‌ایم. معناشناسی‌ای که تعریف کرده‌ایم درواقع سیر محاسباتی برنامه را توصیف می‌کند و ما می‌خواهیم ویژگی‌ها را با توجه به این موصوع تعریف کنیم. در این صورت می‌توانیم صحت عملکرد برنامه‌ها را با توجه به صادق بودن ویژگی‌هایی که در مورد آن‌ها تعریف شده بفهمیم.\\
ابتدا به تعریف ویژگی‌ها می‌پردازیم، سپس به سراغ تعریف یک نوع عبارت منظم می‌رویم که از آن برای بیان ویژگی‌ها استفاده می‌شود.
\subsection{ویژگی‌های معنایی}
همان‌طور که در بخش قبلی دیدیم، معنای هر برنامه با یک مجموعه‌ی 
$\mathcal{S^*} {\mathsf{S}}$
مشخص می‌شود. وقتی می‌خواهیم ویژگی‌هایی را برای موجوداتی که به کمک مجموعه‌ها تعریف شده اند بیان کنیم، اینکه ویژگی‌ها را هم با مجموعه‌ها بیان کنیم کار معقولی به نظر می‌رسد. مثل اینکه بخواهیم ویژگی زوج بودن را در مورد اعداد طبیعی بیان کنیم. می توانیم مجموعه‌ی $\mathbb{E}$ را به عنوان مجموعه‌ی همه‌ی اعداد زوج در نظر بگیریم و اینکه یک عدد زوج هست یا نه را عضویتش در مجموعه‌ی $\mathbb{E}$ تعریف کنیم. پس یعنی در مورد اعداد طبیعی قرار است هر ویژگی به شکل زیرمجموعه‌ای از تمام این اعداد در نظر گرفته شود. یعنی هر عضو 
$\mathit{P}(\mathbb{N})$
بنا به تعریف ما یک ویژگی از اعداد طبیعی است.
در مورد برنامه‌ها نیز قرار است همین رویه را پیش بگیریم. تابع 
$\mathcal{S^*}$
از نوع 
$\mathbb{P} \rightarrow \mathit{P}(\mathfrak{S^+})$
است. یعنی یک برنامه را در ورودی می‌گیرد و یک مجموعه از ردهای پیشوندی را باز می‌گرداند. پس می‌توانیم هر ویژگی را به عنوان زیر مجموعه‌ای از 
$\mathit{P}(\mathfrak{S^+})$
تعریف کنیم، به عبارت دیگر عضوی از
$\mathit{P(P}(\mathfrak{S^+}))$.

\subsection{عبارات منظم}
در اینجا توصیف ویژگی‌ها برای هر برنامه باید یک چارچوب داشته باشد. در صورت قدیمی روش وارسی مدل ما از منطق های زمانی برای بیان ویژگی‌ها به صورت صوری استفاده می‌کردیم و این احتیاج به یک زبان برای صوری کردن کامل کار را، که رسیدن به بیان مسئله‌ی وارسی مدل است، به ما نشان می‌دهد. در اینجا ما با داستان دیگری هم رو به رو هستیم و آن این است که از آنجایی که با مجموعه‌ها سر و کار داریم و مجموعه‌ها چندان موجودات ساختنی‌ای نیستند( برخلاف مدل کریپکی)، بهتر است یک موجود ساختنی مثل یک زبان صوری برای بیان آن‌ها داشته باشیم. در این فصل قصد داریم یک نوع عبارت منظم را برای این منظور تعریف کنیم. پیشتر به نکته‌ی دیگری در مورد استفاده از عبارات منظم، که متداول‌تر بودن بین جامعه‌ی برنامه نویسان است، صحبت کردیم. ابتدا زبان این عبارت منظم را تعریف می‌کنیم، سپس به سراغ معناشناسی آن می‌رویم. 
\subsection{زبان عبارات منظم}
فرق عمده‌ای که زبان عبارات منظم ما با عبارات منظم کلاسیک دارد در کاراکترهاست. کاراکترها در زبان کلاسیک موجوداتی اتمی بودند، اما در اینجا ساختار دارند. در اینجا به جای هر کاراکتر یک زوج متشکل از مجموعه‌ی $\mathsf{L}$ و عبارت بولی $\mathsf{B}$ تشکیل شده‌اند که این زوج را به شکل 
$\mathsf{L : B}$
در زبانمان نمایش می‌دهیم.\\ 
زبان ما به شکل BNF زیر است:
\begin{defn}
$$\mathsf{L} \in \mathit{P}(\mathbb{L})$$        
$$\mathsf{x,y,...} \in \mathbb{X}$$
$$\mathsf{\underline{x},\underline{y},...} \in \mathbb{\underline{X}}$$
$$\mathsf{B} \in \mathbb{B}$$
$$\mathsf{R} \in \mathbb{R}$$
\newpage
$$\mathsf{R} ::=\hspace{0.5cm} \varepsilon\hspace{4.2cm}$$
$$|\:\:\:\mathsf{L : B}\hspace{2.4cm}$$
$$|\:\:\:\mathsf{R_1 R_2}\:\:\:(or\:\mathsf{R_1 \bullet R_2 })$$
$$\:\:\:\:\:\:\:|\:\:\:\mathsf{R_1\:\mid\:R_2}\:\:\:(or\:\mathsf{R_1 + R_2 })$$
$$|\:\:\:\mathsf{R_1^*}\hspace{2.8cm}$$
$$|\:\:\:\mathsf{R_1^+}\hspace{2.7cm}$$
$$|\:\:\:(\mathsf{R_1})\hspace{2.47cm}$$
\end{defn}
همان طور که قابل مشاهده است در اینجا عملگرهای دوتایی چسباندن
$(\bullet)$
 و انتخاب
$(|)$
 را داریم، به همراه عملگرهای یگانی 
$^*$
و
$^+$.
در ادامه خواهیم دید که در فرازبان معنی عملگر یگانی 
$^+$
به وسیله‌ی عملگر یگانی دیگر قابل بیان است، هرچند که در زبانمان هم برای سهولت کار از بیان این عملگر اجتناب نشده. 
توجه شود که پرانتزها هم جزئی از زبان قرار داده شده‌اند.


همین‌طور در اینجا می‌خواهیم از تعدادی عبارات مخفف که در ادامه کارمان را راحت‌تر می‌کنند صحبت کنیم. منظور از زوج 
$\mathsf{? : B}$
همان 
$\mathbb{L}\mathsf{ : B}$
است. عبارت 
$l : \mathsf{B}$
به جای عبارت 
$\{l\} : \mathsf{B}$
به کار می‌رود و منظور از عبارت 
$\neg l \mathsf{: B}$
نیز عبارت 
$\mathbb{L}\setminus\{l\}:\mathsf{B}$
است.

با یک نگاه به دستور این زبان یک نکته‌ی چشمگیر برای ما، با توجه به موجوداتی که در بخش قبل تعریف کردیم، با نگاه به قواعد این زبان می‌تواند وجود یک مجموعه‌ی
$\mathbb{\underline{X}}$
در کنار 
$\mathbb{X}$
که از قبل داشتیم باشد. قرار است به ازای هر 
$\mathsf{x}\in\mathbb{X}$
یک 
$\mathsf{\underline{x}}\in\mathbb{\underline{X}}$
داشته‌باشیم. منظور از 
$\mathsf{\underline{x}}$
مقدار متغیر 
$\mathsf{x}$
در ابتدای هر برنامه است. این یعنی تابع
$\underline{\rho}: \mathbb{\underline{X}} \rightarrow \mathbb{V}$
که 
$\mathbb{V}$
مجموعه‌ی مقادیر متغیرهاست( در بخش قبل به این اشاره نشد اما خود
$\rho$
هایی که در بخش قبل داشتیم هم از نوع
$\mathbb{X} \rightarrow \mathbb{V}$
بود. با توجه به زبانمان و توضیحاتی که در گذشته دادیم، می‌توان در نظر گرفت که در اینجا 
$\mathbb{V}$
همان اعداد صحیح است). همان‌طور که پیش‌تر گفتیم برای اشاره به یک تابع
$\rho$
از کلمه‌ی "محیط" استفاده می‌شود. به همین منوال در ادامه برای اشاره‌ به 
$\underline{\rho}$
از "محیط اولیه" استفاده می‌کنیم. برای اشاره به مجموعه‌ی همه‌ی محیط‌های اولیه هم از نماد 
$\underline{\mathbb{EV}}$
استفاده می‌کنیم.
بقیه‌ی موجودات از جمله برچسب‌ها و عبارات بولی را هم که قبلا داشتیم.\\
در ادامه به بیان صوری معنای زبان بیان شده می‌پردازیم.\\

\subsection{معناشناسی عبارات منظم}
معنای عبارات منظم را با استفاده از تابع 
$\mathcal{S}^r$
نشان می‌دهیم. این تابع به این شکل تعریف می‌شود که در ورودی یک عبارت منظم 
$\mathsf{R}$
را می‌گیرد، سپس یک مجموعه از زوج مرتب‌های( یا همان‌طور که پیش‌تر نام‌گذاری کردیم "وضعیت‌ها"ی)
$\langle\underline{\rho} , \pi\rangle$
را که 
$\pi \in \mathbb{S^*}$
و 
$\underline{\rho} \in \underline{\mathbb{EV}}$
باز می‌گرداند. بنابراین این تابع از نوع
$\mathbb{R} \rightarrow \mathit{P} (\mathbb{\underline{EV} \times S^*})$
است. همین‌طور دقت شود که تا به حال از 
$\mathbb{S}^*$
صحبتی نکرده بودیم و فقط 
$\mathbb{S}^+$
را معرفی کرده بودیم. 
$\mathbb{S}^*$
نیز برابر است با
$\mathbb{S}^+ \cup \{\epsilon\}$ 
(به لحاظ معنایی همان عملگر
$^*$
است که در زبان عبارات منظمهم هست، مشهور به ستاره‌ی کلینی).

تعریف استقرایی تابع 
$\mathcal{S}^r$
به شکل زیر است:
\begin{defn}
	تابع 
	$\mathcal{S}^r:\mathbb{R}\rightarrow \mathit{P}(\mathbb{\underline{EV}\times S}^*)$
	به صورت استقرایی روی ساختار عبارت منظم $\mathsf{R}$ به صورت زیر تعریف می‌شود:
$$\mathcal{S}^r\llbracket\varepsilon\rrbracket= \{ \langle \underline{\rho} , \epsilon \rangle | \underline{\rho} \in \underline{\mathbb{EV}}\}$$
[یعنی معنای عبارت منظم
$\varepsilon$
مجموعه‌ای شامل زوج مرتب‌هایی از محیط‌های اولیه‌ی مختلف در کنار رد پیشوندی تهی استفاده می‌کند.]
$$\mathcal{S}^r\llbracket\mathsf{L:B}\rrbracket = \{\langle\underline{\rho},\langle l , \rho \rangle \rangle | l \in \mathsf{L} \land \mathcal{B}\llbracket\mathsf{B}\rrbracket \underline{\rho},\rho \}$$
[این یعنی معنای عبارت 
$\mathcal{S}^r\llbracket\mathsf{L:B}\rrbracket$
زوج مرتب‌هایی هستند که عضو اول آن‌ها محیط‌های اولیه مختلف هستند( مانند مورد قبلی و البته در موارد آتی!) و عضو دوم آن‌ها ردهای پیشوندی تک‌عضوی 
$\langle l , \rho \rangle$
هستند که در آن‌ها برچسب 
$l$
باید در
$\mathsf{L}$
که مجموعه‌ای از برچسب‌هاست حضور داشته باشد و عبارت بولی 
$\mathsf{B}$
باید درباره‌ی محیط اولیه
$\underline{\rho}$
و محیط 
$\rho$
برقرار باشد. حتما متوجه این نکته شدید که 
$\mathcal{B}$
در اینجا به جای اینکه از نوع 
$\mathbb{EV} \rightarrow \mathbb{BOOL}$
باشد،همان‌طور که قبلا تعریف کردیم، از نوع
$\underline{\mathbb{EV}} \rightarrow \mathbb{EV} \rightarrow \mathbb{BOOL}$
است.( منظور از 
$\mathbb{BOOL}$
همان مجموعه‌ی 
$\{True,False\}$
است.) در اینجا 
$\mathcal{A}$
و 
$\mathcal{B}$
را در ادامه با نوع‌های متفاوت دوباره تعریف خواهیم کرد، که البته فرق اساسی‌ای با تعریف قبلی ندارد و صرفا گسترشی ساده از آن است.]
$$\mathcal{S}^r\llbracket\mathsf{R_1 R_2}\rrbracket= \mathcal{S}^r\llbracket\mathsf{R_1}\rrbracket \Join \mathcal{S}^r\llbracket\mathsf{R_2}\rrbracket$$
\begin{center}
	به‌طوری که در آن برای هر دو مجموعه‌ی 
	$\mathcal{S}$
	و
	$\mathcal{S'}$
	از رد‌های پیشوندی:
$$\mathcal{S \Join S'}=
\{
\langle \underline{\rho}, \pi \pi' \rangle |
\langle \underline{\rho},\pi \rangle \in \mathcal{S} \land
\langle \underline{\rho},\pi' \rangle \in \mathcal{S'}
\}
$$
\end{center}
[این یعنی اگر یک عبارت منظم داشته باشیم که از چسباندن 
$\mathsf{R_1}$
و 
$\mathsf{R_2}$
به هم ساخته شده باشد، آنگاه معنای این عبارت منظم با چسباندن ردهای پیشوندی موجود در مولفه‌ی دوم زوج مرتب‌هایی که اعضای مجموعه‌ی معنای این دو عبارت منظم هستند و گذاشتن این رد پیشوندی‌های حاصل از چسباندنْ در معنای عبارت منظم جدید تعریف می‌شود. همین‌طور که می‌بینید یک عملگر چسباندن برای دو مجموعه از این زوج‌های 
$\langle \underline{\rho} , \pi \rangle$
تعریف شده و در تعریف 
$\mathcal{S}^r \llbracket\mathsf{R_1 R_2}\rrbracket$
از آن کمک گرفته شده.\\
تا این تکه از تعریف معنای عبارت منظم که رسیده‌ایم، تا حدی به دستیابی به درکی شهودی از اینکه به چه نحوی قرار است عبارات منظم راهی برای توصیف ویژگی‌ در مورد برنامه‌ها باشد نزدیک‌تر شده‌ایم. همان‌طور که در مورد قبل دیدیم هر زوج 
$\mathsf{L:B}$
دقیقا به یک وضعیتْ داخل یک رد پیشوندی اشاره می‌کند. انگار که قرار است این زوج‌ها موازی با وضعیت‌ها در ردهای پیشوندی موجود در معنای یک برنامه جلو روند و منطبق باشند تا وارسی مدل انجام شود. درک این موضوع اولین قدم ماست در دیدن عصاره‌ی روش وارسی مدل در ادبیاتی که از اول این فصلْ عَلَم کرده‌ایم.]
$$\mathcal{S}^r \llbracket\mathsf{R_1\:|\:R_2}\rrbracket= 
\mathcal{S}^r \llbracket R_1\rrbracket \cup
\mathcal{S}^r \llbracket R_2\rrbracket$$
[این موردْ معنای اعمال عملگر انتخاب روی دو عبارت منظم را توصیف می‌کند. معنای اعمال این عملگر به‌سادگی به صورت اجتماع معنای هر دو عبارت منظم تعریف شده.]

$$\mathcal{S}^r \llbracket\mathsf{R}\rrbracket^0 = \mathcal{S}^r\llbracket\varepsilon\rrbracket$$
$$\mathcal{S}^r \llbracket\mathsf{R}\rrbracket^{n+1} = \mathcal{S}^r \llbracket\mathsf{R}\rrbracket^{n} \Join
\mathcal{S}^r \llbracket\mathsf{R}\rrbracket$$
[دو عبارت اخیر برای توصیف معنای عملگرهای $^*$ و $^+$ تعریف شده‌اند. عملگر $\Join$ و معنای 
$\mathcal{S}^r\llbracket\varepsilon\rrbracket$
را هم که قبلا تعریف کرده بودیم و $0$ و $n$ و $n+1$ هم اعداد طبیعی‌اند و $+$ لاجرم همان جمع اعداد طبیعی است.]
$$\mathcal{S}^r\llbracket\mathsf{R^*}\rrbracket =  \bigcup_{n \in \mathbb{N}}
\mathcal{S}^r \llbracket\mathsf{R}^n\rrbracket$$
$$\mathcal{S}^r\llbracket\mathsf{R^+}\rrbracket =  \bigcup_{n \in \mathbb{N}\setminus\{0\}}
\mathcal{S}^r \llbracket\mathsf{R}^n\rrbracket$$
[این دو عبارت هم تعریف معنای خود دو عملگر $^*$ و $^+$ هستند. منظور از $\mathbb{N}$ مجموعه‌ی اعداد طبیعی است. همان‌طور که قبل‌تر هم اشاره شد $^+$ را می‌توان در فرازبان با $^*$ تعریف کرد. اضافه می‌کنیم که خود $^*$ را هم در فرازبان می‌توان با عملگر انتخاب تعریف کرد و در اینجا می‌توان این نکته را هم دید.]

$$\mathcal{S}^r \llbracket(\mathsf{B})\rrbracket=\mathcal{S}^r \llbracket\mathsf{B}\rrbracket$$
[این تکه از تعریف هم صرفا بیان می‌کند که پرانتزها تاثیری در معنای عبارات منظم ندارند که کاملا قابل انتظار است چرا که وجود پرانتز قرار است در صرفا در خواص نحوی زبان اثر بگذارد.]
\end{defn}
تعریف معنای عبارات منظم در اینجا تمام می‌شود اما همان‌گونه که در لا‌به‌لای تعاریف گفتیم، احتیاج داریم که $\mathcal{A}$ و $\mathcal{B}$ را از نو تعریف کنیم:
\begin{defn}
	توابع 
	$\mathcal{A}:\mathbb{A}\rightarrow \mathbb{\underline{EV}} \rightarrow
	\mathbb{EV} \rightarrow \mathbb{V}$
	و 
	$\mathcal{B}:\mathbb{B}\rightarrow \mathbb{\underline{EV}} \rightarrow
	\mathbb{EV} \rightarrow \mathbb{BOOL}$
	به شکل استقرایی به ترتیب روی ساختارهای 
	$\mathsf{A}\in\mathbb{A}$
	و
	$\mathsf{B} \in \mathbb{B}$
	به شکل زیر تعریف می‌شوند:
	
	
$$\mathcal{A}\llbracket\mathsf{1}\rrbracket\underline{\rho},\rho=1$$
$$\mathcal{A}\llbracket\mathsf{\underline{\mathsf{x}}}\rrbracket\underline{\rho},\rho= \underline{\rho}(\mathsf{x})$$
$$\mathcal{A}\llbracket\mathsf{\mathsf{x}}\rrbracket\underline{\rho},\rho= \rho(\mathsf{x})$$
$$\mathcal{A}\llbracket\mathsf{A_1 - A_2}\rrbracket\underline{\rho},\rho= 
\mathcal{A}\llbracket\mathsf{A_1}\rrbracket\underline{\rho},\rho - \mathcal{A}\llbracket\mathsf{A_2}\rrbracket\underline{\rho},\rho$$
$$\mathcal{B}\llbracket\mathsf{A_1 < A_2}\rrbracket\underline{\rho},\rho=
	\mathcal{A}\llbracket\mathsf{A_1}\rrbracket\underline{\rho},\rho\: <\: \mathcal{A}\llbracket\mathsf{A_2}\rrbracket\underline{\rho},\rho$$
$$\mathcal{B}\llbracket\mathsf{B_1\:nand\:B_2}\rrbracket\underline{\rho},\rho=
\mathcal{B}\llbracket\mathsf{B_1}\rrbracket\underline{\rho},\rho \uparrow 
\mathcal{B}\llbracket\mathsf{B_2}\rrbracket\underline{\rho},\rho $$
\end{defn}
به‌راحتی قابل مشاهده است که تعاریف جدید تا حد خوبی به تعاریف قبلی شبیه هستند و فرق عمده صرفا وارد شدن $\underline{\rho}$ است.\\
تا اینجای کار بیشتر مفاهیمی که برای بیان صورت جدید مسئله‌ی وارسی مدل احتیاج داریم را بیان کرده‌ایم. 
\subsection{واریته‌های مختلف زبان عبارات منظم}
به عنوان قسمت آخر این بخشْ واریته‌های مختلفی از زبان عبارات منظم را بیان می‌کنیم. ، که هر کدام در واقع زیرمجموعه‌هایی از کل عبارات زبانی که توصیف کرده‌ایم را توصیف می‌کنند. بعضی از آن‌ها را در همین فصل برای هدف نهایی این فصل و بعضی دیگر را در فصل بعدی استفاده می‌کنیم.

اولین واریته‌ای که می‌خواهیم بیان کنیم، واریته‌ای است که در اعضای آن اصلا عبارت 
$\mathsf{L : B}$
حضور ندارد و کل عبارت‌های زبان از $\varepsilon$ ها تشکیل شده‌اند.
\begin{defn}
	(عبارت منظم تهی - $\mathbb{R_\varepsilon}$): 
	$$\mathsf{R} \:\:\:\in\:\:\: \mathbb{R}_\varepsilon$$
	$$\mathsf{R}\:\:\: ::= \:\:\: \varepsilon \: | \: \mathsf{R_1 R_2} \: | 
	\: \mathsf{R_1 + R_2} \: | \: \mathsf{R_1^*} \: | \: \mathsf{R_1^+} | (\mathsf{R_1})$$
\end{defn}


 با توجه به بخش قبل متوجه هستیم که معنای همه‌ی این عبارت‌ها برابر 
$\{\langle \underline{\rho} , \epsilon \rangle\}$
خواهد بود.

واریته‌ی بعدی عبارت منظم ناتهی است.
\begin{defn}
	(عبارت منظم ناتهی - $\mathbb{R}^+$):
	$$\mathsf{R} \:\:\:\in\:\:\: \mathbb{R}^+$$
	$$\mathsf{R}\:\:\: ::= \:\:\: \mathsf{L:B} \: |
	\: \mathsf{\varepsilon R_2} \: | \: \mathsf{R_1 \varepsilon} \: |
	\: \mathsf{R_1 R_2} \: | 
	\: \mathsf{R_1 + R_2} \: | \: \mathsf{R_1^+} | (\mathsf{R_1})$$
\end{defn}
دلیل وجود 
$\mathsf{\varepsilon R_2}$
و 
$\mathsf{R_1 \varepsilon}$
در تعریف این است که ممکن است معنای عبارتی با معنای عبارات عضو $\mathbb{R}_\varepsilon$ برابر نباشد( بعنی برابر ${\langle \underline{\rho} , \epsilon \rangle}$ نباشد)، اما در خود عبارتْ $\varepsilon$ حضور داشته باشد. با این تفاصیل می‌توان دید که دو مجموعه‌ی 
$\mathbb{R}_\varepsilon$
و
$\mathbb{R}^+$
یک افراز برای مجموعه‌ی $\mathbb{R}$ هستند، براساس اینکه معنای هر عبارت در $\mathbb{R}$ برابر ${\langle \underline{\rho} , \epsilon \rangle}$ هست یا خیر. بنابراین شاید به نظر برسد که تعریف یکی از آن‌ها به طور ساختاری کافی بود، اما ممکن است درجایی احتیاج داشته باشیم که ساختاری استقرایی روی هر یک از آن‌ها عَلَم کنیم یا اینکه در اثبات حکمی بخواهیم از استقرا روی یکی از این دو ساختار استفاده کنیم.

واریته‌ی آخر عبارات منظم ما نیز عبارات منظم بدون انتخاب است.
\begin{defn}
(عبارت منظم بدون انتخاب - $\mathbb{R}^\nmid$):
$$
\mathsf{R}\:\:\: \in \:\:\: \mathbb{R}^\nmid$$
$$
\mathsf{R}\:\:\: ::= \:\:\: \varepsilon \: | \: \mathsf{L:B} \: | \:
\mathsf{R_1 R_2} \: | \: \mathsf{R_1}^* \: | \: \mathsf{R_1}^+ \: | \:
(\mathsf{R_1})$$
\end{defn}

\section{صورت جدید مسئله‌ی وارسی مدل}
بالاخره به هدف نهایی این فصل رسیدیم. می‌خواهیم صورت جدیدی از مسئله‌ی وارسی مدل را بیان ‌کنیم.\\
پیش از ارائه‌ی تعریف وارسی مدل نیاز داریم تا عملگر بستار پیشوندی را برای یک مجموعه از ردهای پیشوندی معرفی کنیم.
\begin{defn}
	(بستار پیشوندی):
	اگر 
	$\Pi \in \mathit{P}(\mathbb{\underline{EV}\times S^+})$
	آنگاه بستار پیشوندی $\Pi$را به صورت زیر تعریف می‌کنیم:
	$$\mathsf{prefix}(\Pi)=
	\{\langle \underline{\rho},\pi\rangle | \pi \in \mathbb{S^+} \land \exists\
	\pi' \in \mathbb{S^*}: \langle \underline{\rho}, \pi \pi' \rangle \in \Pi \}$$
\end{defn}

برای درک بهتر مفهوم بستار پیشوندی به مثال زیر توجه شود.
\begin{exm}
	اگر 
	$\Pi = \{\langle\underline{\rho},\langle l_1 , \rho_1 \rangle 
	\langle l_2  \rho_2 \rangle\rangle  \langle l_3 , \rho_3 \rangle\rangle 
	,
	\langle\underline{\rho},\langle {l_1}' , {\rho_1}' \rangle  \langle {l_2}'  {\rho_2}' \rangle\rangle
	\}$ 
	باشد( $\Pi$ شامل دو عضو است) آنگاه:
	$$
	\mathsf{prefix}(\Pi)=
	\{
	\langle\underline{\rho},\langle l_1 , \rho_1 \rangle\rangle ,
	\langle\underline{\rho},\langle l_1 , \rho_1 \rangle  \langle l_2  \rho_2 \rangle\rangle,
	\langle\underline{\rho},\langle l_1 , \rho_1 \rangle  \langle l_2  \rho_2 \rangle  \langle l_3 , \rho_3 \rangle\rangle ,$$
	$$
	\langle\underline{\rho},\langle {l_1}' , {\rho_1}' \rangle\rangle,
	\langle\underline{\rho},\langle {l_1}' , {\rho_1}' \rangle  \langle {l_2}'  {\rho_2}' \rangle\rangle
	\}
	$$
	که شامل 5 عضو است.
\end{exm}
حال به ارائه‌ی صورت جدیدمان از روش وارسی مدل می‌رسیم که هدف اصلی این اصل بود و با این تعریف فصل تمام می‌شود.
\begin{defn}
(وارسی مدل):
	اگر 
	$\mathsf{P}\in\mathbb{P} , \mathsf{R} \in \mathbb{R}^+ , \underline{\rho} \in \underline{\mathbb{EV}}$
	آنگاه:
	$$\mathsf{P},\underline{\rho} \models \mathsf{R}
	 \Leftrightarrow
	(\{\underline{\rho}\}\times \mathcal{S}^* \llbracket\mathsf{P}\rrbracket) \subseteq 
	\mathsf{prefix} (\mathcal{S}^r \llbracket\mathsf{R} \bullet (?:\mathit{T})^*\rrbracket)
	$$
\end{defn}

این تعریف بیان می‌کند که برنامه‌ی 
$\mathsf{P}$
در صورتی که با محیط اولیه‌ی 
$\underline{\rho}$
اجرا شود، در صورتی خاصیتی که با عبارت منظم 
$\mathsf{R}$
بیان شده را دارد که معنای آن زیرمجموعه‌ی بستار پیشوندی معنای عبارت منظم
$\mathsf{R} \bullet (?:\mathit{T})^*$
باشد.
توجه شود که محیط اولیه‌ای که برای برنامه‌ی مورد بررسی متصور هستیم صرفا به این منظور قرار داده شده که معناشناسی برنامه را بتوانیم با معنای عبارات منظم قابل قیاس کنیم. دلیل حضور محیط اولیه در معنای عبارات منظم نیز در صورت سوم روش وارسی مدل یعنی فصل ۴ مشخص می‌شود و در این صورت از روش وارسی مدل و صورت بعدی آن چندان نقشی ندارد. 

در مورد نقش 
$ (?:\mathit{T})^*$
و
$ \mathsf{prefix} $
این به تصمیم مبدع این روش بوده که این دو در تعریف روش وارسی مدل حضور داشته باشند. حضور این دو طبعا باعث می‌شود به ازای یک عبارت منظم 
$\mathsf{R}$
نسبت به این حالت که صرفا معنی برنامه زیرمجموعه‌ی معنی 
$\mathsf{R}$
باشد، برنامه‌های بیشتری باشند که خاصیت بیان شده با 
$\mathsf{R}$
را ارضا کنند، چون در این صورت مجموعه‌ی سمت راستی در رابطه‌ی زیرمجموعه بودن بزرگتر می‌شود.

\section{در مورد توقف پذیری}

در این بخش نکته‌ای در مورد کار که به نظر نگارنده رسیده مطرح شده. اگر صحبت ما در اینجا درست باشد، این به این معنی خواهد بود که کل کاری که در حال توصیفش هستیم قابل پیاده سازی نیست!

بحث ما در اینجا در مورد توقف پذیری است. در \cite{calcul} در مورد توقف یک برنامه صحبتی به میان نیامده. یعنی حتی گفته نشده که در چه صورتی می‌توانیم بگوییم که یک برنامه متوقف شده است. یک تعریف  صوری معقول که خودمان می‌توانیم برای این معنا بیاوریم این است:

\begin{defn}
(توقف پذیری:) برنامه‌ی $\mathsf{P}$ را به همراه اجرای اولیه $\underline{\rho}$ توقف پذیر می‌گوییم اگر و تنها اگر وجود داشته باشد 
	$\pi \in \mathcal{S}^* \llbracket \mathsf{P} \rrbracket$ 
	که ($\rho$ محیط متناظر با محیط اولیه‌ی $\underline{\rho}$ است.):
	$$\pi = \langle at \llbracket \mathsf{P} \rrbracket , \rho \rangle \pi'$$
	و اینکه $\langle aft\llbracket \mathsf{P} \rrbracket , \rho' \rangle$ در $\pi$ حضور داشته باشد. این اتفاق را با 
	$\mathsf{P,\underline{\rho}\downarrow}$
	نشان می‌دهیم. همین تعریف را برای لیست دستورات $\mathsf{Sl}$ یا دستور $\mathsf{S}$ هم صرفا با جایگذاری این‌ها با برنامه‌ی $\mathsf{P}$ داریم.
\end{defn} 
در این تعریف توقف پذیری صرفا برای یک محیط اولیه تعریف شده.
در اینجا توقف پذیری به متناهی بودن ردهای پیشوندی موجود در برنامه ربط داده نشده. با توجه به معناشناسی‌ای که داریم، تعریف توقف پذیری به معنای وجود رد پیشوندی متناهی با محیط اولیه‌ی مورد بررسی در معنای برنامه که اصلا جور در نمی‌آید، چون معناشناسی ما خاصیت پیشوندی بودن را دارد و مطمئن هستیم در معنای هر برنامه‌ای حتما یک رد پیشوندی متناهی با محیط اولیه‌ی مورد بررسی وجود دارد.

اگر هم بخواهیم تعریف توقف پذیری را وجودنداشتن ردهای پیشوندی نامتناهی با محیط اولیه‌ی مورد بررسی در معنای برنامه در نظر بگیریم در ابتدا به نظر می‌آید که به تعریف قوی‌تری نسبت به آنچه ارائه دادیم رسیده‌ایم. ما در اینجا سعی داریم تعریفی را ارائه کنیم که برای حرف‌هایی که در \cite{calcul} زده شده تا حد امکان مشکل درست نکند، که اگر دیدیم با این وجود مشکل وجود دارد مطمئن باشیم که اشتباه در \cite{calcul} است و نه حرف ما. پس سعی از ارائه‌ی این تعریف که به نظر از تعریف ارائه شده با کار ناسازگارتر می‌آید اجتناب می‌کنیم( در ادامه به بیان ناسازگاری پراخته شده) اما در قضیه‌ی بعدی می‌بینیم که تعریفی که ارائه کردیم با همان که بگوییم در برنامه رد پیشوندی نامتناهی وجود ندارد معادل است.
\begin{thm}
	برای برنامه‌ی $\mathsf{P}$ و محیط اولیه‌ی $\underline{\rho}$ داریم $\mathsf{P} , \underline{\rho} \downarrow $ اگر و تنها اگر با فرض اینکه $\rho$ محیط متناظر با محیط اولیه‌ی $\underline{\rho}$ است و
	$$\forall \pi \in \mathbb{S^{+}} : 
	\langle at \llbracket \mathsf{P} \rrbracket , \rho \rangle \pi \in \mathcal{S^*} \llbracket \mathsf{P} \rrbracket \rightarrow
	\langle at \llbracket \mathsf{P} \rrbracket , \rho \rangle \pi \in \mathbb{R^+}$$
	 
\end{thm}
\begin{proof}
	$(\Rightarrow)$
	برای این قسمت باید ثابت کنیم که در معنای هر برنامه‌ای رد پیشوندی‌ای وجود دارد که با
	$\langle at\llbracket \mathsf{P} \rrbracket , \rho \rangle$
	شروع شده و به ازای یک محیط $\rho'$ به 
	$\langle aft\llbracket \mathsf{P} \rrbracket , \rho' \rangle$
	ختم شده. 
	در این اثبات از تعریف برچسب‌ها که در ضمیمه‌ی \cite{calcul} آمده استفاده شده.
	داریم 
	$\mathsf{P=Sl}$
	و 
	$aft \llbracket \mathsf{P} \rrbracket = aft \llbracket \mathsf{Sl} \rrbracket $
	
	حکم را با استقرا روی ساختار $\mathsf{Sl}$ ثابت می‌کنیم. 
	$$\blacktriangleright \mathsf{Sl = \backepsilon}:$$
	داریم:
	$$\mathcal{S^*} \llbracket \backepsilon \rrbracket = \{\langle at \llbracket \backepsilon \rrbracket , \dot{\rho} \rangle | \dot{\rho} \in \mathbb{EV}\}$$
	و طبق تعریف برچسب‌ها داریم:
	$$at \llbracket \backepsilon \rrbracket = aft \llbracket \backepsilon \rrbracket$$
	پس حکم برقرار است.
	$$\blacktriangleright \mathsf{Sl =Sl'\;S}:$$
	اینکه در معنای $\mathsf{Sl}$ دنباله‌ای شامل
	 $\langle aft \llbracket \mathsf{Sl} \rrbracket , \rho '\rangle$ وجود داشته باشد، به با توجه به تعاریفی که داریم به این وابسته است که در معنای $\mathsf{S}$ دنباله‌ای شامل $\langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle$ وجود داشته باشد. برای اینکه این را ثابت کنیم هم باید همین حکم را روی ساختار $\mathsf{S}$ ثابت کنیم که در واقع بخش اصلی اثبات این سمت قضیه است. 
	$$\blacktriangleright\blacktriangleright \mathsf{S\;=\; x\doteq A;}:$$
	در این حالت با توجه به تعریف معنای $\mathsf{S}$ که قبل‌تر ارائه شد، دنباله‌ی 
	$$\langle at \llbracket \mathsf{S} \rrbracket ,\rho \rangle \langle aft\llbracket\mathsf{S}\rrbracket , \rho[\mathsf{x}\leftarrow \mathcal{A}\llbracket\mathsf{A}\rrbracket\rho] \rangle $$
	در معنای دستور به ازای هر $\rho$ وجود دارد که خب در هر صورت این شامل محیط متناظر با $\underline{\rho}$ هم می‌شود .
	$$\blacktriangleright\blacktriangleright \mathsf{S=\; ; \;\;}:$$	 
با توجه به معنای این دستوردنباله‌ی زیر در معنای این دستور وجود دارد.
$$\langle at \llbracket \mathsf{S} \rrbracket ,\rho \rangle \langle aft\llbracket\mathsf{S}\rrbracket , \rho \rangle $$

$$\blacktriangleright\blacktriangleright \mathsf{S=\; if\;(B)\;S_t}:$$
	در صورتی که 
	$\mathcal{B}\llbracket\mathsf{B}\rrbracket\rho=\mathit{T}$
	دنباله‌ی 
	$$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle
	\langle at \llbracket \mathsf{S_t} \rrbracket , \rho \rangle \pi$$
	در مجموعه‌ی معنای این دستور حضور دارد در حالیکه 
	$\langle at \llbracket \mathsf{S_t} \rrbracket , \rho \rangle \pi$
	داخل معنای $\mathsf{S_t}$ است و طبق فرض استقرا می‌دانیم که برچسب آخرین موقعیت $\pi$ برابر است با $aft \llbracket \mathsf{S_t} \rrbracket$ که طبق تعاریف مربوط به برچسب‌ها 
	$aft \llbracket \mathsf{S_t} \rrbracket=aft \llbracket \mathsf{S} \rrbracket$.
	در صورتی که معنای عبارت بولی غلط باشد هم دنباله‌ی زیر در معنای دستور طبق تعریف موجود است.
	$$\langle at \llbracket \mathsf{S} \rrbracket ,\rho \rangle \langle aft\llbracket\mathsf{S}\rrbracket , \rho \rangle $$
	
$$\blacktriangleright\blacktriangleright \mathsf{S=\; if\;(B)\;S_t\;else\;S_f}:$$
مانند حالت قبل است منتها با این تفاوت که در صورتی که معنای عبارت بولی غلط باشد دنباله‌ی زیر در معنای دستور حضور دارد:
	$$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle
\langle at \llbracket \mathsf{S_f} \rrbracket , \rho \rangle \pi$$
و تساوی 
$aft \llbracket \mathsf{S_t} \rrbracket=aft \llbracket \mathsf{S} \rrbracket=aft \llbracket \mathsf{S_f} \rrbracket$
هم طبق تعریف برچسب‌ها برقرار است.

$$\blacktriangleright\blacktriangleright \mathsf{S=\; while\;(B)\;S_t}:$$
در اثبات این سمت قضیه این حالت پیچیده ترین حالت است و در واقع تنها حالتی است که در اثبات آن به فرض قضیه احتیاج داریم! همان طور که پیشتر گفتیم معنای حلقه با استفاده از یک تابع تعریف می‌شود. معنای حلقه کوچکترین نقطه ثابت این تابع است، در حالیکه انگار این تابع وقتی روی یک مجموعه از ردهای پیشوندی اعمال شود، تاثیرات یک بار اجرای دستورات درون حلقه را روی ردهای پیشوندی درون مجموعه اعمال می‌کند.

طبق تعریف $\mathcal{F}$ مطمئن هستیم که رد پیشوندی‌ای که با محیط $\underline{\rho}$ شروع شود در مجموعه‌ی معنای $\mathsf{S}$ وجود دارد، چونکه به ازای هر محیط $\dot{\rho}$(نقطه به این خاطر است که با $\rho$ خاص موجود در فرض اشتباه گرفته نشود) حالت 
$\langle at \llbracket \mathsf{S} \rrbracket, \dot{\rho} \rangle$
 در هر اعمال تابع $\mathcal{F}$ روی هر مجموعه‌ی دلخواه وجود دارد. وقتی معنای $\mathsf{S}$ را به عنوان کوچک‌ترین نقطه ثابت $\mathcal{F}$ در نظر گرفته‌ایم پس مطمئن هستیم که آن مجموعه‌ای که کوچکترین نقطه ثابت است شامل رد پیشوندی 
 $\langle at \llbracket \mathsf{S} \rrbracket, \rho \rangle$
 است. این رد پیشوندی با اجرای $\mathcal{F}$ تحت تاثیر قرار می‌گیرد. اگر معنای $\mathsf{B}$ در یکی از اعمال های $\mathcal{F}$ غلط باشد، رد پیشوندی
$ \langle at \llbracket \mathsf{S} \rrbracket, \rho \rangle \pi \langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle$ 
در معنای برنامه قرار خواهد گرفت و می‌توانیم بگوییم اجرای دستور با این محیط اولیه توقف پذیر است. می‌دانیم که طبق تعریف تابع به انتهای این رد پیشوندی چیزی اضافه نمی‌شود. از طرف دیگر هم با این محیط اولیه، با توجه به تعریف رد پیشوندی دیگری وجود ندارد که طولانی‌تر از رد پیشوندی مورد اشاره باشد. 

در حالت دیگر اگر فرض کنیم هیچ گاه به حالتی نمی‌رسیم که در آن معنای $\mathsf{B}$ غلط باشد هم با فرض مسئله به تناقض می‌خوریم، چون در آن صورت تابع $\mathcal{F}$ مدام به طول دنباله‌‌هایی که با محیط $\rho$ شروع می‌شوند می‌افزاید و این یک دنباله‌ی نامتناهی را خواهد ساخت. در صورتی که معنای $\mathsf{B}$ هیچ گاه صحیح نباشد، حداقل حالت 
$\langle at \llbracket \mathsf{S_t} \rrbracket , \rho'' \rangle$
به ته دنباله‌های پیشین اضافه خواهد شد و از این جهت مطمئن هستیم که دنباله‌ی نامتناهی گفته شده در معنای دستور حضور خواهد داشت. 

پس با این تفاصیل، این مورد هم ثابت می‌شود.

\break$$\blacktriangleright\blacktriangleright \mathsf{S=\; break;}:$$
در تعریف تابع $aft$ روی برچسب‌ها در \cite{calcul} این تعریف برای این دستور مشخص نیست! در \cite{cousotbook} که در مورد برچسب‌ها بحث شده، نویسنده‌ی \cite{calcul} گفته که در مورد آن بخش از تعاریف توابع مربوط به برچسب‌ها که تعریف نشده‌اند برداشت آزاد است و ما در اینجا سعی داریم معقول ترین برداشتی که نسبت به درکمان از این کار می‌توانیم داشته باشیم را بیان کنیم. مهم‌ترین چیزی که در مورد برچسب‌ها در مورد این دستور قرار است برقرار باشد این است که اگر این دستور بخشی از $\mathsf{S_t}$ در حلقه‌ی زیر باشد
$$\mathsf{S'=\; while\; (B)\; S_t}$$
در این صورت 
$aft \llbracket \mathsf{S'} \rrbracket = brk-to \llbracket \mathsf{S_t} \rrbracket $
را طبق تعریف داریم. انتظار می‌رود که\break 
$aft \llbracket \mathsf{break;} \rrbracket = aft \llbracket \mathsf{S'} \rrbracket$ 
باشد. اینکه دستورات برنامه پس از اجرای $\mathsf{break;}$ از خارج(یا به عبارت بهتر بعد از) حقله‌ی $\mathsf{S'}$ پی گرفته شود انتظار معقولی است از سیستمی که در حال توصیف رد اجرای برنامه‌های کامپیوتری است. البته در نظر گرفته شود که فرض کرده‌ایم که $\mathsf{S'}$ داخلی ترین حلقه‌ای است که $\mathsf{break;}$ درون آن جای دارد.

 از پس این فرض‌های ما 
$aft \llbracket \mathsf{break;} \rrbracket = break-to \llbracket \mathsf{S_t} \rrbracket$ 
نتیجه می‌شود و طبق تعریف معنای دستورات 
$\mathsf{break;}$
رد پیشوندی زیر در معنای این دستور وجود دارد
$$\langle at \llbracket \mathsf{break;} \rrbracket , \rho \rangle
\langle aft \llbracket \mathsf{break;} \rrbracket , \rho \rangle$$
 که نشانه‌ی توقف است.
 

$$\blacktriangleright\blacktriangleright \mathsf{S=\; \{ Sl'' \}}:$$
	در این صورت توقف پذیری $\mathsf{Sl''}$ را از فرض استقرای استقرایی که روی لیست دستورات زده بودیم داریم پس $\mathsf{\{Sl''\}}$ هم توقف پذیر است.
	
	
در اینجا اثبات این طرف قضیه به پایان می‌رسد.

($\Leftarrow$)
دوباره باید روی ساختار برنامه‌ها استقرا بزنیم و دوباره چون هر برنامه مساوی با یک لیست از دستورات است استقرا را ابتدا روی ساختار لیست دستورات و در دل آن روی ساختار دستورات استقرا می‌زنیم.

در این اثبات به غیر از یک حالت ساختار دستور، که دستور حلقه است، هر آنچه در مورد اثبات طرف راست قضیه گفتیم، به ما حکم را بدون نیاز به فرض نشان می‌دهد. بنابراین فقط در مورد اثبات همین یک مورد بحث می‌کنیم. 
$$\blacktriangleright\blacktriangleright \mathsf{S=\; while\; (B)\; S_t}:$$

اگر فرض کنیم این دستور به ازای محیط $\rho$ در حالت اول متوقف شده، در واقع فرض کرده‌ایم در معنای این دستور رد پیشوندی 
$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle \pi \langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle \pi'$ 
وجود دارد.
باید ثابت کنیم به ازای $\pi'$ دلخواه اگر رد پیشوندی
$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle \pi \langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle \pi'$ 
داخل 
$\mathcal{S^*}\llbracket \mathsf{S} \rrbracket$
وجود داشته باشد آنگاه
$\pi'=\epsilon$
برقرار است.

اگر برچسب
$aft \llbracket \mathsf{S} \rrbracket$
در یک حالت در رد پیشوندی‌ای که گفتیم حضور داشته باشد، یعنی در یک دور اجرای حلقه عبارت بولی معنی غلط می‌داده که حالتی شامل این برچسب به یک رد پیشوندی چسبانده شده و این رد پیشوندی ساخته شده. از طرفی دیگر هم می‌دانیم که وقتی عبارت بولی حاضر در ساختار حلقه غلط شده، دیگر به ردهای پیشوندی داخل معنای حلقه چیزی اضافه نمی‌شود. بنابراین سناریو‌ای جز $\pi'=\epsilon$ باقی نمی‌ماند. 
\end{proof}

پس با توجه به آنچه گفتیم می‌توانیم با خیال راحت توقف پذیری یک برنامه با یک محیط اولیه را معادل متناهی بودن همه‌ی ردهای پیشوندی‌ای بدانیم که با محیط متناظر با آن محیط اولیه شروع شده‌اند.
اگر در صورت ارائه شده از وارسی مدل عبارت منظم $\mathsf{R}$ را با عبارت منظم $\varepsilon$ جایگزین کنیم داریم:
$$\mathsf{P},\underline{\rho} \models \mathsf{R}
\Leftrightarrow
(\{\underline{\rho}\}\times \mathcal{S}^* \llbracket \mathsf{P}\rrbracket) \subseteq 
\mathsf{prefix} (\mathcal{S}^r \llbracket \varepsilon \bullet (?:\mathit{T})^*\rrbracket)
=\mathsf{prefix} (\mathcal{S}^r \llbracket (?:\mathit{T})^*\rrbracket)$$
طبق تعریف معنای عبارات منظم، هر رد پیشوندی متناهی‌ای داخل مجموعه‌ی سمت راستی رابطه‌ی زیرمجموعه بودن قرار می‌گیرد. این یعنی اگر الگوریتمی برای بررسی 
$\mathsf{P} , \underline{\rho} \models \mathsf{R} $
داشته باشیم، این الگوریتم می‌تواند تشخیص دهد آیا برنامه‌ی $\mathsf{P}$ با محیط اولیه‌ی $\underline{\rho}$ متوقف می‌شود یا خیر! این یعنی الگوریتمی برای مسئله‌ی توقف پذیری، مسئله‌ای که تصمیم ناپذیر است! بنابراین چنین الگوریتمی نباید وجود داشته باشد که یعنی پیاده سازی‌ای برای شیوه‌ای که در حال بیانش هستیم وجود ندارد! ادامه‌ی کار روی همین تعریف پیش می‌رود و دو صورت دیگر هم که قرار است ساختارمندتر باشند در نهایت با این صورت معادل‌اند، هرچند که پس از رسیدن به بیان دو صورت دیگر خواهیم دید که همین صحبت‌هایی که در مورد این صورت می‌کنیم در مورد صورت‌های دیگر هم بدون در نظر گرفتن معادل بودن این ۳ صورت برقرار است.




\section{در مورد قدرت بیان عبارات منظم}
در این بخش می‌‌خواهیم کمی در مورد قدرت بیان عبارات منظمی که در این فصل آورده‌ایم در مقایسه با منطق \lr{LTL} که در فصل اول آمده صحبت کنیم. همان طور که پیش‌تر گفتیم، یکی از دلایلی که کوزو برای استفاده از عبارات منظم دارد این است که عبارات منظم قادر به بیان خواصی هستند که منطق زمانی از بیان آن‌ها عاجز است. او \cite{regisbetter} را به عنوان مرجع صحبتش در نظر گرفته و در \cite{calcul} در این مورد با جزئیات بحثی نشده. 
در این بخش می‌خواهیم این بحث را بیشتر باز کنیم. 

سوال اصلی ما در این بخش این است که آیا یکی از این دو موجود، اکیدا از دیگری در بیان قوی‌تر هست یا خیر. به این معنی که آیا می‌شود هر چیزی که با یکی از این‌ها قابل بیان است را با دیگری هم بیان کرد یا خیر. البته که \cite{regisbetter} حداقل در مورد یک طرف این بحث حرف زده و ما هم در اینجا از آن محتوا هم کمک خواهیم گرفت و این بحث را میان دو زبانی که تا به حال در بحث داشتیم مطرح می‌کنیم، یعنی منطق زمانی خطی و عبارات منظمی که در همین فصل معرفی شدند.

\subsection{نزدیک کردن صورت دو زبان}

پیش از اینکه بخواهیم مقایسه‌ای ترتیب دهیم، ابتدا باید زبانی را که در فصل اول از \lr{LTL} آورده‌ایم، با عبارات منظمی که در این فصل آورده‌ایم با هم قابل مقایسه کنیم. به هر حال زبانی که در فصل اول آمده یک منطق گزاره‌ای است اما در عبارات منظمی که در این فصل آورده‌ایم اتم‌ها( یا به عبارت دیگر لیترال‌ها) به موجودات ساختارمندتری تبدیل شده‌اند که همان زوج مرتب‌های $\mathsf{L:B}$ هستند. در اینجا معناشناسی ما هم نسبت به تغییری که در اتم‌ها داده‌ایم فرق کرده. بنابراین اولین تلاشی که می‌کنیم این است که منطقی که در فصل اول آورده‌ایم را به شکلی که حس می‌کنیم قابل مقایسه با عبارات منظم باشد تغییر دهیم. در واقع تغییری که در زبان می‌دهیم همان تغییر اتم‌هاست. در ادامه معناشناسی منطق \lr{LTL} را هم به کمک ردهای پیشوندی، مثل عبارات منظم، بیان می‌کنیم. نام این منطق جدید را "\lr{LTL}- گسترش یافته" گذاشته‌ایم. 

\begin{defn}
	(زبان \lr{LTL}- گسترش‌ یافته): با فرض اینکه 
	$\mathsf{L} \subseteq \mathbb{L}$
	و 
	$\mathsf{B} \in \mathbb{B}$
	زبان جدید  \lr{LTL} به شکل زیر است:
	
	$$
	\phi \in \Phi \Leftrightarrow
	\phi ::= \mathsf{L:B} | \phi_1 \lor \phi_2 |
	\neg \phi_1 |
	\bigcirc \phi_1 |
	\phi_1 \mathcal{U}\phi_2 
	$$	
	مجموعه‌ی همه‌ی فرمول‌ها در این زبان را با $\mathfrak{L}_e$ نمایش می‌دهیم.
\end{defn} 

\begin{defn}
	(معناشناسی \lr{LTL}- گسترش یافته): تابع 
	$\mathcal{S}^t : \Phi \rightarrow \mathit{P}(\mathbb{\underline{EV}}\times\mathfrak{S}^{+})$
	با ضابطه‌ی زیر، معناشناسی زبان \lr{LTL} است.
	
	$$\blacktriangleleft \mathcal{S}^t \llbracket \mathsf{L:B} \rrbracket = 
	\{ \langle \underline{\rho} , \langle l , \rho \rangle\rangle | l \in \mathsf{L} \; , \; \mathcal{B}\llbracket \mathsf{B} \rrbracket \underline{\rho}, \rho=\mathit{T} \; , \; \underline{\rho}\in \mathbb{\underline{EV}}\}$$
	$$\blacktriangleleft \mathcal{S}^t \llbracket \mathsf{\phi_1 \lor \phi_2} \rrbracket =
	\mathcal{S}^t \llbracket \phi_1 \rrbracket \cup \mathcal{S}^t \llbracket \phi_2 \rrbracket
	$$
	$$\blacktriangleleft \mathcal{S}^t \llbracket \mathsf{\neg \phi_1} \rrbracket =
	\mathfrak{S}^{+ \infty} \setminus \mathcal{S}^t \llbracket \phi_1 \rrbracket
	$$
	$$\blacktriangleleft \mathcal{S}^t \llbracket \mathsf{\bigcirc \phi_1} \rrbracket =
	\{ \langle \underline{\rho} , \langle l , \rho \rangle \pi \rangle | \langle \underline{\rho},\pi \rangle \in \mathcal{S}^t \llbracket \phi_1 \rrbracket \; , \; l \in \mathbb{L} \; , \; \rho \in \mathbb{EV} \; , \;\underline{\rho},\in \mathbb{\underline{EV}} \}
	$$
	$$\blacktriangleleft \mathcal{S}^t \llbracket \mathsf{\phi_1 \mathcal{U} \phi_2} \rrbracket =
	\{ \langle \underline{\rho} , \pi \rangle | \exists \pi': \forall \pi'': \pi \pi'' \subsetneq \pi' \rightarrow (\langle \underline{\rho}, \pi \pi'' \rangle \in \mathcal{S}^t \llbracket \phi_1 \rrbracket,\langle \underline{\rho}, \pi' \rangle \in \mathcal{S}^t \llbracket \phi_2 \rrbracket) \; , \;\underline{\rho} \in \mathbb{\underline{EV}} \}
	$$
	
	
\end{defn}

حال می‌خواهیم ثابت کنیم که معناشناسی‌ای که ارائه کرده‌ایم، معنای منطق \lr{LTL} را حفظ کرده. 
برای این کار ابتدا یک معناشناسی جدید را برای زبان \lr{LTL} قدیمی ارائه می‌دهیم و ثابت می‌کنیم که معادل با معناشناسی قبلی است. 

\begin{defn}
	(مدل \lr{LTL}- جدید): به هر تابع از $\Pi$ یعنی مجموعه‌ی اتم‌ها به $\mathit{P(\mathbb{N})}$ یعنی مجموعه‌ی همه‌ی زیرمجوعه‌های مجموعه‌ی کل اعداد طبیعی می‌گوییم مدل جدید.
	$$M_n:\Pi \rightarrow \mathit{P(\mathbb{N})}$$
	مجموعه‌ی همه‌ی مدل‌های جدید را با 
	$\mathbb{M}_n$
	نشان می‌دهیم.
\end{defn}

\begin{defn}
	(معناشناسی \lr{LTL}- جدید): تابع 
	$\bar{ }:\mathbb{M}_n \rightarrow \Phi \rightarrow \mathit{P}(\mathbb{N})$
	( به علامت گذاری دقت کنید! نام گذاری تابع به شکل سنتی و با یک حرف خاص نیست و صرفا علامت بار را گذاشته‌ایم. به ازای مدل $M_n$ در ورودی، تابع 
	$\bar{M_n}: \Phi \rightarrow \mathit{P}(\mathbb{N})$
	 را داریم.)
	 به ازای مدل $M_n$ روی فرمول‌های زبان \lr{LTL} به شکل زیر تعریف می‌شود:
	 $$\blacktriangleleft \bar{M_n}(\pi)= M_n(\pi)$$
	 $$\blacktriangleleft \bar{M_n}(\phi \lor \psi)= \bar{M_n}(\phi) \cup \bar{M_n}(\psi)$$
	 $$\blacktriangleleft \bar{M_n}(\neg \phi)= \mathbb{N} \setminus \bar{M_n}(\phi)$$
	 $$\blacktriangleleft \bar{M_n}(\bigcirc\phi)= \{n+1|n\in \bar{M_n}(\phi) \}$$
	 $$\blacktriangleleft \bar{M_n}(\phi \mathcal{U} \psi)= \{n|\exists k : \forall j: n \leq j \lneq k \rightarrow j \in \bar{M_n}(\phi) , k \in \bar{M_n}(\psi) \}$$
	 و به کمک این تابع تعریف می‌کنیم:
	 $$M_n,i \models_n \phi \; \mathit{iff}\; i \in \bar{M_n}(\phi)$$
\end{defn}

مدل‌های جدیدی که تعریف کرده‌ایم همان اطلاعاتی را که مدل‌های قدیمی به ما می‌دادند، با آرایش دیگری در خود نگه می‌دارند. برای اینکه بتوانیم از هر دو شیوه‌ی بیان یک مدل استفاده کنیم یک تابع میان آن‌ها تعریف می‌کنیم.

\begin{defn}
	(تابع مبدل): تابع
	$\mathfrak{T}:\mathbb{M_n} \rightarrow \mathbb{M}$
	را به نام تابع مبدل به شکل زیر تعریف می‌کنیم:
	$$\mathfrak{T}(M_n)(i)=\{ \pi | i \in M_n(\pi) \}$$
\end{defn} 

این تابع یک تناظر یک به یک و پوشا بین مدل‌های قدیم و جدید است. 
\begin{thm}
	تابع $\mathfrak{T}$ یک به یک و پوشا است.
\end{thm}
\begin{proof}
	پیش از هر چیز ذکر این نکته ضروری است که اصلا چرا $\mathfrak{T}$ یک تابع است. این از این می‌آید که با توجه به اینکه در تعریف این تابع صرفا از عملگر اجتماع و محمول عضویت استفاده شده و می‌دانیم این دو خوش تعریف هستند، پس متوجه می‌شویم که $\mathfrak{T}$ یک تابع است.
	
	اثبات یک به یک بودن:
	فرض می‌‌کنیم که به ازای دو مدل $M_n$ و $M_n'$ که ممکن است متفاوت باشند، داریم $\mathfrak{T}(M_n)=\mathfrak{T}(M_n')$. داریم:
	$$\Rightarrow \forall i \in \mathbb{N}: \mathfrak{T}(M_n)(i)=\mathfrak{T}(M_n')(i)
	\Rightarrow \forall i \in \mathbb{N}: \forall \pi \in \Pi: \pi \in \mathfrak{T}(M_n)(i) \leftrightarrow \pi \in \mathfrak{T}(M_n')(i)$$
	$$\Rightarrow \forall i \in \mathbb{N}: \forall \pi \in \Pi: i \in M_n(\pi) \leftrightarrow \pi \in M_n'(\pi) \iff M_n = M_n'$$
	پس این دو مدل الزاما برابرند و این یعنی این تابع یک به یک است.
	
	اثبات پوشا بودن: فرض می‌کنیم $M \in \mathbb{M}$ و ثابت می‌کنیم برای مدل \break
	 $M_n (\pi)=\{i | \pi \in M(i)\}$ 
	داریم $\mathfrak{T}(M_n)=M$.
	$$\forall j \in \mathbb{N}: \mathfrak{T}(M_n)(j)=\{\pi | j \in M_n(\pi)\}
	=\{\pi | j \in \{i | \pi \in M(i)\}\}= \{\pi | \pi \in M(j)\}=M(j)$$
	$$\Rightarrow \mathfrak{T}(M_n)=M$$
	پس تابع مبدل پوشا نیز هست.
\end{proof}

بنابراین می‌توانیم قضیه‌ی زیر را بیان کنیم.
\begin{thm}
	معناشناسی جدید و قدیم با یکدیگر معادل‌اند یا به عبارت دیگر 
	برای هر مدل $M_n \in \mathbb{M_n}$ داریم:
	$$\forall \phi \in \Phi, i\in\mathbb{N}:\bar{M_n},i \models_n \phi \leftrightarrow \mathfrak{T}(M_n) , i \models \phi $$
\end{thm}

\begin{proof}
	روی ساختار $\phi$ استقرا می‌زنیم:
	$$\blacktriangleright \phi=\pi:$$
	$$M_n , i \models_n \pi \iff i \in \bar{M_n} (\pi) \iff i \in M_n(\pi)$$
	$$\iff \pi \in \mathfrak{T}(M_n)(i) \iff \mathfrak{T}(M_n),i \models \pi $$
	
	$$\blacktriangleright \phi=\phi \lor \psi:$$
	$$M_n , i \models_n \phi \lor \psi  \iff i\in \bar{M_n}(\phi \lor \psi) = \bar{M_n} (\phi) \cup \bar{M_n}(\psi)$$
	در اینجا بدون کاستن از کلیت می‌توانیم فرض کنیم $i \in \bar{M_n}$. با فرض دیگر هم اثبات به همین شکل است.
	$$i \in \bar{M_n}(\phi) \iff M_n,i\models_n \phi \mathfrak{T}(M_n),i \models \phi \Rightarrow \mathfrak{T}(M_n),i\models \phi \lor \psi$$
	عکس این اثبات را هم برای عکس این طرف قضیه که ثابت کردیم در همین اثبات می‌شود دید. آخرین نتیجه‌ای که گرفتیم می‌تواند بدون کاستن از کلیت برعکس گرفته شود و در واقع برای هر دو زیر فرمول به‌طور جداگانه ثابت شود.
	$$\blacktriangleright \phi=\neg \phi:$$
	$$M_n,i \models_n \iff i \in \bar{M_n}(\neg \phi) \iff i \notin \bar{M_n}(\phi)$$
	$$\iff M_n ,i \nvDash_n \phi \iff \mathfrak{T}(M_n),i \nvDash \phi \iff \mathfrak{T} (M_n) ,i \models \neg \phi$$ 

	$$\blacktriangleright \phi=\phi \mathcal{U} \psi:$$
	$$M_n,i \models_n \pi \mathcal{U} \psi \iff i \in \bar{M_n}(\phi \mathcal{U}\psi)$$
	$$\iff \exists k: \forall j: i \leq j < k \rightarrow j \in \bar{M_n}(\phi) , k \in \bar{M_n}(\psi)$$
	$$\iff \exists k: \forall j: i \leq j < k \rightarrow M_n,j \models_n\phi ,  M_n,k\models_n \psi$$
	$$\iff \exists k: \forall j: i \leq j < k \rightarrow \mathfrak{T}(M_n),j \models\phi ,  \mathfrak{T}(M_n),k\models \psi$$
	$$\iff \mathfrak{T}(M_n),i \models \phi \mathcal{U} \psi$$

\end{proof}

پس تا اینجای کار ثابت کردیم که معناشناسی جدیدی که برای \lr{LTL} ارائه کرده‌ایم با معناشناسی قدیمی‌اش معادل است. 

می‌توان دید که معناشناسی جدید به معناشناسی‌ 
$\mathcal{S}^t$
 بسیار شبیه است و انگار که با جایگذاری زوج‌های 
 $\mathsf{L:B}$ به جای اتم‌ها و ردهای پیشوندی متناهی به جای مدل‌هایی که داشتیم، می‌توان 
 از 
$\bar{M_n}$
به 
$\mathcal{S}^t$
رسید. تا اینجای کار تا حدی ارتباط $\mathcal{S}^t$ به $\bar{M}_n$ را نشان داده‌ایم، هرچند که برای اطمینان بیشتر می‌بایست به مشخص‌تر کردن این ارتباط ادامه داد. کاری که انتظار می‌رود انجام شود این است که یک دوسویی مدل‌ها را از \lr{LTL}-جدید به \lr{LTL}-گسترش یافته مرتبط کند و دوسویی دیگر هم مدل‌ها را در دو منطق به هم مرتبط کند.

در مورد اتم‌ها می‌توانیم این را بگوییم که چون در \lr{LTL}- جدید( مثل \lr{LTL} که در فصل اول مطرح شده)، اتم‌ها را شمارای نامتناهی در نظر گرفته‌ایم و از طرفی در \lr{LTL}- گسترش یافته هم عبارات بولی شمارای نامتناهی هستند و مجموعه‌ی برچسب‌ها هم قاعدتا باید متناهی در نظر گرفته شود(‌یا اگر می‌خواهیم مجموعه‌ی برچسب‌ها را برای همه‌ی برنامه‌ها تعریف کنیم و آن‌ها را نامتناهی در نظر بگیریم، شاید دلیل معقولی برای ناشمارا در نظرگرفتن آن‌ها وجود نداشته باشد. در \cite{calcul} نویسنده در مورد مجموعه‌ی برچسب‌ها هم به صراحت صحبت نکرده)، در این صورت مجموعه‌ی اتم‌ها شمارای نامتناهی خواهد بود. همین حقیقت به ما یک دو سویی بین اتم‌های دو زبان می‌دهد. نام این دوسویی را 
$\mathfrak{T}_a$
می‌گذاریم.

در مورد مدل‌ها نیز 

\subsection{مقایسه}

حال به بررسی این می‌پردازیم که کدام زبان قدرت بیان بیشتری دارد.

\begin{thm}
	هر فرمولی که به زبان \lr{LTL}-گسترش یافته قابل بیان باشد، به زبان عبارات منظم هم قابل بیان است. به عبارت دیگر 
	$$\forall \phi \in \mathfrak{L}_e: \exists \mathsf{R} \in \mathbb{R} : \mathcal{S}^t \llbracket \phi \rrbracket = \mathcal{S}^r \llbracket \mathsf{R} \rrbracket$$
\end{thm}
\begin{proof}
	با استقرا روی ساختار فرمول‌ها می توانیم این قضیه را ثابت کنیم.
	$$\blacktriangleright\phi=\mathsf{L:B}:$$
	$\mathsf{L:B}$ عضو هر دو زبان هست و در هر دو معنای یکسانی دارد.
	$$\blacktriangleright\phi= \phi_1 \lor \phi_2:$$
	طبق فرض استقرا وجود دارند 
	$\mathsf{R_1,R_2} \in \mathbb{R}$
	که
	$\mathcal{S}^r \llbracket \mathsf{R_1} \rrbracket = \mathcal{S}^t \llbracket \phi_1 \rrbracket$ 
	و
	$\mathcal{S}^r \llbracket \mathsf{R_2} \rrbracket = \mathcal{S}^t \llbracket \phi_2 \rrbracket$
	و داریم:
	$$\mathcal{S}^r \llbracket \mathsf{ R_1 + R_2} \rrbracket =  \mathcal{S}^r \llbracket \mathsf{R_1} \rrbracket \cup \mathcal{S}^r \llbracket \mathsf{R_2} \rrbracket = \mathcal{S}^t \llbracket \phi_1 \rrbracket \cup \mathcal{S}^t \llbracket \phi_1 \rrbracket = \mathcal{S}^t \llbracket \phi_1 \lor \phi_2 \rrbracket$$
	$$\blacktriangleright\phi= \neg \phi_1:$$
	طبق فرض استقرا یک عبارت منظم $\mathsf{R_1}$ وجود دارد که 
	$\mathcal{S}^r \llbracket \mathsf{R_1} \rrbracket = \mathcal{S}^t \llbracket \phi_1 \rrbracket $.
	در \cite{sipser13} یک الگوریتم برای تبدیل هر عبارت منظم به عبارت منظم دیگری که مکملش است آمده. اما عبارت منظمی که در \cite{sipser13} آمده الفبای متناهی دارد. در عبارات منظمی که اینجا داریم اما الفبا نامتناهی است. بنابراین دو سیستم متفاوت داریم و کاملا محتمل است که آن روش که به کمک اتوماتای متناهی است، در مورد این نوع عبارت منظم صدق نکند. اما به هر حال با اندکی اهمال و ساده گیری این بخش از اثبات را رها می‌کنیم و به ادامه‌ی راه می‌پردازیم، به این امید که بعدا این تکه از اثبات هم حل شود.
	
	$$\blacktriangleright\phi= \bigcirc \phi_1:$$
	اگر $\mathsf{R_1}$ عبارت منظم معادل $\phi_1$ باشد، آنگاه 
	$?: \mathit{T} \bullet \mathsf{R_1}$
	عبارت منظم $\bigcirc \phi_1$ است.
	
	$$\blacktriangleright\phi= \phi_1 \mathcal{U} \phi_2:$$
	طبق فرض استقرا $\mathsf{R_1,R_2}$ وجود دارند که به ترتیب معادل با فرمول‌های $\phi_1,\phi_2$ هستند. احتمالا این اثبات‌ها را باید به کمک تابع سر و دم و و فرم نرمال فصلی یک عبارت منظم کامل کرد.
	
	
\end{proof}


از طرف دیگر نشان می‌دهیم که عبارت منظم 
$\mathsf{ (?:\mathit{T} \bullet L:B)*}$
که در واقع شامل همه‌ی رد‌های پیشوندی می‌شود که که در اعضای زوجشان اتم $\mathsf{L:B}$ را ارضا می‌کند و در اعضای فردشان مهم نیست که چه اتفاقی می‌افتد، در \lr{LTL} قابل بیان نیست.

این را با برهان خلف به صورت استقرایی روی ساختار فرمول $\phi$ ثابت می‌کنیم. 

\begin{thm}
	هیچ فرمول 
	$\phi \in \mathfrak{L}_e$ 
	وجود ندارد که به ازای یک زوج $\mathsf{L:B}$ داشته باشیم
	$\mathcal{S}^t \llbracket \phi \rrbracket = \mathcal{S}^r \llbracket \mathsf{(?:\mathit{T}\bullet \mathsf{L:B})^*} \rrbracket$.
\end{thm}
\begin{proof}
$$\blacktriangleright \phi = \mathsf{L:B}: $$
ردهای پیشوندی موجود در معنای این فرمول همه تک عضوی هستند در حالی که در معنای عبارت منظم 
$\mathsf{(?:\mathit{T}\bullet \mathsf{L:B})^*}$
ردهای به طول متفاوت وجود دارند. پس $\phi$ به این فرم نمی‌تواند باشد.

$$\blacktriangleright \phi = \phi_1 \lor \phi_2: $$
فرض استقرا این است که معنای هیچ یک از $\phi_1,\phi_2$ با این عبارت منظم برابر نیست.


\end{proof}

پس در این صورت لزوما هر چه که با عبارات منظم قابل بیان است، با \lr{LRL} قابل بیان نیست.



















