
\chapter{\gls*{formalization} جدید برای روش وارسی مدل}

در این فصل، صورت جدیدی برای روش وارسی مدل ارائه ‌می‌شود. در این صورت، برای بیان ویژگی‌های مورد بررسی به‌جای منطق زمانی از \gls*{lregex} استفاده می‌شود. با صحبت در مورد ویژگیهای برنامه‌ها شروع می‌کنیم، سپس به معرفی نحو و معناشناسی عبارات منظم، به عنوان یک منطق برای بیان ویژگی‌ها، می‌پردازیم و پس از آن، صورت جدید روش وارسی مدل را ارائه می‌کنیم. در آخر این فصل نیز، به بحث در مورد \gls*{decidability} این روش می‌پردازیم. 


\section{ویژگی‌های برنامه‌ها}
تا به اینجای کار، نحو و معناشناسی یک زبان برنامه نویسی را تعریف کرده‌ایم. در این بخش، در مورد ویژگی‌های برنامه‌هایی که در این زبان نوشته می‌شوند، با توجه به معناشناسی رد پیشوندی که در فصل پیش تعریف کردیم، صحبت می‌کنیم. برای برنامه‌هایی که در یک زبان برنامه‌نویسی نوشته می‌شوند، می‌توان به اشکال مختلفی ویژگی تعریف کرد. مثلا ویژگی‌های کاملا نحوی، مثل اینکه طول برنامه چند خط است یا هر کاراکتر چند بار به کار رفته است، یا ویژگی‌های محاسباتی، مثل بررسی‌ سرعت برنامه یا میزان استفاده‌ی آن از حافظه که عموما در \gls*{algtheory} و \gls*{complexity} بررسی می‌شود. در اینجا، منظور ما از تعریف ویژگی، متناسب است با گردش کار برنامه‌ها. 
ابتدا به صحبت در مورد ویژگی‌ها در صوری‌گری‌مان، می‌پردازیم. صحبت در مورد اینکه با توجه به تعاریفی که ارائه داده‌ایم، خوب است که ویژگی‌ها را چه طور تعریف کنیم. سپس، به سراغ تعریف یک نوع عبارات منظم می‌رویم که بشود از آن برای بیان ویژگی‌ها استفاده کرد.
\subsection{ویژگی‌ها}
همان‌طور که در فصل قبل دیدیم، معنای هر برنامه‌ی $\mathsf{P}$ با یک مجموعه‌ی 
$\mathcal{S^*}\llbracket {\mathsf{P}}\rrbracket$
مشخص می‌شود. اگر بخواهیم، ویژگی‌هایی را برای موجوداتی ریاضیاتی که به با مجموعه‌ها تعریف شده‌اند، بیان بکنیم، اینکه ویژگی‌ها را هم با مجموعه‌ها بیان کنیم، کار معقولی به نظر می‌رسد. مثل اینکه بخواهیم ویژگی زوج بودن را در مورد اعداد طبیعی بیان کنیم. می توانیم مجموعه‌ی $\mathbb{E}$ را به عنوان مجموعه‌ی همه‌ی اعداد زوج در نظر بگیریم. در مورد یک \gls*{collection} از اعداد طبیعی، می‌توانیم خاصیت زوج بودن را معادل با این در نظر بگیریم که که هر چه داخل این گردایه هست، در $\mathbb{E}$ عضو است. پس یعنی در مورد گردایه‌هایی از اعداد طبیعی، می‌توان یک سری ویژگی را به شکل زیرمجموعه‌ای از مجموعه‌ی $\mathbb{N}$ بیان کرد. یعنی هر عضو 
$\mathit{P}(\mathbb{N})$
بنا به صحبت ما یک ویژگی از اعداد طبیعی است.
در مورد برنامه‌ها نیز قرار است همین رویه را پیش بگیریم. تابع 
$\mathcal{S^*}$
از \gls*{type} 
$\mathbb{P} \rightarrow \mathit{P}(\mathfrak{S^*})$
است. یعنی یک برنامه را در ورودی می‌گیرد و یک مجموعه از ردهای پیشوندی را باز می‌گرداند. پس می‌توانیم، هر ویژگی را به عنوان زیر مجموعه‌ای از 
$\mathit{P}(\mathfrak{S^*})$
تعریف کنیم، به عبارت دیگر عضوی از
$\mathit{P(P}(\mathfrak{S^*}))$. 
تعریف ویژگی‌ها به کمک رابطه‌ی زیرمجموعه بودن از سنت‌های نظریه‌ی \gls*{abstint}\cite{cousot1} است.

\subsection{عبارات منظم}
برای بیان ویژگی‌های برنامه‌ها به یک چارچوب نیاز داریم. در صورت سنتی روش وارسی مدل از منطق های زمانی برای بیان ویژگی‌ها به صورت صوری استفاده می‌کرد و این احتیاج به یک منطق را برای ارائه‌ی یک صوری‌گری کامل که رسیدن به صورت جدید وارسی مدل است، به ما نشان می‌دهد. طبق \cite{calcul} یک دلیل برای استفاده از عبارات منظم، که متداول‌تر بودن آن بین جامعه‌ی برنامه نویسان است. منظور این است که برنامه نویسان از شاخه‌های مختلف این تخصص همگی با عبارات منظم آشنا هستند، درحالیکه برنامه نویسانی که با منطق‌های زمانی آشنایی داشته باشند، بسیار کم هستند و جایگزینی اولی با دومی می‌تواند به رواج استفاده از روش وارسی مدل برای درستی‌یابی برنامه‌های کامپوتری کمک کند. ابتدا، نحو این منطق را تعریف می‌کنیم، سپس به سراغ معناشناسی آن می‌رویم. عبارات منظمی که در اینجا تعریف می‌کنیم، با عبارات منظم سنتی که در علوم کامپیوتر رایج هستند، در جزئیات متفاوت هستند. 
\subsection{نحو عبارات منظم}
فرق عمده‌ای که نحو عبارات منظم ما با عبارات منظم سنتی دارد، در \gls{atom}هاست. اتم‌ها در عبارات منظم سنتی بدون ساختار بودند، اما در اینجا، ساختار دارند. در اینجا، هر اتم یک زوج مرتب است، متشکل از مجموعه‌ی $\mathsf{L}$ شامل برچسب‌ها و عبارت بولی $\mathsf{B}$. این زوج مرتب را به شکل 
$\mathsf{L : B}$
نمایش می‌دهیم.\\ 
نحو عبارات منظم به شکل زیر است:
\begin{defn}
$$\mathsf{L} \in \mathit{P}(\mathbb{L})$$        
$$\mathsf{x,y,...} \in \mathbb{X}$$
$$\mathsf{\underline{x},\underline{y},...} \in \mathbb{\underline{X}}$$
$$\mathsf{B} \in \mathbb{B}$$
$$\mathsf{R} \in \mathbb{R}$$
$$\mathsf{R} ::=\hspace{0.5cm} \varepsilon\hspace{4.2cm}$$
$$|\:\:\:\mathsf{L : B}\hspace{2.4cm}$$
$$|\:\:\:\mathsf{R_1 R_2}\:\:\:(or\:\mathsf{R_1 \bullet R_2 })$$
$$\:\:\:\:\:\:\:|\:\:\:\mathsf{R_1\:\mid\:R_2}\:\:\:(or\:\mathsf{R_1 + R_2 })$$
$$|\:\:\:\mathsf{R_1^*}\hspace{2.8cm}$$
$$|\:\:\:\mathsf{R_1^+}\hspace{2.7cm}$$
$$|\:\:\:(\mathsf{R_1})\hspace{2.47cm}$$
\end{defn}
همان طور که قابل مشاهده است، در اینجا، \glspl*{binop} چسباندن
$(\bullet)$
 و \gls{choice}
$(|)$
 را به همراه \glspl*{unop}
$^*$
و
$^+$
داریم.
در ادامه، با توجه به تعریف \gls{regexsem}، خواهیم دید که معنای عملگر یگانی 
$^+$
به وسیله‌ی عملگر یگانی $^*$ قابل بیان است.
توجه شود که پرانتزها هم جزئی از نحو قرار داده شده‌اند.


همین‌ طور در اینجا، می‌خواهیم از تعدادی عبارات مخفف که در ادامه استفاده می‌شوند، معرفی کنیم. منظور از عبارت منظم 
$\mathsf{? : B}$
همان عبارت منظم
$\mathbb{L}\mathsf{ : B}$
است. عبارت منظم 
$l : \mathsf{B}$
به جای عبارت منظم 
$\{l\} : \mathsf{B}$
به کار می‌رود و منظور از عبارت منظم
$\neg l \mathsf{: B}$
نیز عبارت منظم 
$\mathbb{L}\setminus\{l\}:\mathsf{B}$
است. 

یک نکته‌ی قابل توجه، با توجه به تعاریف فصل قبل، وجود یک مجموعه به نام
$\mathbb{\underline{X}}$
در کنار 
$\mathbb{X}$
که از قبل داشتیم، است. به ازای هر 
$\mathsf{x}\in\mathbb{X}$
یک 
$\mathsf{\underline{x}}\in\mathbb{\underline{X}}$
داریم. 
$\mathsf{\underline{x}}$
متغیر 
$\mathsf{x}$
در ابتدای هر برنامه است.  همان‌طور که تعریف می‌کنیم:
\begin{defn}
	(\gls{initenv}): به هر تابع  
	$\underline{\rho}:\underline{\mathbb{X}}\rightarrow\mathbb{V}$
	یک محیط اولیه می‌گوییم. مجموعه‌ی همه‌ی محیط‌های اولیه را با 
	$\underline{\mathbb{EV}}$
	نمایش می‌دهیم.
\end{defn}
 
\subsection{معناشناسی عبارات منظم}
معنای هر عبارت منظم را با استفاده از تابع 
$\mathcal{S}^r$
به نام \gls{regexsemantics} تعریف می‌کنیم. این تابع در ورودی‌اش یک عبارت منظم 
$\mathsf{R}$
را می‌گیرد، سپس یک مجموعه از زوج مرتب‌های
$\langle\underline{\rho} , \pi\rangle$
را که 
$\pi \in \mathfrak{S^*}$
و 
$\underline{\rho} \in \underline{\mathbb{EV}}$
باز می‌گرداند. بنابراین این تابع از نوع
$\mathbb{R} \rightarrow \mathit{P} (\mathbb{\underline{EV}} \times \mathfrak{S}^*)$
است.
 منظور از 
 $\mathfrak{S}^*$
 نیز 
 $\mathfrak{S}^+ \cup \{\epsilon\}$
 است.
 
تعریف \gls*{inductive} تابع 
$\mathcal{S}^r$
را در ادامه آورده‌ایم.
\begin{defn}
	(معناشناسی عبارات منظم):
	تابع 
	$\mathcal{S}^r:\mathbb{R}\rightarrow \mathit{P}(\mathbb{\underline{EV}\times \mathfrak{S}}^*)$
	به صورت استقرایی روی نحو عبارات منظم به صورت زیر تعریف می‌شود:
$$\mathcal{S}^r\llbracket\varepsilon\rrbracket= \{ \langle \underline{\rho} , \epsilon \rangle | \underline{\rho} \in \underline{\mathbb{EV}}\}$$
[معنای عبارت منظم
$\varepsilon$
مجموعه‌ای شامل زوج مرتب‌هایی از محیط‌های اولیه‌ی مختلف در کنار رد پیشوندی تهی است.]
$$\mathcal{S}^r\llbracket\mathsf{L:B}\rrbracket = \{\langle\underline{\rho},\langle l , \rho \rangle \rangle | l \in \mathsf{L} \land \mathcal{B}\llbracket\mathsf{B}\rrbracket \underline{\rho},\rho \}$$
[معنای عبارت منظم
$\mathsf{L:B}$
مجموعه‌ای است شامل زوج مرتب‌هایی که عضو اول آن‌ها محیط‌های اولیه‌ی مختلف و عضو دوم آن‌ها ردهای پیشوندی تک‌عضوی 
$\langle l , \rho \rangle$
هستند. در این ردهای پیشوندی، برچسب 
$l$
باید در
$\mathsf{L}$
که مجموعه‌ای از برچسب‌هاست حضور داشته باشد. همین طور باید عبارت بولی 
$\mathsf{B}$
درباره‌ی محیط اولیه
$\underline{\rho}$
و محیط 
$\rho$
برقرار باشد. با توجه به حضور محیط‌های اولیه، در اینجا
$\mathcal{B}$
به جای اینکه از نوع 
$\mathbb{EV} \rightarrow \mathbb{BOOL}$
باشد، از نوع
$\underline{\mathbb{EV}} \rightarrow \mathbb{EV} \rightarrow \mathbb{BOOL}$
است( منظور از 
$\mathbb{BOOL}$
همان مجموعه‌ی 
$\{\mathit{T,F}\}$
است). بعد از تمام شدن تعریف معناشناسی عبارات منظم، دوباره
$\mathcal{A}$
و 
$\mathcal{B}$
را با در نظر گرفتن محیط اولیه تعریف خواهیم کرد.]
$$\mathcal{S}^r\llbracket\mathsf{R_1 R_2}\rrbracket= \mathcal{S}^r\llbracket\mathsf{R_1}\rrbracket \Join \mathcal{S}^r\llbracket\mathsf{R_2}\rrbracket$$
\begin{center}
	به ‌طوریکه، با فرض اینکه دو مجموعه‌ی 
	$\mathcal{S}$
	و
	$\mathcal{S'}$
	هر یک معنای یک عبارت منظم باشند:
$$\mathcal{S \Join S'}=
\{
\langle \underline{\rho}, \pi \pi' \rangle |
\langle \underline{\rho},\pi \rangle \in \mathcal{S} \land
\langle \underline{\rho},\pi' \rangle \in \mathcal{S'}
\}
$$
\end{center}
[اگر یک عبارت منظم داشته باشیم که از چسباندن دو عبارت منظم
$\mathsf{R_1}$
و 
$\mathsf{R_2}$
به هم ساخته شده باشد، آنگاه معنای این عبارت منظم از زوج مرتب‌هایی تشکیل شده است که عضو اول آن‌ها محیط‌های اولیه هستند و عضو دوم آن‌ها از چسباندن ردهای پیشوندی موجود در عضو دوم اعضای مجموعه‌ی معنای این دو عبارت منظم تشکیل شده است. این عملگر چسباندن که در اینجا برای معنای عبارت‌های منظم تعریف شده است، با عملگر چسباندن برای معنای برنامه‌ها که در فصل پیش ارائه شد، متفاوت است. مورد دوم هم با نماد $\Join$ روی ردهای پیشوندی تعریف ‌شد، اما در تعریفی که در این فصل از چسباندن ارائه داده‌ایم، این عملگر روی ردهای پیشوندی تعریف نشده است، بلکه روی زوج‌های مرتبی که در معنای هر عبارت منظمی حضور دارند، تعریف می‌شود.

تا این قسمت از تعریف معناشناسی عبارات منظم که رسیده‌ایم، تا حدی به درکی شهودی از اینکه به چه شکلی عبارات منظم راهی برای توصیف ویژگی‌ در مورد برنامه‌ها هستند، دست پیدا کرده‌ایم. همان‌طور که در حالت قبل دیدیم، \gls*{consistency} هر زوج مرتب
$\mathsf{L:B}$
با یک وضعیت داخل یک رد پیشوندی بررسی می‌‌شود. این زوج‌ مرتب‌ها موازی با وضعیت‌ها در ردهای پیشوندی معنای برنامه پیش می‌روند و سازگاری آن‌ها با یکدیگر بررسی می‌شود تا وارسی مدل انجام شود.]
$$\mathcal{S}^r \llbracket\mathsf{R_1\:|\:R_2}\rrbracket= 
\mathcal{S}^r \llbracket R_1\rrbracket \cup
\mathcal{S}^r \llbracket R_2\rrbracket$$
[این حالت، معنای \gls*{apply} عملگر انتخاب روی دو عبارت منظم را توصیف می‌کند. معنای اعمال این عملگر به صورت اجتماع معنای هر دو عبارت منظم تعریف شده است.]

$$\mathcal{S}^r \llbracket\mathsf{R}\rrbracket^0 = \mathcal{S}^r\llbracket\varepsilon\rrbracket$$
$$\mathcal{S}^r \llbracket\mathsf{R}\rrbracket^{n+1} = \mathcal{S}^r \llbracket\mathsf{R}\rrbracket^{n} \Join
\mathcal{S}^r \llbracket\mathsf{R}\rrbracket$$
[دو عبارت اخیر، برای تعریف معنای عملگرهای $^*$ و $^+$ تعریف شده‌اند. عملگر $\Join$ و معنای 
$\mathcal{S}^r\llbracket\varepsilon\rrbracket$
را هم که قبلا تعریف کرده بودیم و $0$ و $n$ هم اعداد طبیعی‌اند.]
$$\mathcal{S}^r\llbracket\mathsf{R^*}\rrbracket =  \bigcup_{n \in \mathbb{N}}
\mathcal{S}^r \llbracket\mathsf{R}^n\rrbracket$$
$$\mathcal{S}^r\llbracket\mathsf{R^+}\rrbracket =  \bigcup_{n \in \mathbb{N}\setminus\{0\}}
\mathcal{S}^r \llbracket\mathsf{R}^n\rrbracket$$
[این دو عبارت تعریف معنای دو عملگر $^*$ و $^+$ هستند. منظور از $\mathbb{N}$ مجموعه‌ی اعداد طبیعی است. همان‌طور که قبل‌تر هم اشاره شد، معنای عملگر $^+$ با عملگر $^*$ قابل بیان است. اضافه می‌کنیم که معنای عملگر $^*$ را در \gls*{meta}( و نه در منطق تعریف شده در اینجا) می‌توان با عملگر انتخاب تعریف کرد.]

$$\mathcal{S}^r \llbracket(\mathsf{B})\rrbracket=\mathcal{S}^r \llbracket\mathsf{B}\rrbracket$$
[این قسمت از تعریف هم صرفا بیان می‌کند که پرانتزها تاثیری در معنای عبارات منظم ندارند که کاملا قابل انتظار است، چرا که وجود پرانتز قرار است صرفا در خواص نحو منطق نقش داشته باشد.]

\end{defn}

\begin{defn}
	(\gls*{satisfy}): می‌گوییم، در محیط اولیه‌ی $\underline{\rho}$ رد پیشوندی $\pi$ عبارت منظم $\mathsf{R}$ را ارضا می‌کند، اگر و تنها اگر 
	$\langle \underline{\rho},\pi \rangle \in \mathcal{S}^r \llbracket \mathsf{R} \rrbracket$. 
\end{defn}

تعریف معناشناسی عبارات منظم در اینجا تمام می‌شود، اما همان‌گونه که در لا‌به‌لای تعاریف گفته ‌شد، احتیاج داریم که $\mathcal{A}$ و $\mathcal{B}$ را از نو تعریف کنیم:
\begin{defn}
	توابع 
	$\mathcal{A}:\mathbb{A}\rightarrow \mathbb{\underline{EV}} \rightarrow
	\mathbb{EV} \rightarrow \mathbb{V}$
	و 
	$\mathcal{B}:\mathbb{B}\rightarrow \mathbb{\underline{EV}} \rightarrow
	\mathbb{EV} \rightarrow \mathbb{BOOL}$
	به شکل استقرایی به ترتیب روی ساختار عبارت‌های حسابی 
	$\mathsf{A}\in\mathbb{A}$
	و عبارت‌های بولی
	$\mathsf{B} \in \mathbb{B}$
	به شکل زیر تعریف می‌شوند:
	
	
$$\mathcal{A}\llbracket\mathsf{1}\rrbracket\underline{\rho},\rho=1$$
$$\mathcal{A}\llbracket\mathsf{\underline{\mathsf{x}}}\rrbracket\underline{\rho},\rho= \underline{\rho}(\mathsf{x})$$
$$\mathcal{A}\llbracket\mathsf{\mathsf{x}}\rrbracket\underline{\rho},\rho= \rho(\mathsf{x})$$
$$\mathcal{A}\llbracket\mathsf{A_1 - A_2}\rrbracket\underline{\rho},\rho= 
\mathcal{A}\llbracket\mathsf{A_1}\rrbracket\underline{\rho},\rho - \mathcal{A}\llbracket\mathsf{A_2}\rrbracket\underline{\rho},\rho$$
$$\mathcal{B}\llbracket\mathsf{A_1 < A_2}\rrbracket\underline{\rho},\rho=
	\mathcal{A}\llbracket\mathsf{A_1}\rrbracket\underline{\rho},\rho\: <\: \mathcal{A}\llbracket\mathsf{A_2}\rrbracket\underline{\rho},\rho$$
$$\mathcal{B}\llbracket\mathsf{B_1\:nand\:B_2}\rrbracket\underline{\rho},\rho=
\mathcal{B}\llbracket\mathsf{B_1}\rrbracket\underline{\rho},\rho \uparrow 
\mathcal{B}\llbracket\mathsf{B_2}\rrbracket\underline{\rho},\rho $$
\end{defn}
قابل مشاهده است که تعاریف جدید تا حد خوبی به تعاریف قبلی شبیه هستند و فرق عمده صرفا وارد شدن $\underline{\rho}$ است.\\

حال که معناشناسی عبارات منظم را داریم، به طور مختصر به مقایسه‌ی عبارات منظمی که در این بحث تعریف کرده‌ایم و عبارات منظم کلاسیک در باقی نوشته‌ها و موضوعات می‌پردازیم. \gls{kleenealgebra} یک  \gls*{algstruc} است که تعمیمی است از عبارات منظم معرفی شده در \cite{kleene56}. سر و کله‌ی عبارات منظم در قسمت‌های مختلفی از علوم کامپیوتر پیدا می‌شود، اما با تعاریفی که هم‌ارز نیستند. هدف از ارائه‌ی جبر کلاینی این بوده است که تعریفی عمومی باشد که این تعاریف \gls*{unequiv} را در خود جای می‌دهد. در \cite{DexterKleene} آمده است که برای جبر کلاینی هم تعاریف مختلفی که با هم‌ارز نیستند، معرفی شده است. علاوه بر این، این مقاله به بررسی این تعاریف و ارتباطشان با یکدیگر پرداخته است. همین طور، این مقاله خود با یک تعریف از جبر کلاینی شروع کرده است. طبق این تعریف، اگر عبارات منظمی که در اینجا تعریف کرده‌ایم، یک جبر کلاینی می‌بودند، می‌بایستی که برای هر عبارت منظم $\mathsf{R}$ می‌داشتیم
$\mathcal{S}^r \llbracket \mathsf{\varepsilon R} \rrbracket = \mathcal{S}^r \llbracket \mathsf{\varepsilon} \rrbracket$،
چون $\varepsilon$ نقش صفر عملگر چسباندن( که \gls*{multop} جبر کلاینی است) را دارد و یک جبر کلاینی برای صفر \gls*{absroplaw} را به عنوان یک \gls*{law} دارد. اما در مورد عبارات منظمی که در اینجا تعریف کرده‌ایم، داریم 
$\mathcal{S}^r \llbracket \mathsf{\varepsilon R} \rrbracket = \mathcal{S}^r \llbracket \mathsf{R} \rrbracket$.
بیشتر از این به این بحث نمی‌پردازیم که بحث دامنه‌دار و منحرف کننده‌ایست. یک قضیه را در مورد عبارات منظم ارائه می‌دهیم که \gls*{distrib} عملگر انتخاب به عملگر چسباندن است و بعد به ادامه‌ی راه اصلیمان می‌پردازیم.
\begin{thm}
	برای عبارت‌های منظم
	 $\mathsf{R , R}_1,\mathsf{R}_2$
	 داریم:
	  $$\mathcal{S}^r \llbracket \mathsf{R}\bullet (\mathsf{R}_1 + \mathsf{R}_2) \rrbracket = \mathcal{S}^r \llbracket (\mathsf{R \bullet R}_1) + (\mathsf{R \bullet R}_2) \rrbracket $$
\end{thm}

\begin{proof}
	$$\mathcal{S}^r \llbracket \mathsf{R}\bullet (\mathsf{R}_1 + \mathsf{R}_2) \rrbracket =\mathcal{S}^r \llbracket \mathsf{R} \rrbracket \Join \mathcal{S}^r \llbracket (\mathsf{R}_1+\mathsf{R}_2) \rrbracket$$
	$$=\mathcal{S}^r \llbracket \mathsf{R} \rrbracket \Join \mathcal{S}^r \llbracket \mathsf{R}_1+\mathsf{R}_2 \rrbracket=\mathcal{S}^r \llbracket \mathsf{R} \rrbracket \Join (\mathcal{S}^r \llbracket \mathsf{R}_1 \rrbracket \cup \mathcal{S}^r\llbracket \mathsf{R}_2 \rrbracket)$$
	$$= \{ \langle \underline{\rho}, \pi \pi' \rangle| \langle \underline{\rho}, \pi \rangle \in \mathcal{S}^r \llbracket \mathsf{R} \rrbracket \land (\langle \underline{\rho},\pi'\rangle \in \mathcal{S}^r \llbracket \mathsf{R}_1 \rrbracket\lor \langle \underline{\rho} , \pi' \rangle \in \mathcal{S}^r \llbracket \mathsf{R}_2 \rrbracket) \}$$
	$$=\{ \langle \underline{\rho}, \pi \pi' \rangle| (\langle \underline{\rho}, \pi \rangle \in \mathcal{S}^r \llbracket \mathsf{R} \rrbracket \land \langle \underline{\rho},\pi'\rangle \in \mathcal{S}^r \llbracket \mathsf{R}_1 \rrbracket) \lor (\langle \underline{\rho}, \pi \rangle \in \mathcal{S}^r \llbracket \mathsf{R} \rrbracket \land \langle \underline{\rho} , \pi' \rangle \in \mathcal{S}^r \llbracket \mathsf{R}_2 \rrbracket  \}$$
	$$=\{ \langle \underline{\rho}, \pi \pi' \rangle|\langle \underline{\rho}, \pi \rangle \in \mathcal{S}^r \llbracket \mathsf{R} \rrbracket \land \langle \underline{\rho},\pi'\rangle \in \mathcal{S}^r \llbracket \mathsf{R}_1 \rrbracket\} \cup
	\{ \langle \underline{\rho}, \pi \pi' \rangle|\langle \underline{\rho}, \pi \rangle \in \mathcal{S}^r \llbracket \mathsf{R} \rrbracket \land \langle \underline{\rho},\pi'\rangle \in \mathcal{S}^r \llbracket \mathsf{R}_2 \rrbracket\}$$
	$$=(\mathcal{S}^r \llbracket \mathsf{R} \rrbracket \Join \mathcal{S}^r \llbracket \mathsf{R}_1\rrbracket ) \cup (\mathcal{S}^r \llbracket \mathsf{R} \rrbracket \Join \mathcal{S}^r \llbracket \mathsf{R}_2 \rrbracket)=
	\mathcal{S}^r \llbracket \mathsf{R\bullet R}_1 \rrbracket \cup \mathcal{S}^r \llbracket \mathsf{R\bullet R}_2 \rrbracket$$
	$$=\mathcal{S}^r \llbracket (\mathsf{R \bullet R}_1) + (\mathsf{R \bullet R}_2) \rrbracket $$
\end{proof}
تا اینجای کار، بیشتر مفاهیمی که برای بیان صورت جدید روش وارسی مدل احتیاج داریم را بیان کرده‌ایم، هرچند که هنوز برخی از تعاریف باقی مانده‌اند.
\subsection{گونه‌های مختلف نحو عبارات منظم}
به عنوان قسمت آخر این بخش، گونه‌های مختلفی از نحو عبارات منظم را بیان می‌کنیم که هر کدام در واقع زیرمجموعه‌ای از منطقی که توصیف کرده‌ایم را تشکیل می‌دهند. بعضی از آن‌ها را در همین فصل، برای هدف نهایی این فصل و بعضی دیگر را در فصل بعدی استفاده می‌کنیم.

می‌توانیم به هر یک از این عبارات منظم به چشم یک منطق متفاوت نگاه کنیم. هرچند که معناشناسی عبارات منظم به عنوان معناشناسی هر یک از این منطق‌ها باقی می‌ماند. با توجه به اینکه هر یک از این منطق‌ها زیرمجموعه‌ی عبارات منظم هستند، می‌توان گفت معناشناسی هر یک از آن‌ها همان تابع $\mathcal{S}^r$ با \gls*{domain}ی محدود شده است.

اولین گونه‌ای که می‌خواهیم بیان کنیم، گونه‌ای است که در اعضای آن اصلا اتم حضور ندارد و کل عبارت‌های منظم عضو این منطق از $\varepsilon$ها تشکیل شده‌اند.
\begin{defn}
	(\gls{emptyregex} - $\mathbb{R_\varepsilon}$): 
	$$\mathsf{R} \:\:\:\in\:\:\: \mathbb{R}_\varepsilon$$
	$$\mathsf{R}\:\:\: ::= \:\:\: \varepsilon \: | \: \mathsf{R_1 R_2} \: | 
	\: \mathsf{R_1 + R_2} \: | \: \mathsf{R_1^*} \: | \: \mathsf{R_1^+} | (\mathsf{R_1})$$
\end{defn}


 با توجه به آنچه گفتیم، معنای همه‌ی این عبارت‌های منظم عضو این منطق برابر 
$\{\langle \underline{\rho} , \epsilon \rangle\}$
خواهد بود.

گونه‌ی بعدی \gls{nonemptyregex} است.
\begin{defn}
	(عبارات منظم ناتهی - $\mathbb{R}^+$):
	$$\mathsf{R} \:\:\:\in\:\:\: \mathbb{R}^+$$
	$$\mathsf{R}\:\:\: ::= \:\:\: \mathsf{L:B} \: |
	\: \mathsf{\varepsilon R_2} \: | \: \mathsf{R_1 \varepsilon} \: |
	\: \mathsf{R_1 R_2} \: | 
	\: \mathsf{R_1 + R_2} \: | \: \mathsf{R_1^+} | (\mathsf{R_1})$$
\end{defn}
دلیل وجود 
$\mathsf{\varepsilon R_2}$
و 
$\mathsf{R_1 \varepsilon}$
در تعریف این است که ممکن است معنای عبارت منظمی در این منطق با ${\langle \underline{\rho} , \epsilon \rangle}$ برابر نباشد، اما در آن عبات منظم، $\varepsilon$ حضور داشته باشد. با این تفاصیل، می‌توان دید که دو مجموعه‌ی 
$\mathbb{R}_\varepsilon$
و
$\mathbb{R}^+$
یک \gls*{partition} برای مجموعه‌ی $\mathbb{R}$ هستند، چونکه معنای هر عبارت منظم در $\mathbb{R}$ یا با ${\langle \underline{\rho} , \epsilon \rangle}$ برابر هست یا نیست. بنابراین شاید به نظر برسد که تعریف یکی از این نحوها کافی باشد. اما این‌طور نیست، چون ممکن است که درجایی احتیاج داشته باشیم که تعریفی استقرایی روی هر یک از این دو ساختار ارائه دهیم، یا اینکه در اثبات حکمی بخواهیم از استقرا روی یکی از این دو ساختار استفاده کنیم.

گونه‌ی آخر عبارات منظم ما نیز \gls{choicefreeregex} است.
\begin{defn}
(عبارات منظم بدون انتخاب - $\mathbb{R}^\nmid$):
$$
\mathsf{R}\:\:\: \in \:\:\: \mathbb{R}^\nmid$$
$$
\mathsf{R}\:\:\: ::= \:\:\: \varepsilon \: | \: \mathsf{L:B} \: | \:
\mathsf{R_1 R_2} \: | \: \mathsf{R_1}^* \: | \: \mathsf{R_1}^+ \: | \:
(\mathsf{R_1})$$
\end{defn}

\section{صورت جدید مسئله‌ی وارسی مدل}
بالاخره، به هدف نهایی این فصل رسیدیم. می‌خواهیم صورت جدیدی از مسئله‌ی وارسی مدل را بیان ‌کنیم.\\
پیش از ارائه‌ی تعریف وارسی مدل، نیاز داریم که عملگر \gls{prefixclosure} را برای یک مجموعه از ردهای پیشوندی معرفی کنیم.
\begin{defn}
	(بستار پیشوندی):
	اگر 
	$\Pi \in \mathit{P}(\mathbb{\underline{EV}\times \mathfrak{S}^+})$،
	آنگاه بستار پیشوندی $\Pi$ را به صورت زیر تعریف می‌کنیم:
	$$\mathsf{prefix}(\Pi)=
	\{\langle \underline{\rho},\pi\rangle | \pi \in \mathfrak{S^+} \land \exists\
	\pi' \in \mathfrak{S^*}: \langle \underline{\rho}, \pi \pi' \rangle \in \Pi \}$$
\end{defn}

برای درک بهتر مفهوم بستار پیشوندی به مثال زیر توجه شود.
\begin{exm}
	اگر 
	$\Pi = \{\langle\underline{\rho},\langle l_1 , \rho_1 \rangle 
	\langle l_2  \rho_2 \rangle\rangle  \langle l_3 , \rho_3 \rangle\rangle 
	,
	\langle\underline{\rho},\langle {l_1}' , {\rho_1}' \rangle  \langle {l_2}'  {\rho_2}' \rangle\rangle
	\}$
	باشد( $\Pi$ شامل دو عضو است)، آنگاه:
	$$
	\mathsf{prefix}(\Pi)=
	\{
	\langle\underline{\rho},\langle l_1 , \rho_1 \rangle\rangle ,
	\langle\underline{\rho},\langle l_1 , \rho_1 \rangle  \langle l_2  \rho_2 \rangle\rangle,
	\langle\underline{\rho},\langle l_1 , \rho_1 \rangle  \langle l_2  \rho_2 \rangle  \langle l_3 , \rho_3 \rangle\rangle ,$$
	$$
	\langle\underline{\rho},\langle {l_1}' , {\rho_1}' \rangle\rangle,
	\langle\underline{\rho},\langle {l_1}' , {\rho_1}' \rangle  \langle {l_2}'  {\rho_2}' \rangle\rangle
	\}
	$$
	که شامل 5 عضو است.
\end{exm}
حال به ارائه‌ی صورت جدید روش وارسی مدل می‌رسیم.
\begin{defn}
(وارسی مدل):
	اگر 
	$\mathsf{P}\in\mathbb{P} , \mathsf{R} \in \mathbb{R}^+ , \underline{\rho} \in \underline{\mathbb{EV}}$
	آنگاه:
	$$\mathsf{P},\underline{\rho} \models \mathsf{R}
	 \Leftrightarrow
	(\{\underline{\rho}\}\times \mathcal{S}^* \llbracket\mathsf{P}\rrbracket) \subseteq 
	\mathsf{prefix} (\mathcal{S}^r \llbracket\mathsf{R} \bullet (?:\mathit{T})^*\rrbracket)
	$$
\end{defn}

این تعریف بیان می‌کند که اگر برنامه‌ی 
$\mathsf{P}$
با محیط اولیه‌ی 
$\underline{\rho}$
اجرا شود، این برنامه در صورتی ویژگی‌ای که با یک عبارت منظم 
$\mathsf{R}$
بیان شده است را دارد که معنای آن زیرمجموعه‌ی بستار پیشوندی معنای عبارت منظم
$\mathsf{R} \bullet (?:\mathit{T})^*$
باشد.
توجه شود که محیط اولیه‌ای که برای برنامه‌ی مورد بررسی در نظر گرفته‌ایم، صرفا به این منظور در تعریف قرار داده شده است که بتوانیم،  معنای برنامه‌ها را با معنای عبارت‌های منظم قابل قیاس کنیم. دلیل حضور محیط اولیه در معنای عبارت‌های منظم نیز در صورت سوم روش وارسی مدل مشخص می‌شود، یعنی جایی که وارسی مدل روی ساختار برنامه‌ها تعریف شده است و ردهای پیشوندی موجود در معنای هر عبارت دستوری یا لیست عبارت‌های دستوری با محیط متفاوتی شروع می‌شوند و اطلاعات محیط اولیه‌ی برنامه در این ردها حضور ندارد (با اینکه ممکن است به آن نیاز داشته باشیم). در این صورت از روش وارسی مدل و صورت بعدی، محیط‌های اولیه صرفا حضور دارند و در عمل نقش مهمی ندارند. 

در مورد نقش عبارت منظم
$ (?:\mathit{T})^*$
و عملگر
$ \mathsf{prefix} $
نیز می‌توان گفت، بنا به تصمیم مبدع این روش، اگر یک رد پیشوندی، با عبارت منظم ناسازگاری نداشته باشد و از آن کوتاه‌تر باشد، این رد پیشوندی با ویژگی بیان شده را دارد. این نکته صرفا در مورد حضور 
$\mathsf{prefix}$ 
بود. حضور 
$(?:\mathit{T})^*$
نیز باعث می‌شود اگر طول عبارت منظم مورد بررسی کمتر از رد پیشوندی باشد و ناسازگاری‌ای مشاهده نشده باشد، رد پیشوندی دارای ویژگی $\mathsf{R}$ در نظر گرفته شود.
در اینجا، بیان صورت جدید وارسی مدل به اتمام می‌رسد.
\section{در مورد توقف پذیری}

در این بخش نکته‌ای در مورد کار که به نظر نگارنده رسیده، مطرح شده است. اگر صحبت ما در اینجا درست باشد، این به این معنی خواهد بود که روشی که در حال توصیفش هستیم،\gls*{undecidable} است، به عبارت دیگر قابلیت پیاده‌سازی را ندارد!

بحث ما در اینجا در مورد \gls*{halting} است. در \cite{calcul} در مورد تعریف \gls*{halt} یک برنامه صحبتی به میان نیامده است، یعنی گفته نشده است که در چه صورتی می‌توانیم، بگوییم که یک برنامه متوقف شده است. یک تعریف  صوری که خودمان می‌توانیم برای این مفهوم، بیاوریم این است:

\begin{defn}
(توقف پذیری:) برنامه‌ی $\mathsf{P}$ را به همراه محیط اولیه
 $\underline{\rho}$
  \gls{terminable}
  می‌گوییم، اگر و تنها اگر وجود داشته باشد 
	$\pi \in \mathcal{S}^* \llbracket \mathsf{P} \rrbracket$، 
	که ($\rho$ محیط متناظر با محیط اولیه‌ی $\underline{\rho}$ است):
	$$\pi = \langle at \llbracket \mathsf{P} \rrbracket , \rho \rangle \pi'$$
	و اینکه $\langle aft\llbracket \mathsf{P} \rrbracket , \rho' \rangle$ در $\pi$ حضور داشته باشد. این اتفاق را با 
	$\mathsf{P,\underline{\rho}\downarrow}$
	نشان می‌دهیم. همین تعریف را برای لیست عبارت‌های دستوری $\mathsf{Sl}$ یا عبارت‌ دستوری $\mathsf{S}$ صرفا با جایگذاری به‌جای برنامه‌ی $\mathsf{P}$ نیز داریم.
\end{defn} 
در این تعریف، توقف پذیری صرفا برای یک محیط اولیه تعریف شده است.
در اینجا، توقف پذیری به متناهی بودن ردهای پیشوندی موجود در برنامه ارتباطی ندارد. با توجه به معناشناسی‌ رد پیشوندی، تعریف کردن توقف پذیری به معنای وجود رد پیشوندی متناهی در معنای برنامه به هیچ عنوان مناسب نیست، چون معناشناسی خاصیت پیشوندی بودن را دارد و مطمئن هستیم، در معنای هر برنامه‌ای حتما یک رد پیشوندی متناهی با محیط اولیه‌ی مورد بررسی وجود دارد.

اگر هم بخواهیم، تعریف توقف پذیری را عدم حضور ردهای پیشوندی نامتناهی در معنای برنامه در نظر بگیریم، به تعریف قوی‌تری نسبت به آنچه ارائه دادیم، رسیده‌ایم. در اینجا، ما سعی می‌کنیم، ضعیف‌ترین تعریف معقول را ارائه دهیم. در این صورت، از اثباتی که بر اساس تعریف ارائه شده، برای تصمیم ناپذیری می‌آوریم، مطمئن‌تر خواهیم شد. با این حال، در قضیه‌ی بعدی می‌بینیم که تعریفی که ارائه کرده‌ایم با اینکه بگوییم، در معنای برنامه رد پیشوندی نامتناهی وجود ندارد معادل است.
\begin{thm}
	برای برنامه‌ی $\mathsf{P}$ و محیط اولیه‌ی $\underline{\rho}$ داریم $\mathsf{P} , \underline{\rho} \downarrow $، اگر و تنها اگر $\rho$ محیط متناظر با محیط اولیه‌ی $\underline{\rho}$ باشد و
	$$\forall \pi \in \mathfrak{S^{+}} : 
	\langle at \llbracket \mathsf{P} \rrbracket , \rho \rangle \pi \in \mathcal{S^*} \llbracket \mathsf{P} \rrbracket \rightarrow
	\langle at \llbracket \mathsf{P} \rrbracket , \rho \rangle \pi \in \mathbb{R^+}$$
	 
\end{thm}
\begin{proof}
	$(\Rightarrow)$
	برای این حالت، باید ثابت کنیم که در معنای هر برنامه‌ای رد پیشوندی‌ای وجود دارد که با
	$\langle at\llbracket \mathsf{P} \rrbracket , \rho \rangle$
	شروع شده است و به ازای یک محیط $\rho'$ به 
	$\langle aft\llbracket \mathsf{P} \rrbracket , \rho' \rangle$
	ختم شده است. 
	در این اثبات، از تعریف برچسب‌ها که در ضمیمه‌ی \cite{calcul} آمده است، استفاده کرده‌ایم.
	داریم:
	$\mathsf{P=Sl}$
	و 
	$aft \llbracket \mathsf{P} \rrbracket = aft \llbracket \mathsf{Sl} \rrbracket $.
	
	حکم را با \gls*{induction} روی ساختار $\mathsf{Sl}$ ثابت می‌کنیم. 
	$$\blacktriangleright \mathsf{Sl = \backepsilon}:$$
	داریم:
	$$\mathcal{S^*} \llbracket \backepsilon \rrbracket = \{\langle at \llbracket \backepsilon \rrbracket , \dot{\rho} \rangle | \dot{\rho} \in \mathbb{EV}\}$$
	همین طور طبق تعریف برچسب‌ها داریم:
	$$at \llbracket \backepsilon \rrbracket = aft \llbracket \backepsilon \rrbracket$$
	پس حکم برقرار است.
	$$\blacktriangleright \mathsf{Sl =Sl'\;S}:$$
	اینکه در معنای $\mathsf{Sl}$، رد پیشوندی‌ای شامل
	 $\langle aft \llbracket \mathsf{Sl} \rrbracket , \rho '\rangle$ وجود داشته باشد، با توجه به تعاریفی که داریم، به این وابسته است که در معنای
	  $\mathsf{S}$،
	   دنباله‌ای شامل $\langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle$ وجود داشته باشد. برای اینکه این گزاره را ثابت کنیم، باید آن را روی ساختار $\mathsf{S}$ ثابت کنیم که در واقع بخش اصلی اثبات این سمت قضیه است. 
	$$\blacktriangleright\blacktriangleright \mathsf{S\;=\; x\doteq A;}:$$
	در این حالت، با توجه به تعریف معنای $\mathsf{S}$، دنباله‌ی 
	$$\langle at \llbracket \mathsf{S} \rrbracket ,\rho \rangle \langle aft\llbracket\mathsf{S}\rrbracket , \rho[\mathsf{x}\leftarrow \mathcal{A}\llbracket\mathsf{A}\rrbracket\rho] \rangle $$
	در معنای عبارت‌ دستوری به ازای هر $\rho$ وجود دارد. پس دنباله‌ای به شکل بالا با محیطی متناظر با
	$\underline{\rho}$
	هم در معنای عبارت‌ دستوری حضور دارد.
	$$\blacktriangleright\blacktriangleright \mathsf{S=\; ; \;\;}:$$	 
با توجه به معنای این عبارت‌ دستوری، دنباله‌ی زیر در معنای این عبارت‌ دستوری وجود دارد.
$$\langle at \llbracket \mathsf{S} \rrbracket ,\rho \rangle \langle aft\llbracket\mathsf{S}\rrbracket , \rho \rangle $$

$$\blacktriangleright\blacktriangleright \mathsf{S=\; if\;(B)\;S_t}:$$
	در صورتی که 
	$\mathcal{B}\llbracket\mathsf{B}\rrbracket\rho=\mathit{T}$
	برقرار باشد، دنباله‌ی 
	$$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle
	\langle at \llbracket \mathsf{S_t} \rrbracket , \rho \rangle \pi$$
	در مجموعه‌ی معنای این عبارت‌ دستوری حضور دارد، در حالیکه، 
	$\langle at \llbracket \mathsf{S_t} \rrbracket , \rho \rangle \pi$
	داخل معنای $\mathsf{S_t}$ نیز هست. طبق \gls*{indhyp} می‌دانیم که برچسب آخرین وضعیت $\pi$ برابر است با $aft \llbracket \mathsf{S_t} \rrbracket$ که طبق تعاریف مربوط به برچسب‌ها داریم
	$aft \llbracket \mathsf{S_t} \rrbracket=aft \llbracket \mathsf{S} \rrbracket$.\\
	در صورتی که معنای عبارت بولی غلط باشد نیز، طبق تعریف، دنباله‌ی زیر در معنای عبارت‌ دستوری موجود است.
	$$\langle at \llbracket \mathsf{S} \rrbracket ,\rho \rangle \langle aft\llbracket\mathsf{S}\rrbracket , \rho \rangle $$
	
$$\blacktriangleright\blacktriangleright \mathsf{S=\; if\;(B)\;S_t\;else\;S_f}:$$
مانند حالت قبل است، منتها با این تفاوت که در صورتی که معنای عبارت بولی غلط باشد، دنباله‌ی زیر در معنای عبارت‌ دستوری حضور دارد:
	$$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle
\langle at \llbracket \mathsf{S_f} \rrbracket , \rho \rangle \pi$$
همین ‌طور، تساوی 
$aft \llbracket \mathsf{S_t} \rrbracket=aft \llbracket \mathsf{S} \rrbracket=aft \llbracket \mathsf{S_f} \rrbracket$
هم طبق تعریف برچسب‌ها برقرار است.

$$\blacktriangleright\blacktriangleright \mathsf{S=\; while\;(B)\;S_t}:$$
در اثبات این سمت قضیه، این حالت پیچیده ترین حالت است و در واقع تنها حالتی است که در اثبات آن به فرض قضیه احتیاج داریم! همان طور که پیش‌تر گفتیم، معنای عبارت دستوری حلقه به کمک یک تابع تعریف می‌شود. معنای حلقه کوچکترین نقطه‌ثابت این تابع است، در حالیکه، این تابع وقتی روی یک مجموعه از ردهای پیشوندی اعمال شود، تاثیرات یک بار اجرای عبارت‌(های) دستوری درون حلقه را روی ردهای پیشوندی درون مجموعه اعمال می‌کند.

طبق تعریف $\mathcal{F}$، مطمئن هستیم که رد پیشوندی‌ای که با محیط $\underline{\rho}$ شروع شود، در مجموعه‌ی معنای $\mathsf{S}$ وجود دارد، چون به ازای هر محیط $\dot{\rho}$(نقطه به این خاطر است که با $\rho$ خاص موجود در فرض اشتباه گرفته نشود) حالت 
$\langle at \llbracket \mathsf{S} \rrbracket, \dot{\rho} \rangle$
 در هر اعمال تابع $\mathcal{F}$ روی هر مجموعه‌ی دلخواه وجود دارد. چون معنای $\mathsf{S}$ را به عنوان کوچک‌ترین نقطه‌ثابت $\mathcal{F}$ در نظر گرفته‌ایم، مطمئن هستیم که مجموعه‌ای که کوچکترین نقطه‌ثابت تابع $\mathcal{F}$ است، شامل رد پیشوندی 
 $\langle at \llbracket \mathsf{S} \rrbracket, \rho \rangle$
 می‌شود. این رد پیشوندی، با اجرای $\mathcal{F}$ تحت تاثیر قرار می‌گیرد. اگر معنای $\mathsf{B}$ در یکی از اعمال های $\mathcal{F}$ غلط باشد، رد پیشوندی
$ \langle at \llbracket \mathsf{S} \rrbracket, \rho \rangle \pi \langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle$ 
در معنای برنامه قرار خواهد گرفت و می‌توانیم، بگوییم اجرای عبارت‌ دستوری با این محیط اولیه توقف پذیر است. می‌دانیم که طبق تعریف تابع، چیزی به انتهای این رد پیشوندی اضافه نمی‌شود. از طرف دیگر، با این محیط اولیه، با توجه به تعریف، رد پیشوندی دیگری وجود ندارد که طولانی‌تر از رد پیشوندی مورد اشاره باشد. 

در حالت دیگر، اگر فرض کنیم هیچ گاه به حالتی نمی‌رسیم که در آن معنای $\mathsf{B}$ غلط باشد هم با فرض مسئله به تناقض می‌خوریم، چون در آن صورت تابع $\mathcal{F}$ مدام به دنباله‌‌هایی که با محیط $\rho$ شروع می‌شوند، می‌افزاید و این یک دنباله‌ی نامتناهی را خواهد ساخت. در صورتی که معنای $\mathsf{B}$ هیچ گاه صحیح نباشد، حداقل حالت 
$\langle at \llbracket \mathsf{S_t} \rrbracket , \rho'' \rangle$
به آخر دنباله‌های پیشین اضافه خواهد شد و از این جهت مطمئن هستیم که دنباله‌ی نامتناهی گفته شده در معنای عبارت‌ دستوری حضور خواهد داشت. 

پس با این تفاصیل، این حالت هم ثابت می‌شود.

$$\blacktriangleright\blacktriangleright \mathsf{S=\; break;}:$$
در تعریف تابع $aft$ روی برچسب‌ها در \cite{calcul} تعریف برای این عبارت‌ دستوری مشخص نیست! در \cite{cousotbook} هم در مورد این برچسب‌ها بحث شده است. در آنجا، گفته شده است که در مورد بخش هایی از تعریف این توابع، که تعریف مشخصی ارائه نشده است، برداشت آزاد است! ما در اینجا سعی داریم، معقول ترین برداشتی که نسبت به درکمان از این کار می‌توانیم داشته باشیم را بیان کنیم. مهم‌ترین چیزی که در مورد برچسب‌ها در این عبارت‌ دستوری باید برقرار باشد، این است که اگر این عبارت‌ دستوری بخشی از $\mathsf{S_t}$ در حلقه‌ی زیر باشد،
$$\mathsf{S'=\; while\; (B)\; S_t}$$
در این صورت، تساوی 
$aft \llbracket \mathsf{S'} \rrbracket = brk-to \llbracket \mathsf{S_t} \rrbracket $
را طبق تعریف خواهیم داشت. انتظار می‌رود که\break 
$aft \llbracket \mathsf{break;} \rrbracket = aft \llbracket \mathsf{S'} \rrbracket$ 
باشد. اینکه اجرای برنامه پس از اجرای $\mathsf{break;}$ بعد از عبارت دستوری $\mathsf{S'}$ پی گرفته شود، انتظار معقولی است از صوری‌گری‌ای که در حال توصیف گردش کار کامپیوتری است. البته در نظر گرفته شود که فرض کرده‌ایم که $\mathsf{S'}$ داخلی ترین حلقه‌ای است که $\mathsf{break;}$ درون آن جای دارد.

 از پس این فرض‌های ما 
$aft \llbracket \mathsf{break;} \rrbracket = break-to \llbracket \mathsf{S_t} \rrbracket$ 
نتیجه می‌شود و طبق معنای عبارت دستوری 
$\mathsf{break;}$،
رد پیشوندی زیر در معنای این عبارت‌ دستوری وجود دارد،
$$\langle at \llbracket \mathsf{break;} \rrbracket , \rho \rangle
\langle aft \llbracket \mathsf{break;} \rrbracket , \rho \rangle$$
 که نشانه‌ی توقف است.
 

$$\blacktriangleright\blacktriangleright \mathsf{S=\; \{ Sl'' \}}:$$
	در این صورت، توقف پذیری $\mathsf{Sl''}$ را از فرض استقرای، استقرای قبلی( روی لیست عبارت‌های دستوری) داریم، پس $\mathsf{\{Sl''\}}$ هم توقف پذیر است.
	
	
در اینجا، اثبات این طرف قضیه به پایان می‌رسد.

($\Leftarrow$)
دوباره باید از استقرا روی ساختار برنامه‌ها استفاده کنیم و دوباره چون هر برنامه‌ای مساوی با یک لیست از عبارت‌های دستوری است، ابتدا از استقرا روی ساختار لیست عبارت‌های و در دل آن روی ساختار خود عبارت‌های دستوری استفاده کنیم.

در این اثبات به غیر از یک حالت ساختار یک عبارت‌ دستوری، که عبارت‌ دستوری حلقه است، هر آنچه در مورد اثبات طرف راست قضیه گفتیم، به ما حکم را بدون نیاز به فرض نشان می‌دهد. بنابراین، فقط در مورد اثبات این یک حالت بحث می‌کنیم: 
$$\blacktriangleright\blacktriangleright \mathsf{S=\; while\; (B)\; S_t}:$$

اگر فرض کنیم این عبارت‌ دستوری به ازای محیط $\rho$ در حالت اول متوقف شده است، در واقع فرض کرده‌ایم که در معنای این عبارت‌ دستوری رد پیشوندی 
$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle \pi \langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle \pi'$ 
وجود دارد.
باید ثابت کنیم، به ازای $\pi'$ دلخواه، اگر رد پیشوندی
$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle \pi \langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle \pi'$ 
داخل 
$\mathcal{S^*}\llbracket \mathsf{S} \rrbracket$
وجود داشته باشد، آنگاه
$\pi'=\epsilon$
برقرار است.

اگر برچسب
$aft \llbracket \mathsf{S} \rrbracket$
در یک وضعیت از رد پیشوندی‌ای که گفتیم، حضور داشته باشد، یعنی در یک دور از اجرای حلقه، عبارت بولی لزوما معنای غلط داشته است. این باعث شده است که یک وضعیت شامل برچسب $aft$ به یک رد پیشوندی چسبانده بشود و درنتیجه، این رد پیشوندی ساخته شده است. از طرفی دیگر هم می‌دانیم که وقتی معنای عبارت بولی حاضر در ساختار حلقه غلط شده باشد، دیگر به ردهای پیشوندی داخل معنای حلقه چیزی اضافه نمی‌شود. بنابراین حالت ممکنی جز $\pi'=\epsilon$ باقی نمی‌ماند. 
\end{proof}

پس با توجه به آنچه گفتیم، می‌توانیم با خیال راحت توقف پذیری یک برنامه با یک محیط اولیه را معادل متناهی بودن همه‌ی ردهای پیشوندی‌ای بدانیم که با محیط متناظر با آن محیط اولیه شروع شده‌اند.
اگر در صورت ارائه شده از وارسی مدل عبارت منظم $\mathsf{R}$ را با عبارت منظم $\varepsilon$ جایگزین کنیم داریم:
$$\mathsf{P},\underline{\rho} \models \mathsf{R}
\Leftrightarrow
(\{\underline{\rho}\}\times \mathcal{S}^* \llbracket \mathsf{P}\rrbracket) \subseteq 
\mathsf{prefix} (\mathcal{S}^r \llbracket \varepsilon \bullet (?:\mathit{T})^*\rrbracket)
=\mathsf{prefix} (\mathcal{S}^r \llbracket (?:\mathit{T})^*\rrbracket)$$
طبق تعریف معنای عبارات منظم، هر رد پیشوندی متناهی‌ای داخل مجموعه‌ی سمت راستی رابطه‌ی زیرمجموعه بودن قرار می‌گیرد. این یعنی اگر الگوریتمی برای بررسی 
$\mathsf{P} , \underline{\rho} \models \mathsf{R} $
داشته باشیم، این \gls*{algorithm} می‌تواند تشخیص دهد که آیا برنامه‌ی $\mathsf{P}$ با محیط اولیه‌ی $\underline{\rho}$ متوقف می‌شود یا خیر. این الگوریتمی است برای مسئله‌ی توقف پذیری، مسئله‌ای که تصمیم ناپذیر است. بنابراین، چنین الگوریتمی نباید وجود داشته باشد که یعنی پیاده سازی‌ای برای روشی که در حال بیانش هستیم وجود ندارد. ادامه‌ی کار روی همین تعریف پیش می‌رود و دو صورت دیگر هم که قرار است ساختارمندتر باشند، در نهایت با این صورت معادل‌اند و در نتیجه تصمیم ناپذیرند.














