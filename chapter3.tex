
\chapter{صوری‌گری جدید برای روش وارسی مدل}

در این فصل، صورت جدیدی برای روش وارسی مدل ارائه ‌می‌شود. در این صورت، برای بیان خاصیت‌های مورد بررسی به‌جای منطق زمانی از عبارات منظم استفاده می‌شود. با صحبت در مورد ویژگی‌های برنامه‌ها در صوری‌گری‌ای که داریم شروع می‌کنیم، سپس به معرفی عبارات منظم، به عنوان یک وسیله برای بیان ویژگی‌ها، می‌پردازیم و پس از آن، صورت روش وارسی مدل را ارائه می‌کنیم. در آخر این فصل نیز، به بحث در مورد تصمیم پذیری این روش می‌پردازیم. 


\section{ویژگی‌های معنایی برنامه‌ها}
تا به اینجای کار، یک زبان آورده‌ایم و برای آن معنا تعریف کرده‌ایم. در این بخش، در مورد ویژگی‌های برنامه‌هایی که در این زبان نوشته می‌شوند، با توجه به معنای صوری‌ای که تعریف کرده‌ایم، صحبت می‌کنیم. برای برنامه‌هایی که در یک زبان برنامه‌نویسی نوشته می‌شوند، می‌توان به اشکال مختلفی ویژگی تعریف کرد. مثلا ویژگی‌های نحوی، مثل این که طول برنامه چند خط است یا هر کاراکتر چند بار به کار رفته است، یا ویژگی‌های محاسباتی، مثل بررسی‌ سرعت برنامه یا میزان استفاده‌ی آن از حافظه که عموما در نظریه الگوریتم و پیچیدگی محاسبات بررسی می‌شود. منظور ما در اینجا از تعریف ویژگی، متناسب است با معناشناسی‌ای که برای برنامه‌هایمان تعریف کرده‌ایم. معناشناسی‌ای که تعریف کرده‌ایم، درواقع سیر محاسباتی برنامه را توصیف می‌کند و ما می‌خواهیم ویژگی‌ها را با توجه به این موضوع تعریف کنیم. در این صورت، می‌توانیم، صحت عملکرد برنامه‌ها را با توجه به صادق بودن ویژگی‌هایی که در مورد آن‌ها تعریف شده بفهمیم.\\
ابتدا به تعریف ویژگی‌ها می‌پردازیم، سپس به سراغ تعریف یک نوع عبارت منظم می‌رویم که از آن برای بیان ویژگی‌ها استفاده می‌شود.
\subsection{ویژگی‌های معنایی}
همان‌طور که در بخش قبلی دیدیم، معنای هر برنامه با یک مجموعه‌ی 
$\mathcal{S^*}\llbracket {\mathsf{S}}\rrbracket$
مشخص می‌شود. وقتی می‌خواهیم ویژگی‌هایی را برای موجوداتی که به کمک مجموعه‌ها تعریف شده اند بیان کنیم، این که ویژگی‌ها را هم با مجموعه‌ها بیان کنیم، کار معقولی به نظر می‌رسد. مثل اینکه بخواهیم ویژگی زوج بودن را در مورد اعداد طبیعی بیان کنیم. می توانیم مجموعه‌ی $\mathbb{E}$ را به عنوان مجموعه‌ی همه‌ی اعداد زوج در نظر بگیریم و این که یک عدد زوج هست یا نه را عضویتش در مجموعه‌ی $\mathbb{E}$ تعریف کنیم. پس یعنی در مورد اعداد طبیعی، هر ویژگی به شکل زیرمجموعه‌ای از تمام این اعداد در نظر گرفته می‌شود. یعنی هر عضو 
$\mathit{P}(\mathbb{N})$
بنا به تعریف ما یک ویژگی از اعداد طبیعی است.
در مورد برنامه‌ها نیز قرار است همین رویه را پیش بگیریم. تابع 
$\mathcal{S^*}$
از نوع 
$\mathbb{P} \rightarrow \mathit{P}(\mathfrak{S^+})$
است. یعنی یک برنامه را در ورودی می‌گیرد و یک مجموعه از ردهای پیشوندی را باز می‌گرداند. پس می‌توانیم، هر ویژگی را به عنوان زیر مجموعه‌ای از 
$\mathit{P}(\mathfrak{S^+})$
تعریف کنیم، به عبارت دیگر عضوی از
$\mathit{P(P}(\mathfrak{S^+}))$.

\subsection{عبارات منظم}
در اینجا، توصیف ویژگی‌ها برای هر برنامه باید یک چارچوب داشته باشد. در صورت قدیمی روش وارسی مدل ما از منطق های زمانی برای بیان ویژگی‌ها به صورت صوری استفاده می‌کردیم و این احتیاج به یک زبان برای صوری کردن کامل کار را، که رسیدن به بیان مسئله‌ی وارسی مدل است، به ما نشان می‌دهد. در اینجا ما با داستان دیگری هم رو به رو هستیم و آن این است که از آنجایی که با مجموعه‌ها سر و کار داریم و مجموعه‌ها چندان موجودات ساختنی‌ای نیستند( برخلاف مدل کریپکی)، بهتر است یک موجود ساختنی مثل یک زبان صوری برای بیان آن‌ها داشته باشیم. در این فصل قصد داریم یک نوع عبارت منظم را برای این منظور تعریف کنیم. پیش‌تر به نکته‌ی دیگری در مورد استفاده از عبارات منظم، که متداول‌تر بودن بین جامعه‌ی برنامه نویسان است، صحبت کردیم. ابتدا زبان این عبارت منظم را تعریف می‌کنیم، سپس به سراغ معناشناسی آن می‌رویم. 
\subsection{زبان عبارات منظم}
فرق عمده‌ای که زبان عبارات منظم ما با عبارات منظم کلاسیک دارد در کاراکترهاست. کاراکترها در زبان کلاسیک موجوداتی اتمی بودند، اما در اینجا، ساختار دارند. در اینجا، به جای هر کاراکتر یک زوج متشکل از مجموعه‌ی $\mathsf{L}$ شامل برچسب‌ها و عبارت بولی $\mathsf{B}$ تشکیل شده‌اند که این زوج را به شکل 
$\mathsf{L : B}$
در زبانمان نمایش می‌دهیم.\\ 
زبان ما به شکل BNF زیر است:
\begin{defn}
$$\mathsf{L} \in \mathit{P}(\mathbb{L})$$        
$$\mathsf{x,y,...} \in \mathbb{X}$$
$$\mathsf{\underline{x},\underline{y},...} \in \mathbb{\underline{X}}$$
$$\mathsf{B} \in \mathbb{B}$$
$$\mathsf{R} \in \mathbb{R}$$
$$\mathsf{R} ::=\hspace{0.5cm} \varepsilon\hspace{4.2cm}$$
$$|\:\:\:\mathsf{L : B}\hspace{2.4cm}$$
$$|\:\:\:\mathsf{R_1 R_2}\:\:\:(or\:\mathsf{R_1 \bullet R_2 })$$
$$\:\:\:\:\:\:\:|\:\:\:\mathsf{R_1\:\mid\:R_2}\:\:\:(or\:\mathsf{R_1 + R_2 })$$
$$|\:\:\:\mathsf{R_1^*}\hspace{2.8cm}$$
$$|\:\:\:\mathsf{R_1^+}\hspace{2.7cm}$$
$$|\:\:\:(\mathsf{R_1})\hspace{2.47cm}$$
\end{defn}
همان طور که قابل مشاهده است، در اینجا، عملگرهای دوتایی چسباندن
$(\bullet)$
 و انتخاب
$(|)$
 را به همراه عملگرهای یگانی 
$^*$
و
$^+$
داریم.
در ادامه، با توجه به معناشناسی عبارات منظم، خواهیم دید که معنی عملگر یگانی 
$^+$
به وسیله‌ی عملگر یگانی $^*$ قابل بیان است.
توجه شود که پرانتزها هم جزئی از زبان قرار داده شده‌اند.


همین‌طور در اینجا، می‌خواهیم از تعدادی عبارات مخفف که در ادامه کارمان را راحت‌تر می‌کنند، صحبت کنیم. منظور از زوج 
$\mathsf{? : B}$
همان 
$\mathbb{L}\mathsf{ : B}$
است. عبارت 
$l : \mathsf{B}$
به جای عبارت 
$\{l\} : \mathsf{B}$
به کار می‌رود و منظور از عبارت 
$\neg l \mathsf{: B}$
نیز عبارت 
$\mathbb{L}\setminus\{l\}:\mathsf{B}$
است.

یک نکته‌ی قابل توجه، با توجه به تعاریف فصل قبل، وجود یک مجموعه به نام
$\mathbb{\underline{X}}$
در کنار 
$\mathbb{X}$
که از قبل داشتیم، است. به ازای هر 
$\mathsf{x}\in\mathbb{X}$
یک 
$\mathsf{\underline{x}}\in\mathbb{\underline{X}}$
داریم. منظور از 
$\mathsf{\underline{x}}$
مقدار متغیر 
$\mathsf{x}$
در ابتدای هر برنامه است. یعنی تابع
$\underline{\rho}: \mathbb{\underline{X}} \rightarrow \mathbb{V}$
که 
$\mathbb{V}$
مجموعه‌ی مقادیر متغیرها است. همان‌طور که پیش‌تر گفتیم، برای اشاره به یک تابع
$\rho$
از کلمه‌ی "محیط" استفاده می‌شود. به همین منوال،برای اشاره‌ به 
$\underline{\rho}$
از "محیط اولیه" استفاده می‌کنیم. برای اشاره به مجموعه‌ی همه‌ی محیط‌های اولیه هم از نماد 
$\underline{\mathbb{EV}}$
استفاده می‌کنیم.
بقیه‌ی موجودات، از جمله برچسب‌ها و عبارات بولی، را در فصل گذشته تعریف کرده‌ایم.\\
در ادامه به بیان صوری معنای زبان بیان شده می‌پردازیم.\\

\subsection{معناشناسی عبارات منظم}
معنای عبارات منظم را با استفاده از تابع 
$\mathcal{S}^r$
نشان می‌دهیم. این تابع به این شکل تعریف می‌شود که در ورودی یک عبارت منظم 
$\mathsf{R}$
را می‌گیرد، سپس یک مجموعه از زوج‌های
$\langle\underline{\rho} , \pi\rangle$
را که 
$\pi \in \mathfrak{S^*}$
و 
$\underline{\rho} \in \underline{\mathbb{EV}}$
باز می‌گرداند. بنابراین این تابع از نوع
$\mathbb{R} \rightarrow \mathit{P} (\mathbb{\underline{EV}} \times \mathfrak{S}^*)$
است.
 منظور از 
 $\mathfrak{S}^*$
 نیز 
 $\mathfrak{S}^+ \cup \{\epsilon\}$
 است.
 
تعریف استقرایی تابع 
$\mathcal{S}^r$
به شکل زیر است:
\begin{defn}
	تابع 
	$\mathcal{S}^r:\mathbb{R}\rightarrow \mathit{P}(\mathbb{\underline{EV}\times \mathfrak{S}}^*)$
	به صورت استقرایی روی ساختار عبارت منظم $\mathsf{R}$ به صورت زیر تعریف می‌شود:
$$\mathcal{S}^r\llbracket\varepsilon\rrbracket= \{ \langle \underline{\rho} , \epsilon \rangle | \underline{\rho} \in \underline{\mathbb{EV}}\}$$
[یعنی معنای عبارت منظم
$\varepsilon$
مجموعه‌ای شامل زوج مرتب‌هایی از محیط‌های اولیه‌ی مختلف در کنار رد پیشوندی تهی است.]
$$\mathcal{S}^r\llbracket\mathsf{L:B}\rrbracket = \{\langle\underline{\rho},\langle l , \rho \rangle \rangle | l \in \mathsf{L} \land \mathcal{B}\llbracket\mathsf{B}\rrbracket \underline{\rho},\rho \}$$
[این یعنی معنای عبارت منظم
$\mathsf{L:B}$
مجموعه‌ای است شامل زوج مرتب‌هایی که عضو اول آن‌ها محیط‌های اولیه مختلف و عضو دوم آن‌ها ردهای پیشوندی تک‌عضوی 
$\langle l , \rho \rangle$
هستند. در این ردهای پیشوندی، برچسب 
$l$
باید در
$\mathsf{L}$
که مجموعه‌ای از برچسب‌هاست حضور داشته باشد. همین طور باید عبارت بولی 
$\mathsf{B}$
درباره‌ی محیط اولیه
$\underline{\rho}$
و محیط 
$\rho$
برقرار باشد. با توجه به حضور محیط‌های اولیه، در اینجا
$\mathcal{B}$
به جای اینکه از نوع 
$\mathbb{EV} \rightarrow \mathbb{BOOL}$
باشد، از نوع
$\underline{\mathbb{EV}} \rightarrow \mathbb{EV} \rightarrow \mathbb{BOOL}$
است( منظور از 
$\mathbb{BOOL}$
همان مجموعه‌ی 
$\{\mathit{T,F}\}$
است). بعد از این تعریف،
$\mathcal{A}$
و 
$\mathcal{B}$
را با در نظر گفتن محیط اولیه دوباره تعریف خواهیم کرد.]
$$\mathcal{S}^r\llbracket\mathsf{R_1 R_2}\rrbracket= \mathcal{S}^r\llbracket\mathsf{R_1}\rrbracket \Join \mathcal{S}^r\llbracket\mathsf{R_2}\rrbracket$$
\begin{center}
	به‌طوری که، با فرض اینکه دو مجموعه‌ی 
	$\mathcal{S}$
	و
	$\mathcal{S'}$
	هر یک معنای یک عبارت منظم باشند:
$$\mathcal{S \Join S'}=
\{
\langle \underline{\rho}, \pi \pi' \rangle |
\langle \underline{\rho},\pi \rangle \in \mathcal{S} \land
\langle \underline{\rho},\pi' \rangle \in \mathcal{S'}
\}
$$
\end{center}
[این یعنی اگر یک عبارت منظم داشته باشیم که از چسباندن 
$\mathsf{R_1}$
و 
$\mathsf{R_2}$
به هم ساخته شده باشد، آنگاه معنای این عبارت منظم از زوج‌هایی تشکیل شده است که مولفه‌ی اول آن‌ها محیط‌های اولیه هستند و مولفه‌ی دوم آن‌ها از چسباندن ردهای پیشوندی موجود در مولفه‌ی دوم اعضای مجموعه‌ی معنای این دو عبارت منظم تشکیل شده است. عملگر $Join$ که برای معنای عبارات منظم تعریف شده است، با تعریف عملگر چسباندن معنای دو برنامه متفاوت است. مورد دوم را در فصل قبل داشتیم که با کمک $\Join$ روی ردهای پیشوندی تعریف می‌شد، اما در تعریفی که در اینجا از $\Join$ ارائه شده است، از عملگر $\Join$ روی ردهای پیشوندی استفاده نشده است.

تا این قسمت از تعریف معنای عبارت منظم که رسیده‌ایم، تا حدی به درکی شهودی از اینکه به چه نحوی قرار است عبارات منظم راهی برای توصیف ویژگی‌ در مورد برنامه‌ها باشند، نزدیک‌تر شده‌ایم. همان‌طور که در مورد قبل دیدیم، هر زوج 
$\mathsf{L:B}$
دقیقا به یک وضعیتْ داخل یک رد پیشوندی اشاره می‌کند. انگار که قرار است این زوج‌ها موازی با وضعیت‌ها در ردهای پیشوندی موجود در معنای یک برنامه جلو روند و انطباق را بررسی کنند تا وارسی مدل انجام شود. درک این موضوع اولین قدم ما در دیدن عصاره‌ی روش وارسی مدل است، در ادبیاتی که از شروع فصل دوم عَلَم کرده‌ایم.]
$$\mathcal{S}^r \llbracket\mathsf{R_1\:|\:R_2}\rrbracket= 
\mathcal{S}^r \llbracket R_1\rrbracket \cup
\mathcal{S}^r \llbracket R_2\rrbracket$$
[این مورد، معنای اعمال عملگر انتخاب روی دو عبارت منظم را توصیف می‌کند. معنای اعمال این عملگر به صورت اجتماع معنای هر دو عبارت منظم تعریف شده.]

$$\mathcal{S}^r \llbracket\mathsf{R}\rrbracket^0 = \mathcal{S}^r\llbracket\varepsilon\rrbracket$$
$$\mathcal{S}^r \llbracket\mathsf{R}\rrbracket^{n+1} = \mathcal{S}^r \llbracket\mathsf{R}\rrbracket^{n} \Join
\mathcal{S}^r \llbracket\mathsf{R}\rrbracket$$
[دو عبارت اخیر برای توصیف معنای عملگرهای $^*$ و $^+$ تعریف شده‌اند. عملگر $\Join$ و معنای 
$\mathcal{S}^r\llbracket\varepsilon\rrbracket$
را هم که قبلا تعریف کرده بودیم و $0$ و $n$ هم اعداد طبیعی‌اند.]
$$\mathcal{S}^r\llbracket\mathsf{R^*}\rrbracket =  \bigcup_{n \in \mathbb{N}}
\mathcal{S}^r \llbracket\mathsf{R}^n\rrbracket$$
$$\mathcal{S}^r\llbracket\mathsf{R^+}\rrbracket =  \bigcup_{n \in \mathbb{N}\setminus\{0\}}
\mathcal{S}^r \llbracket\mathsf{R}^n\rrbracket$$
[این دو عبارت هم تعریف معنای دو عملگر $^*$ و $^+$ هستند. منظور از $\mathbb{N}$ مجموعه‌ی اعداد طبیعی است. همان‌طور که قبل‌تر هم اشاره شد $^+$ را می‌توان با $^*$ تعریف کرد. اضافه می‌کنیم که $^*$ را در فرازبان( و نه در زبان عبارات منظم) می‌توان با عملگر انتخاب تعریف کرد.]

$$\mathcal{S}^r \llbracket(\mathsf{B})\rrbracket=\mathcal{S}^r \llbracket\mathsf{B}\rrbracket$$
[این قسمت از تعریف هم صرفا بیان می‌کند که پرانتزها تاثیری در معنای عبارات منظم ندارند که کاملا قابل انتظار است، چرا که وجود پرانتز قرار است صرفا در خواص نحوی زبان اثر بگذارد.]
\end{defn}
تعریف معنای عبارات منظم در اینجا تمام می‌شود، اما همان‌گونه که در لا‌به‌لای تعاریف گفته‌شد، احتیاج داریم که $\mathcal{A}$ و $\mathcal{B}$ را از نو تعریف کنیم:
\begin{defn}
	توابع 
	$\mathcal{A}:\mathbb{A}\rightarrow \mathbb{\underline{EV}} \rightarrow
	\mathbb{EV} \rightarrow \mathbb{V}$
	و 
	$\mathcal{B}:\mathbb{B}\rightarrow \mathbb{\underline{EV}} \rightarrow
	\mathbb{EV} \rightarrow \mathbb{BOOL}$
	به شکل استقرایی به ترتیب روی ساختارهای 
	$\mathsf{A}\in\mathbb{A}$
	و
	$\mathsf{B} \in \mathbb{B}$
	به شکل زیر تعریف می‌شوند:
	
	
$$\mathcal{A}\llbracket\mathsf{1}\rrbracket\underline{\rho},\rho=1$$
$$\mathcal{A}\llbracket\mathsf{\underline{\mathsf{x}}}\rrbracket\underline{\rho},\rho= \underline{\rho}(\mathsf{x})$$
$$\mathcal{A}\llbracket\mathsf{\mathsf{x}}\rrbracket\underline{\rho},\rho= \rho(\mathsf{x})$$
$$\mathcal{A}\llbracket\mathsf{A_1 - A_2}\rrbracket\underline{\rho},\rho= 
\mathcal{A}\llbracket\mathsf{A_1}\rrbracket\underline{\rho},\rho - \mathcal{A}\llbracket\mathsf{A_2}\rrbracket\underline{\rho},\rho$$
$$\mathcal{B}\llbracket\mathsf{A_1 < A_2}\rrbracket\underline{\rho},\rho=
	\mathcal{A}\llbracket\mathsf{A_1}\rrbracket\underline{\rho},\rho\: <\: \mathcal{A}\llbracket\mathsf{A_2}\rrbracket\underline{\rho},\rho$$
$$\mathcal{B}\llbracket\mathsf{B_1\:nand\:B_2}\rrbracket\underline{\rho},\rho=
\mathcal{B}\llbracket\mathsf{B_1}\rrbracket\underline{\rho},\rho \uparrow 
\mathcal{B}\llbracket\mathsf{B_2}\rrbracket\underline{\rho},\rho $$
\end{defn}
به‌راحتی قابل مشاهده است که تعاریف جدید تا حد خوبی به تعاریف قبلی شبیه هستند و فرق عمده صرفا وارد شدن $\underline{\rho}$ است.\\

حال که معناشناسی عبارات منظم را داریم، به طور مختصر به مقایسه‌ی عبارات منظمی که در این بحث تعریف کرده‌ایم و عبارات منظم کلاسیک در باقی نوشته‌ها و موضوعات می‌پردازیم. جبر کلاینی یک ساختار جبری است که تعمیمی است از عبارات منظم معرفی شده در \cite{kleene56}. سر و کله‌ی عبارات منظم در قسمت‌های مختلفی از علوم کامپیوتر پیدا می‌شود، اما با تعاریفی نامعادل. هدف از ارائه‌ی جبر کلاینی این بوده است که تعمیمی باشد که این تعاریف نابرابر را در خود جای می‌دهد. در \cite{DexterKleene} آمده است که برای جبر کلاینی هم تعاریف متفاوتی که با هم برابر نیستند، معرفی شده است. علاوه بر این، این مقاله به بررسی این تعاریف و ارتباطشان با یکدیگر پرداخته است. همین طور، این مقاله خود با یک تعریف از جبر کلاینی شروع کرده است. طبق این تعریف، اگر عبارات منظمی که در اینجا تعریف کرده‌ایم، یک جبر کلاینی می‌بودند، می‌بایستی که برای هر عبارت منظم $\mathsf{R}$ می‌داشتیم
$\mathcal{S}^r \llbracket \mathsf{\varepsilon R} \rrbracket = \mathcal{S}^r \llbracket \mathsf{\varepsilon} \rrbracket$،
چون $\varepsilon$ نقش صفر عملگر چسباندن( که عملگر ضرب جبر کلاینی است) را دارد و یک جبر کلاینی برای صفر خاصیت جذب را به عنوان یک اصل دارد. اما در مورد عبارات منظمی که در اینجا تعریف کردیم داریم 
$\mathcal{S}^r \llbracket \mathsf{\varepsilon R} \rrbracket = \mathcal{S}^r \llbracket \mathsf{R} \rrbracket$.
بیشتر از این به این بحث نمی‌پردازیم که بحث دامنه‌دار و منحرف کننده‌ایست. یک قضیه را در مورد عبارات منظم ارائه می‌دهیم که پخش پذیری عملگر انتخاب به عملگر چسباندن است و بعد به ادامه‌ی راه اصلیمان می‌پردازیم.
\begin{thm}
	برای عبارات منظم
	 $\mathsf{R , R}_1,\mathsf{R}_2$
	 داریم:
	  $$\mathcal{S}^r \llbracket \mathsf{R}\bullet (\mathsf{R}_1 + \mathsf{R}_2) \rrbracket = \mathcal{S}^r \llbracket (\mathsf{R \bullet R}_1) + (\mathsf{R \bullet R}_2) \rrbracket $$
\end{thm}

\begin{proof}
	$$\mathcal{S}^r \llbracket \mathsf{R}\bullet (\mathsf{R}_1 + \mathsf{R}_2) \rrbracket =\mathcal{S}^r \llbracket \mathsf{R} \rrbracket \Join \mathcal{S}^r \llbracket (\mathsf{R}_1+\mathsf{R}_2) \rrbracket$$
	$$=\mathcal{S}^r \llbracket \mathsf{R} \rrbracket \Join \mathcal{S}^r \llbracket \mathsf{R}_1+\mathsf{R}_2 \rrbracket=\mathcal{S}^r \llbracket \mathsf{R} \rrbracket \Join (\mathcal{S}^r \llbracket \mathsf{R}_1 \rrbracket \cup \mathcal{S}^r\llbracket \mathsf{R}_2 \rrbracket)$$
	$$= \{ \langle \underline{\rho}, \pi \pi' \rangle| \langle \underline{\rho}, \pi \rangle \in \mathcal{S}^r \llbracket \mathsf{R} \rrbracket \land (\langle \underline{\rho},\pi'\rangle \in \mathcal{S}^r \llbracket \mathsf{R}_1 \rrbracket\lor \langle \underline{\rho} , \pi' \rangle \in \mathcal{S}^r \llbracket \mathsf{R}_2 \rrbracket) \}$$
	$$=\{ \langle \underline{\rho}, \pi \pi' \rangle| (\langle \underline{\rho}, \pi \rangle \in \mathcal{S}^r \llbracket \mathsf{R} \rrbracket \land \langle \underline{\rho},\pi'\rangle \in \mathcal{S}^r \llbracket \mathsf{R}_1 \rrbracket) \lor (\langle \underline{\rho}, \pi \rangle \in \mathcal{S}^r \llbracket \mathsf{R} \rrbracket \land \langle \underline{\rho} , \pi' \rangle \in \mathcal{S}^r \llbracket \mathsf{R}_2 \rrbracket  \}$$
	$$=\{ \langle \underline{\rho}, \pi \pi' \rangle|\langle \underline{\rho}, \pi \rangle \in \mathcal{S}^r \llbracket \mathsf{R} \rrbracket \land \langle \underline{\rho},\pi'\rangle \in \mathcal{S}^r \llbracket \mathsf{R}_1 \rrbracket\} \cup
	\{ \langle \underline{\rho}, \pi \pi' \rangle|\langle \underline{\rho}, \pi \rangle \in \mathcal{S}^r \llbracket \mathsf{R} \rrbracket \land \langle \underline{\rho},\pi'\rangle \in \mathcal{S}^r \llbracket \mathsf{R}_2 \rrbracket\}$$
	$$=(\mathcal{S}^r \llbracket \mathsf{R} \rrbracket \Join \mathcal{S}^r \llbracket \mathsf{R}_1\rrbracket ) \cup (\mathcal{S}^r \llbracket \mathsf{R} \rrbracket \Join \mathcal{S}^r \llbracket \mathsf{R}_2 \rrbracket)=
	\mathcal{S}^r \llbracket \mathsf{R\bullet R}_1 \rrbracket \cup \mathcal{S}^r \llbracket \mathsf{R\bullet R}_2 \rrbracket$$
	$$=\mathcal{S}^r \llbracket (\mathsf{R \bullet R}_1) + (\mathsf{R \bullet R}_2) \rrbracket $$
\end{proof}
تا اینجای کار، بیشتر مفاهیمی که برای بیان صورت جدید مسئله‌ی وارسی مدل احتیاج داریم را بیان کرده‌ایم. 
\subsection{گونه‌های مختلف زبان عبارات منظم}
به عنوان قسمت آخر این بخش، گونه‌های مختلفی از زبان عبارات منظم را بیان می‌کنیم که هر کدام در واقع زیرمجموعه‌ای از کل زبانی که توصیف کرده‌ایم را تشکیل می‌دهند. بعضی از آن‌ها را در همین فصل، برای هدف نهایی این فصل و بعضی دیگر را در فصل بعدی استفاده می‌کنیم.

اولین گونه‌ای که می‌خواهیم بیان کنیم، گونه‌ای است که در اعضای آن اصلا عبارت 
$\mathsf{L : B}$
حضور ندارد و کل عبارت‌های زبان از $\varepsilon$ ها تشکیل شده‌اند.
\begin{defn}
	(عبارت منظم تهی - $\mathbb{R_\varepsilon}$): 
	$$\mathsf{R} \:\:\:\in\:\:\: \mathbb{R}_\varepsilon$$
	$$\mathsf{R}\:\:\: ::= \:\:\: \varepsilon \: | \: \mathsf{R_1 R_2} \: | 
	\: \mathsf{R_1 + R_2} \: | \: \mathsf{R_1^*} \: | \: \mathsf{R_1^+} | (\mathsf{R_1})$$
\end{defn}


 با توجه به بخش قبل، معنای همه‌ی این عبارت‌ها برابر 
$\{\langle \underline{\rho} , \epsilon \rangle\}$
خواهد بود.

گونه‌ی بعدی عبارت منظم ناتهی است.
\begin{defn}
	(عبارت منظم ناتهی - $\mathbb{R}^+$):
	$$\mathsf{R} \:\:\:\in\:\:\: \mathbb{R}^+$$
	$$\mathsf{R}\:\:\: ::= \:\:\: \mathsf{L:B} \: |
	\: \mathsf{\varepsilon R_2} \: | \: \mathsf{R_1 \varepsilon} \: |
	\: \mathsf{R_1 R_2} \: | 
	\: \mathsf{R_1 + R_2} \: | \: \mathsf{R_1^+} | (\mathsf{R_1})$$
\end{defn}
دلیل وجود 
$\mathsf{\varepsilon R_2}$
و 
$\mathsf{R_1 \varepsilon}$
در تعریف این است که ممکن است معنای عبارتی در این زبان با ${\langle \underline{\rho} , \epsilon \rangle}$ برابر نباشد، اما در خود عبارت، $\varepsilon$ حضور داشته باشد. با این تفاصیل می‌توان دید که دو مجموعه‌ی 
$\mathbb{R}_\varepsilon$
و
$\mathbb{R}^+$
یک افراز برای مجموعه‌ی $\mathbb{R}$ هستند، چونکه معنای هر عبارت در $\mathbb{R}$ یا با ${\langle \underline{\rho} , \epsilon \rangle}$ برابر هست یا نیست. بنابراین شاید به نظر برسد که تعریف یکی از آن‌ها به طور ساختاری کافی باشد. اما این‌طور نیست، چون ممکن است که درجایی احتیاج داشته باشیم که تعریفی استقرایی روی هر یک از این دو زبان ارائه دهیم، یا اینکه در اثبات حکمی بخواهیم از استقرا روی یکی از این دو ساختار استفاده کنیم.

گونه‌ی آخر عبارات منظم ما نیز عبارات منظم بدون انتخاب است.
\begin{defn}
(عبارت منظم بدون انتخاب - $\mathbb{R}^\nmid$):
$$
\mathsf{R}\:\:\: \in \:\:\: \mathbb{R}^\nmid$$
$$
\mathsf{R}\:\:\: ::= \:\:\: \varepsilon \: | \: \mathsf{L:B} \: | \:
\mathsf{R_1 R_2} \: | \: \mathsf{R_1}^* \: | \: \mathsf{R_1}^+ \: | \:
(\mathsf{R_1})$$
\end{defn}

\section{صورت جدید مسئله‌ی وارسی مدل}
بالاخره، به هدف نهایی این فصل رسیدیم. می‌خواهیم صورت جدیدی از مسئله‌ی وارسی مدل را بیان ‌کنیم.\\
پیش از ارائه‌ی تعریف وارسی مدل، نیاز داریم که عملگر بستار پیشوندی را برای یک مجموعه از ردهای پیشوندی معرفی کنیم.
\begin{defn}
	(بستار پیشوندی):
	اگر 
	$\Pi \in \mathit{P}(\mathbb{\underline{EV}\times \mathfrak{S}^+})$،
	آنگاه بستار پیشوندی $\Pi$را به صورت زیر تعریف می‌کنیم:
	$$\mathsf{prefix}(\Pi)=
	\{\langle \underline{\rho},\pi\rangle | \pi \in \mathfrak{S^+} \land \exists\
	\pi' \in \mathfrak{S^*}: \langle \underline{\rho}, \pi \pi' \rangle \in \Pi \}$$
\end{defn}

برای درک بهتر مفهوم بستار پیشوندی به مثال زیر توجه شود.
\begin{exm}
	اگر 
	$\Pi = \{\langle\underline{\rho},\langle l_1 , \rho_1 \rangle 
	\langle l_2  \rho_2 \rangle\rangle  \langle l_3 , \rho_3 \rangle\rangle 
	,
	\langle\underline{\rho},\langle {l_1}' , {\rho_1}' \rangle  \langle {l_2}'  {\rho_2}' \rangle\rangle
	\}$
	باشد( $\Pi$ شامل دو عضو است)، آنگاه:
	$$
	\mathsf{prefix}(\Pi)=
	\{
	\langle\underline{\rho},\langle l_1 , \rho_1 \rangle\rangle ,
	\langle\underline{\rho},\langle l_1 , \rho_1 \rangle  \langle l_2  \rho_2 \rangle\rangle,
	\langle\underline{\rho},\langle l_1 , \rho_1 \rangle  \langle l_2  \rho_2 \rangle  \langle l_3 , \rho_3 \rangle\rangle ,$$
	$$
	\langle\underline{\rho},\langle {l_1}' , {\rho_1}' \rangle\rangle,
	\langle\underline{\rho},\langle {l_1}' , {\rho_1}' \rangle  \langle {l_2}'  {\rho_2}' \rangle\rangle
	\}
	$$
	که شامل 5 عضو است.
\end{exm}
حال به ارائه‌ی صورت جدیدمان از روش وارسی مدل می‌رسیم.
\begin{defn}
(وارسی مدل):
	اگر 
	$\mathsf{P}\in\mathbb{P} , \mathsf{R} \in \mathbb{R}^+ , \underline{\rho} \in \underline{\mathbb{EV}}$
	آنگاه:
	$$\mathsf{P},\underline{\rho} \models \mathsf{R}
	 \Leftrightarrow
	(\{\underline{\rho}\}\times \mathcal{S}^* \llbracket\mathsf{P}\rrbracket) \subseteq 
	\mathsf{prefix} (\mathcal{S}^r \llbracket\mathsf{R} \bullet (?:\mathit{T})^*\rrbracket)
	$$
\end{defn}

این تعریف بیان می‌کند که اگر برنامه‌ی 
$\mathsf{P}$
با محیط اولیه‌ی 
$\underline{\rho}$
اجرا شود، این برنامه در صورتی خاصیتی که با عبارت منظم 
$\mathsf{R}$
بیان شده را دارد که معنای آن زیرمجموعه‌ی بستار پیشوندی معنای عبارت منظم
$\mathsf{R} \bullet (?:\mathit{T})^*$
باشد.
توجه شود که محیط اولیه‌ای که برای برنامه‌ی مورد بررسی متصور هستیم، صرفا به این منظور در تعریف قرار داده شده است که معناشناسی برنامه را بتوانیم با معنای عبارات منظم قابل قیاس کنیم. دلیل حضور محیط اولیه در معنای عبارات منظم نیز در صورت سوم روش وارسی مدل مشخص می‌شود، یعنی جایی که وارسی مدل روی ساختار برنامه تعریف شده است و ردهای پیشوندی موجود در هر قسمت از برنامه با محیط متفاوتی شروع می‌شوند و اطلاعات محیط اولیه‌ی برنامه در این ردها حضور ندارد (با اینکه ممکن است به آن نیاز داشته باشیم). در این صورت از روش وارسی مدل و صورت بعدی، محیط‌های اولیه صرفا حضور دارند و در عمل نقش مهمی ندارند. 

در مورد نقش 
$ (?:\mathit{T})^*$
و
$ \mathsf{prefix} $
نیز می‌توان گفت، بنا به تصمیم مبدع این روش، اگر یک رد پیشوندی، همه‌ی زوج‌های 
$\mathsf{L:B}$
را ارضا کند و بدون اینکه با هیچ کدام از آن‌‌ها ناسازگاری‌ای داشته باشد به اتمام برسد، درحالیکه هنوز عبارت منظم به اتمام نرسیده است، این رد پیشوندی با خاصیت بیان شده با عبارت منظم را دارد. این نکته صرفا در مورد حضور 
$\mathsf{prefix}$ 
بود. حضور 
$(?:\mathit{T})^*$
نیز باعث می‌شود اگر طول عبارت منظم مورد بررسی کمتر از رد پیشوندی بود و ناسازگاری‌ای مشاهده نشده بود، رد پیشوندی دارای خاصیت $\mathsf{R}$ در نظر گفته شود.
\section{در مورد توقف پذیری}

در این بخش نکته‌ای در مورد کار که به نظر نگارنده رسیده مطرح شده. اگر صحبت ما در اینجا درست باشد، این به این معنی خواهد بود که کل کاری که در حال توصیفش هستیم قابل پیاده سازی نیست!

بحث ما در اینجا در مورد توقف پذیری است. در \cite{calcul} در مورد توقف یک برنامه صحبتی به میان نیامده. یعنی حتی گفته نشده که در چه صورتی می‌توانیم بگوییم که یک برنامه متوقف شده است. یک تعریف  صوری معقول که خودمان می‌توانیم برای این معنا بیاوریم این است:

\begin{defn}
(توقف پذیری:) برنامه‌ی $\mathsf{P}$ را به همراه اجرای اولیه $\underline{\rho}$ توقف پذیر می‌گوییم اگر و تنها اگر وجود داشته باشد 
	$\pi \in \mathcal{S}^* \llbracket \mathsf{P} \rrbracket$ 
	که ($\rho$ محیط متناظر با محیط اولیه‌ی $\underline{\rho}$ است.):
	$$\pi = \langle at \llbracket \mathsf{P} \rrbracket , \rho \rangle \pi'$$
	و اینکه $\langle aft\llbracket \mathsf{P} \rrbracket , \rho' \rangle$ در $\pi$ حضور داشته باشد. این اتفاق را با 
	$\mathsf{P,\underline{\rho}\downarrow}$
	نشان می‌دهیم. همین تعریف را برای لیست دستورات $\mathsf{Sl}$ یا دستور $\mathsf{S}$ هم صرفا با جایگذاری این‌ها با برنامه‌ی $\mathsf{P}$ داریم.
\end{defn} 
در این تعریف توقف پذیری صرفا برای یک محیط اولیه تعریف شده.
در اینجا توقف پذیری به متناهی بودن ردهای پیشوندی موجود در برنامه ربط داده نشده. با توجه به معناشناسی‌ای که داریم، تعریف توقف پذیری به معنای وجود رد پیشوندی متناهی با محیط اولیه‌ی مورد بررسی در معنای برنامه که اصلا جور در نمی‌آید، چون معناشناسی ما خاصیت پیشوندی بودن را دارد و مطمئن هستیم در معنای هر برنامه‌ای حتما یک رد پیشوندی متناهی با محیط اولیه‌ی مورد بررسی وجود دارد.

اگر هم بخواهیم تعریف توقف پذیری را وجودنداشتن ردهای پیشوندی نامتناهی با محیط اولیه‌ی مورد بررسی در معنای برنامه در نظر بگیریم در ابتدا به نظر می‌آید که به تعریف قوی‌تری نسبت به آنچه ارائه دادیم رسیده‌ایم. ما در اینجا سعی داریم تعریفی را ارائه کنیم که برای حرف‌هایی که در \cite{calcul} زده شده تا حد امکان مشکل درست نکند، که اگر دیدیم با این وجود مشکل وجود دارد مطمئن باشیم که اشتباه در \cite{calcul} است و نه حرف ما. پس سعی از ارائه‌ی این تعریف که به نظر از تعریف ارائه شده با کار ناسازگارتر می‌آید اجتناب می‌کنیم( در ادامه به بیان ناسازگاری پراخته شده) اما در قضیه‌ی بعدی می‌بینیم که تعریفی که ارائه کردیم با همان که بگوییم در برنامه رد پیشوندی نامتناهی وجود ندارد معادل است.
\begin{thm}
	برای برنامه‌ی $\mathsf{P}$ و محیط اولیه‌ی $\underline{\rho}$ داریم $\mathsf{P} , \underline{\rho} \downarrow $ اگر و تنها اگر با فرض اینکه $\rho$ محیط متناظر با محیط اولیه‌ی $\underline{\rho}$ است و
	$$\forall \pi \in \mathbb{S^{+}} : 
	\langle at \llbracket \mathsf{P} \rrbracket , \rho \rangle \pi \in \mathcal{S^*} \llbracket \mathsf{P} \rrbracket \rightarrow
	\langle at \llbracket \mathsf{P} \rrbracket , \rho \rangle \pi \in \mathbb{R^+}$$
	 
\end{thm}
\begin{proof}
	$(\Rightarrow)$
	برای این قسمت باید ثابت کنیم که در معنای هر برنامه‌ای رد پیشوندی‌ای وجود دارد که با
	$\langle at\llbracket \mathsf{P} \rrbracket , \rho \rangle$
	شروع شده و به ازای یک محیط $\rho'$ به 
	$\langle aft\llbracket \mathsf{P} \rrbracket , \rho' \rangle$
	ختم شده. 
	در این اثبات از تعریف برچسب‌ها که در ضمیمه‌ی \cite{calcul} آمده استفاده شده.
	داریم 
	$\mathsf{P=Sl}$
	و 
	$aft \llbracket \mathsf{P} \rrbracket = aft \llbracket \mathsf{Sl} \rrbracket $
	
	حکم را با استقرا روی ساختار $\mathsf{Sl}$ ثابت می‌کنیم. 
	$$\blacktriangleright \mathsf{Sl = \backepsilon}:$$
	داریم:
	$$\mathcal{S^*} \llbracket \backepsilon \rrbracket = \{\langle at \llbracket \backepsilon \rrbracket , \dot{\rho} \rangle | \dot{\rho} \in \mathbb{EV}\}$$
	و طبق تعریف برچسب‌ها داریم:
	$$at \llbracket \backepsilon \rrbracket = aft \llbracket \backepsilon \rrbracket$$
	پس حکم برقرار است.
	$$\blacktriangleright \mathsf{Sl =Sl'\;S}:$$
	اینکه در معنای $\mathsf{Sl}$ دنباله‌ای شامل
	 $\langle aft \llbracket \mathsf{Sl} \rrbracket , \rho '\rangle$ وجود داشته باشد، به با توجه به تعاریفی که داریم به این وابسته است که در معنای $\mathsf{S}$ دنباله‌ای شامل $\langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle$ وجود داشته باشد. برای اینکه این را ثابت کنیم هم باید همین حکم را روی ساختار $\mathsf{S}$ ثابت کنیم که در واقع بخش اصلی اثبات این سمت قضیه است. 
	$$\blacktriangleright\blacktriangleright \mathsf{S\;=\; x\doteq A;}:$$
	در این حالت با توجه به تعریف معنای $\mathsf{S}$ که قبل‌تر ارائه شد، دنباله‌ی 
	$$\langle at \llbracket \mathsf{S} \rrbracket ,\rho \rangle \langle aft\llbracket\mathsf{S}\rrbracket , \rho[\mathsf{x}\leftarrow \mathcal{A}\llbracket\mathsf{A}\rrbracket\rho] \rangle $$
	در معنای دستور به ازای هر $\rho$ وجود دارد که خب در هر صورت این شامل محیط متناظر با $\underline{\rho}$ هم می‌شود .
	$$\blacktriangleright\blacktriangleright \mathsf{S=\; ; \;\;}:$$	 
با توجه به معنای این دستوردنباله‌ی زیر در معنای این دستور وجود دارد.
$$\langle at \llbracket \mathsf{S} \rrbracket ,\rho \rangle \langle aft\llbracket\mathsf{S}\rrbracket , \rho \rangle $$

$$\blacktriangleright\blacktriangleright \mathsf{S=\; if\;(B)\;S_t}:$$
	در صورتی که 
	$\mathcal{B}\llbracket\mathsf{B}\rrbracket\rho=\mathit{T}$
	دنباله‌ی 
	$$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle
	\langle at \llbracket \mathsf{S_t} \rrbracket , \rho \rangle \pi$$
	در مجموعه‌ی معنای این دستور حضور دارد در حالیکه 
	$\langle at \llbracket \mathsf{S_t} \rrbracket , \rho \rangle \pi$
	داخل معنای $\mathsf{S_t}$ است و طبق فرض استقرا می‌دانیم که برچسب آخرین موقعیت $\pi$ برابر است با $aft \llbracket \mathsf{S_t} \rrbracket$ که طبق تعاریف مربوط به برچسب‌ها 
	$aft \llbracket \mathsf{S_t} \rrbracket=aft \llbracket \mathsf{S} \rrbracket$.
	در صورتی که معنای عبارت بولی غلط باشد هم دنباله‌ی زیر در معنای دستور طبق تعریف موجود است.
	$$\langle at \llbracket \mathsf{S} \rrbracket ,\rho \rangle \langle aft\llbracket\mathsf{S}\rrbracket , \rho \rangle $$
	
$$\blacktriangleright\blacktriangleright \mathsf{S=\; if\;(B)\;S_t\;else\;S_f}:$$
مانند حالت قبل است منتها با این تفاوت که در صورتی که معنای عبارت بولی غلط باشد دنباله‌ی زیر در معنای دستور حضور دارد:
	$$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle
\langle at \llbracket \mathsf{S_f} \rrbracket , \rho \rangle \pi$$
و تساوی 
$aft \llbracket \mathsf{S_t} \rrbracket=aft \llbracket \mathsf{S} \rrbracket=aft \llbracket \mathsf{S_f} \rrbracket$
هم طبق تعریف برچسب‌ها برقرار است.

$$\blacktriangleright\blacktriangleright \mathsf{S=\; while\;(B)\;S_t}:$$
در اثبات این سمت قضیه این حالت پیچیده ترین حالت است و در واقع تنها حالتی است که در اثبات آن به فرض قضیه احتیاج داریم! همان طور که پیشتر گفتیم معنای حلقه با استفاده از یک تابع تعریف می‌شود. معنای حلقه کوچکترین نقطه ثابت این تابع است، در حالیکه انگار این تابع وقتی روی یک مجموعه از ردهای پیشوندی اعمال شود، تاثیرات یک بار اجرای دستورات درون حلقه را روی ردهای پیشوندی درون مجموعه اعمال می‌کند.

طبق تعریف $\mathcal{F}$ مطمئن هستیم که رد پیشوندی‌ای که با محیط $\underline{\rho}$ شروع شود در مجموعه‌ی معنای $\mathsf{S}$ وجود دارد، چونکه به ازای هر محیط $\dot{\rho}$(نقطه به این خاطر است که با $\rho$ خاص موجود در فرض اشتباه گرفته نشود) حالت 
$\langle at \llbracket \mathsf{S} \rrbracket, \dot{\rho} \rangle$
 در هر اعمال تابع $\mathcal{F}$ روی هر مجموعه‌ی دلخواه وجود دارد. وقتی معنای $\mathsf{S}$ را به عنوان کوچک‌ترین نقطه ثابت $\mathcal{F}$ در نظر گرفته‌ایم پس مطمئن هستیم که آن مجموعه‌ای که کوچکترین نقطه ثابت است شامل رد پیشوندی 
 $\langle at \llbracket \mathsf{S} \rrbracket, \rho \rangle$
 است. این رد پیشوندی با اجرای $\mathcal{F}$ تحت تاثیر قرار می‌گیرد. اگر معنای $\mathsf{B}$ در یکی از اعمال های $\mathcal{F}$ غلط باشد، رد پیشوندی
$ \langle at \llbracket \mathsf{S} \rrbracket, \rho \rangle \pi \langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle$ 
در معنای برنامه قرار خواهد گرفت و می‌توانیم بگوییم اجرای دستور با این محیط اولیه توقف پذیر است. می‌دانیم که طبق تعریف تابع به انتهای این رد پیشوندی چیزی اضافه نمی‌شود. از طرف دیگر هم با این محیط اولیه، با توجه به تعریف رد پیشوندی دیگری وجود ندارد که طولانی‌تر از رد پیشوندی مورد اشاره باشد. 

در حالت دیگر اگر فرض کنیم هیچ گاه به حالتی نمی‌رسیم که در آن معنای $\mathsf{B}$ غلط باشد هم با فرض مسئله به تناقض می‌خوریم، چون در آن صورت تابع $\mathcal{F}$ مدام به طول دنباله‌‌هایی که با محیط $\rho$ شروع می‌شوند می‌افزاید و این یک دنباله‌ی نامتناهی را خواهد ساخت. در صورتی که معنای $\mathsf{B}$ هیچ گاه صحیح نباشد، حداقل حالت 
$\langle at \llbracket \mathsf{S_t} \rrbracket , \rho'' \rangle$
به ته دنباله‌های پیشین اضافه خواهد شد و از این جهت مطمئن هستیم که دنباله‌ی نامتناهی گفته شده در معنای دستور حضور خواهد داشت. 

پس با این تفاصیل، این مورد هم ثابت می‌شود.

\break$$\blacktriangleright\blacktriangleright \mathsf{S=\; break;}:$$
در تعریف تابع $aft$ روی برچسب‌ها در \cite{calcul} این تعریف برای این دستور مشخص نیست! در \cite{cousotbook} که در مورد برچسب‌ها بحث شده، نویسنده‌ی \cite{calcul} گفته که در مورد آن بخش از تعاریف توابع مربوط به برچسب‌ها که تعریف نشده‌اند برداشت آزاد است و ما در اینجا سعی داریم معقول ترین برداشتی که نسبت به درکمان از این کار می‌توانیم داشته باشیم را بیان کنیم. مهم‌ترین چیزی که در مورد برچسب‌ها در مورد این دستور قرار است برقرار باشد این است که اگر این دستور بخشی از $\mathsf{S_t}$ در حلقه‌ی زیر باشد
$$\mathsf{S'=\; while\; (B)\; S_t}$$
در این صورت 
$aft \llbracket \mathsf{S'} \rrbracket = brk-to \llbracket \mathsf{S_t} \rrbracket $
را طبق تعریف داریم. انتظار می‌رود که\break 
$aft \llbracket \mathsf{break;} \rrbracket = aft \llbracket \mathsf{S'} \rrbracket$ 
باشد. اینکه دستورات برنامه پس از اجرای $\mathsf{break;}$ از خارج(یا به عبارت بهتر بعد از) حقله‌ی $\mathsf{S'}$ پی گرفته شود انتظار معقولی است از سیستمی که در حال توصیف رد اجرای برنامه‌های کامپیوتری است. البته در نظر گرفته شود که فرض کرده‌ایم که $\mathsf{S'}$ داخلی ترین حلقه‌ای است که $\mathsf{break;}$ درون آن جای دارد.

 از پس این فرض‌های ما 
$aft \llbracket \mathsf{break;} \rrbracket = break-to \llbracket \mathsf{S_t} \rrbracket$ 
نتیجه می‌شود و طبق تعریف معنای دستورات 
$\mathsf{break;}$
رد پیشوندی زیر در معنای این دستور وجود دارد
$$\langle at \llbracket \mathsf{break;} \rrbracket , \rho \rangle
\langle aft \llbracket \mathsf{break;} \rrbracket , \rho \rangle$$
 که نشانه‌ی توقف است.
 

$$\blacktriangleright\blacktriangleright \mathsf{S=\; \{ Sl'' \}}:$$
	در این صورت توقف پذیری $\mathsf{Sl''}$ را از فرض استقرای استقرایی که روی لیست دستورات زده بودیم داریم پس $\mathsf{\{Sl''\}}$ هم توقف پذیر است.
	
	
در اینجا اثبات این طرف قضیه به پایان می‌رسد.

($\Leftarrow$)
دوباره باید روی ساختار برنامه‌ها استقرا بزنیم و دوباره چون هر برنامه مساوی با یک لیست از دستورات است استقرا را ابتدا روی ساختار لیست دستورات و در دل آن روی ساختار دستورات استقرا می‌زنیم.

در این اثبات به غیر از یک حالت ساختار دستور، که دستور حلقه است، هر آنچه در مورد اثبات طرف راست قضیه گفتیم، به ما حکم را بدون نیاز به فرض نشان می‌دهد. بنابراین فقط در مورد اثبات همین یک مورد بحث می‌کنیم. 
$$\blacktriangleright\blacktriangleright \mathsf{S=\; while\; (B)\; S_t}:$$

اگر فرض کنیم این دستور به ازای محیط $\rho$ در حالت اول متوقف شده، در واقع فرض کرده‌ایم در معنای این دستور رد پیشوندی 
$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle \pi \langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle \pi'$ 
وجود دارد.
باید ثابت کنیم به ازای $\pi'$ دلخواه اگر رد پیشوندی
$\langle at \llbracket \mathsf{S} \rrbracket , \rho \rangle \pi \langle aft \llbracket \mathsf{S} \rrbracket , \rho' \rangle \pi'$ 
داخل 
$\mathcal{S^*}\llbracket \mathsf{S} \rrbracket$
وجود داشته باشد آنگاه
$\pi'=\epsilon$
برقرار است.

اگر برچسب
$aft \llbracket \mathsf{S} \rrbracket$
در یک حالت در رد پیشوندی‌ای که گفتیم حضور داشته باشد، یعنی در یک دور اجرای حلقه عبارت بولی معنی غلط می‌داده که حالتی شامل این برچسب به یک رد پیشوندی چسبانده شده و این رد پیشوندی ساخته شده. از طرفی دیگر هم می‌دانیم که وقتی عبارت بولی حاضر در ساختار حلقه غلط شده، دیگر به ردهای پیشوندی داخل معنای حلقه چیزی اضافه نمی‌شود. بنابراین سناریو‌ای جز $\pi'=\epsilon$ باقی نمی‌ماند. 
\end{proof}

پس با توجه به آنچه گفتیم می‌توانیم با خیال راحت توقف پذیری یک برنامه با یک محیط اولیه را معادل متناهی بودن همه‌ی ردهای پیشوندی‌ای بدانیم که با محیط متناظر با آن محیط اولیه شروع شده‌اند.
اگر در صورت ارائه شده از وارسی مدل عبارت منظم $\mathsf{R}$ را با عبارت منظم $\varepsilon$ جایگزین کنیم داریم:
$$\mathsf{P},\underline{\rho} \models \mathsf{R}
\Leftrightarrow
(\{\underline{\rho}\}\times \mathcal{S}^* \llbracket \mathsf{P}\rrbracket) \subseteq 
\mathsf{prefix} (\mathcal{S}^r \llbracket \varepsilon \bullet (?:\mathit{T})^*\rrbracket)
=\mathsf{prefix} (\mathcal{S}^r \llbracket (?:\mathit{T})^*\rrbracket)$$
طبق تعریف معنای عبارات منظم، هر رد پیشوندی متناهی‌ای داخل مجموعه‌ی سمت راستی رابطه‌ی زیرمجموعه بودن قرار می‌گیرد. این یعنی اگر الگوریتمی برای بررسی 
$\mathsf{P} , \underline{\rho} \models \mathsf{R} $
داشته باشیم، این الگوریتم می‌تواند تشخیص دهد آیا برنامه‌ی $\mathsf{P}$ با محیط اولیه‌ی $\underline{\rho}$ متوقف می‌شود یا خیر! این یعنی الگوریتمی برای مسئله‌ی توقف پذیری، مسئله‌ای که تصمیم ناپذیر است! بنابراین چنین الگوریتمی نباید وجود داشته باشد که یعنی پیاده سازی‌ای برای شیوه‌ای که در حال بیانش هستیم وجود ندارد! ادامه‌ی کار روی همین تعریف پیش می‌رود و دو صورت دیگر هم که قرار است ساختارمندتر باشند در نهایت با این صورت معادل‌اند، هرچند که پس از رسیدن به بیان دو صورت دیگر خواهیم دید که همین صحبت‌هایی که در مورد این صورت می‌کنیم در مورد صورت‌های دیگر هم بدون در نظر گرفتن معادل بودن این ۳ صورت برقرار است.














